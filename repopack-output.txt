This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2025-01-15T14:11:06.157Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
accounts/admin.py
accounts/apps.py
accounts/forms.py
accounts/models.py
accounts/signals.py
accounts/templates/accounts/login.html
accounts/templates/accounts/logout.html
accounts/templates/accounts/register.html
accounts/tests.py
accounts/urls.py
accounts/views.py
clubs/admin.py
clubs/apps.py
clubs/country_locales.py
clubs/forms.py
clubs/management/commands/assign_leagues.py
clubs/management/commands/check_leagues.py
clubs/management/commands/generate_players.py
clubs/models.py
clubs/templates/clubs/club_detail.html
clubs/templates/clubs/create_club.html
clubs/templates/clubs/team_selection.html
clubs/tests.py
clubs/urls.py
clubs/views.py
core/admin.py
core/apps.py
core/models.py
core/templates/core/base.html
core/templates/core/home.html
core/tests.py
core/urls.py
core/views.py
manage.py
matches/admin.py
matches/apps.py
matches/consumers.py
matches/management/commands/test_match.py
matches/match_preparation.py
matches/match_simulation.py
matches/models.py
matches/pitch.py
matches/player_agent.py
matches/static/matches/js/live_match.js
matches/static/matches/js/match_replay.js
matches/static/matches/js/team_selection.js
matches/tasks.py
matches/templates/matches/create_match.html
matches/templates/matches/match_detail.html
matches/templates/matches/match_list.html
matches/templates/matches/team_selection.html
matches/tests.py
matches/urls.py
matches/views.py
players/admin.py
players/apps.py
players/constants.py
players/management/commands/update_player_attributes.py
players/models.py
players/player_attributes_config.py
players/templates/players/player_confirm_delete.html
players/templates/players/player_detail.html
players/tests.py
players/urls.py
players/utils.py
players/views.py
realfootballsim/__init__.py
realfootballsim/asgi.py
realfootballsim/celery.py
realfootballsim/routing.py
realfootballsim/settings.py
realfootballsim/urls.py
realfootballsim/wsgi.py
requirements.txt
static/js/team_selection.js
tournaments/admin.py
tournaments/apps.py
tournaments/context_processors.py
tournaments/date_utils.py
tournaments/management/commands/check_matches.py
tournaments/management/commands/create_new_season.py
tournaments/management/commands/create_second_division_championships.py
tournaments/management/commands/create_second_divisions.py
tournaments/management/commands/end_season.py
tournaments/management/commands/generate_all_matches.py
tournaments/management/commands/generate_championships.py
tournaments/management/commands/generate_players_for_all_teams.py
tournaments/management/commands/generate_schedule.py
tournaments/management/commands/handle_season_transitions.py
tournaments/management/commands/initialize_football_world.py
tournaments/management/commands/initialize_top_leagues.py
tournaments/management/commands/populate_first_divisions.py
tournaments/management/commands/populate_second_divisions.py
tournaments/management/commands/reset_season.py
tournaments/management/commands/run_match_checker.py
tournaments/management/commands/test_match.py
tournaments/management/commands/test_prematch.py
tournaments/management/commands/update_club_matches.py
tournaments/middleware.py
tournaments/models.py
tournaments/signals.py
tournaments/static/tournaments/css/calendar.css
tournaments/static/tournaments/js/calendar.js
tournaments/tasks.py
tournaments/templates/tournaments/base.html
tournaments/templates/tournaments/championship_detail.html
tournaments/templates/tournaments/championship_list.html
tournaments/templates/tournaments/league_list.html
tournaments/templates/tournaments/my_championship.html
tournaments/templates/tournaments/season_list.html
tournaments/templates/tournaments/timezone_selector.html
tournaments/tests.py
tournaments/tests/test_championships.py
tournaments/tests/test_season_transitions.py
tournaments/timezone_middleware.py
tournaments/urls.py
tournaments/utils.py
tournaments/views.py

================================================================
Repository Files
================================================================

================
File: accounts/admin.py
================
from django.contrib import admin
from .models import CustomUser

class CustomUserAdmin(admin.ModelAdmin):
    list_display = ('username', 'email', 'is_staff', 'last_login')  # Добавление 'email' в список
    search_fields = ('username', 'email')  # Убедитесь, что поиск по email также включен

admin.site.register(CustomUser, CustomUserAdmin)

================
File: accounts/apps.py
================
from django.apps import AppConfig

class AccountsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'accounts'

    def ready(self):
        import accounts.signals

================
File: accounts/forms.py
================
from django import forms
from django.contrib.auth.forms import UserCreationForm, AuthenticationForm
from django.contrib.auth import get_user_model

User = get_user_model()

class CustomUserCreationForm(UserCreationForm):
    email = forms.EmailField(
        widget=forms.EmailInput(attrs={
            'class': 'form-control',
            'placeholder': 'Enter your email'
        })
    )
    username = forms.CharField(
        widget=forms.TextInput(attrs={
            'class': 'form-control',
            'placeholder': 'Choose a username'
        })
    )
    password1 = forms.CharField(
        label='Password',
        widget=forms.PasswordInput(attrs={
            'class': 'form-control',
            'placeholder': 'Enter your password'
        })
    )
    password2 = forms.CharField(
        label='Confirm Password',  # Изменено с Password2 на Confirm Password
        widget=forms.PasswordInput(attrs={
            'class': 'form-control',
            'placeholder': 'Confirm your password'
        })
    )

    class Meta:
        model = User
        fields = ("username", "email", "password1", "password2")

class CustomAuthenticationForm(AuthenticationForm):
    username = forms.CharField(
        widget=forms.TextInput(attrs={
            'class': 'form-control',
            'placeholder': 'Enter your username'
        })
    )
    password = forms.CharField(
        widget=forms.PasswordInput(attrs={
            'class': 'form-control',
            'placeholder': 'Enter your password'
        })
    )

    class Meta:
        model = User
        fields = ("username", "password")

================
File: accounts/models.py
================
from django.contrib.auth.models import AbstractUser
from django.db import models

class CustomUser(AbstractUser):
    email = models.EmailField(unique=True, blank=False)

    # Поле для хранения баланса токенов
    tokens = models.PositiveIntegerField(
        default=0,
        help_text="Current balance of tokens for user."
    )

================
File: accounts/signals.py
================
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.conf import settings

@receiver(post_save, sender=settings.AUTH_USER_MODEL)
def assign_initial_tokens(sender, instance, created, **kwargs):
    if created:
        instance.tokens = 3000
        instance.save()

================
File: accounts/templates/accounts/login.html
================
{% extends 'core/base.html' %}

{% block title %}Login{% endblock %}

{% block content %}
<div class="container">
    <div class="row justify-content-center mt-5">
        <div class="col-md-6">
            <div class="card">
                <div class="card-header">
                    <h3 class="mb-0">Login</h3>
                </div>
                <div class="card-body">
                    <form method="post">
                        {% csrf_token %}
                        {% for field in form %}
                            <div class="form-group mb-3">
                                <label for="{{ field.id_for_label }}">{{ field.label }}</label>
                                {{ field }}
                                {% if field.errors %}
                                    {% for error in field.errors %}
                                        <div class="alert alert-danger mt-1">
                                            {{ error }}
                                        </div>
                                    {% endfor %}
                                {% endif %}
                            </div>
                        {% endfor %}
                        <button type="submit" class="btn btn-primary">Login</button>
                    </form>
                </div>
                <div class="card-footer">
                    <p class="mb-0">Don't have an account? <a href="{% url 'accounts:register' %}">Register here</a></p>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

================
File: accounts/templates/accounts/logout.html
================
{% extends 'core/base.html' %}

{% block title %}Logged Out{% endblock %}

{% block content %}
<div class="container">
    <div class="row justify-content-center mt-5">
        <div class="col-md-6">
            <div class="card">
                <div class="card-header">
                    <h3 class="mb-0">Logged Out</h3>
                </div>
                <div class="card-body">
                    <p>You have been successfully logged out.</p>
                    <a href="{% url 'accounts:login' %}" class="btn btn-primary">Login Again</a>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

================
File: accounts/templates/accounts/register.html
================
{% extends 'core/base.html' %}

{% block title %}Register{% endblock %}

{% block content %}
<div class="container">
    <div class="row justify-content-center mt-5">
        <div class="col-md-6">
            <div class="card">
                <div class="card-header">
                    <h3 class="mb-0">Register</h3>
                </div>
                <div class="card-body">
                    <form method="post">
                        {% csrf_token %}
                        {% for field in form %}
                            <div class="form-group mb-3">
                                <label for="{{ field.id_for_label }}">{{ field.label }}</label>
                                {{ field }}
                                {% if field.errors %}
                                    {% for error in field.errors %}
                                        <div class="alert alert-danger mt-1">
                                            {{ error }}
                                        </div>
                                    {% endfor %}
                                {% endif %}
                            </div>
                        {% endfor %}
                        <button type="submit" class="btn btn-primary">Register</button>
                    </form>
                </div>
                <div class="card-footer">
                    <p class="mb-0">Already have an account? <a href="{% url 'accounts:login' %}">Login here</a></p>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

================
File: accounts/tests.py
================
from django.test import TestCase
from django.contrib.auth import get_user_model
from django.urls import reverse

class AuthenticationTestCase(TestCase):
    def setUp(self):
        # Создание пользователя для тестирования
        self.user = get_user_model().objects.create_user(username='testuser', password='12345')

    def test_successful_login(self):
        # Отправка данных аутентификации на проверку
        response = self.client.post(reverse('login'), {'username': 'testuser', 'password': '12345'})
        # Проверка успешного входа
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, 'Вы успешно вошли в систему')

================
File: accounts/urls.py
================
from django.urls import path
from .views import RegisterView, LoginView, LogoutView

app_name = 'accounts'

urlpatterns = [
    path('register/', RegisterView.as_view(), name='register'),
    path('login/', LoginView.as_view(), name='login'),
    path('logout/', LogoutView.as_view(), name='logout'),
]

================
File: accounts/views.py
================
from django.contrib.auth import login, logout
from django.shortcuts import redirect
from django.urls import reverse_lazy
from django.views.generic import FormView
from django.contrib.auth.views import LogoutView as BaseLogoutView
from .forms import CustomUserCreationForm, CustomAuthenticationForm

class RegisterView(FormView):
    template_name = 'accounts/register.html'
    form_class = CustomUserCreationForm
    success_url = reverse_lazy('accounts:login')

    def form_valid(self, form):
        user = form.save()
        login(self.request, user)
        if hasattr(user, 'club'):
            return redirect('clubs:club_detail', user.club.pk)
        return redirect('clubs:create_club')

class LoginView(FormView):
    template_name = 'accounts/login.html'
    form_class = CustomAuthenticationForm
    
    def form_valid(self, form):
        user = form.get_user()
        login(self.request, user)
        
        if hasattr(user, 'club'):
            return redirect('clubs:club_detail', user.club.pk)
        return redirect('clubs:create_club')

class LogoutView(BaseLogoutView):
    http_method_names = ['get', 'post']
    next_page = reverse_lazy('accounts:login')

    def dispatch(self, request, *args, **kwargs):
        logout(request)
        return redirect(self.next_page)

================
File: clubs/admin.py
================
from django.contrib import admin
from .models import Club

@admin.register(Club)
class ClubAdmin(admin.ModelAdmin):
    list_display = ['name', 'country', 'owner', 'is_bot']  # явно перечисляем все поля
    list_filter = ['country', 'is_bot']
    search_fields = ['name', 'owner__username']

================
File: clubs/apps.py
================
from django.apps import AppConfig


class ClubsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'clubs'

================
File: clubs/country_locales.py
================
country_locales = {
    'GB': 'en_GB',  # Великобритания
    'ES': 'es_ES',  # Испания
    'IT': 'it_IT',  # Италия
    'DE': 'de_DE',  # Германия
    'FR': 'fr_FR',  # Франция
    'PT': 'pt_PT',  # Португалия
    'GR': 'el_GR',  # Греция
    'RU': 'ru_RU',  # Россия
    'AR': 'es_AR',  # Аргентина
    'BR': 'pt_BR',  # Бразилия
}

================
File: clubs/forms.py
================
from django import forms
from django_countries.widgets import CountrySelectWidget
from .models import Club

AVAILABLE_COUNTRIES = [
    ('GB', 'Great Britain'),
    ('ES', 'Spain'),
    ('IT', 'Italy'),
    ('DE', 'Germany'),
    ('FR', 'France'),
    ('PT', 'Portugal'),
    ('GR', 'Greece'),
    ('RU', 'Russia'),
    ('AR', 'Argentina'),
    ('BR', 'Brazil'),
]

class ClubForm(forms.ModelForm):
    country = forms.ChoiceField(
        choices=AVAILABLE_COUNTRIES,
        widget=forms.Select(attrs={'class': 'form-control'})
    )

    class Meta:
        model = Club
        fields = ['name', 'country']
        widgets = {
            'name': forms.TextInput(attrs={
                'class': 'form-control',
                'placeholder': 'Enter club name'
            }),
        }

    def clean(self):
        cleaned_data = super().clean()
        self.instance._skip_clean = True
        return cleaned_data

    def save(self, commit=True, user=None):
        instance = super().save(commit=False)
        
        if user:
            instance.owner = user
            instance.is_bot = False
        
        if commit and not hasattr(instance, '_skip_save'):
            instance._skip_save = True
            instance.save()
        
        return instance

================
File: clubs/management/commands/assign_leagues.py
================
from django.core.management.base import BaseCommand
from django.db import transaction
from clubs.models import Club
from tournaments.models import League
from django.db.models import Count

class Command(BaseCommand):
    help = 'Assigns clubs to leagues ensuring 16 teams per league'

    def handle(self, *args, **options):
        try:
            with transaction.atomic():
                # Сначала очистим существующие привязки к лигам только для ботов
                Club.objects.filter(is_bot=True).update(league=None)

                # Получаем все лиги, сортируем по стране и уровню
                leagues = League.objects.all().order_by('country', 'level')
                
                # Для каждой страны отдельно обрабатываем клубы
                for league in leagues:
                    existing_clubs = Club.objects.filter(league=league).count()
                    if existing_clubs > 0:
                        self.stdout.write(f"League {league} already has {existing_clubs} clubs")
                        continue

                    # Берем только бот-клубы без лиги из той же страны
                    available_clubs = Club.objects.filter(
                        country=league.country,
                        league__isnull=True,
                        is_bot=True  # Только боты
                    )[:16]  # Берем только 16 клубов
                    
                    if available_clubs.count() < 16:
                        self.stdout.write(
                            self.style.WARNING(
                                f"Not enough bot clubs for {league}. Found only {available_clubs.count()}"
                            )
                        )
                        continue

                    # Назначаем лигу для клубов
                    for club in available_clubs:
                        club.league = league
                        club.save()
                        
                    self.stdout.write(
                        self.style.SUCCESS(
                            f"Assigned {available_clubs.count()} bot clubs to {league}"
                        )
                    )

                # Проверяем результаты
                for league in leagues:
                    bot_count = Club.objects.filter(league=league, is_bot=True).count()
                    human_count = Club.objects.filter(league=league, is_bot=False).count()
                    self.stdout.write(f"{league}: {bot_count} bot teams, {human_count} human teams")

        except Exception as e:
            self.stdout.write(self.style.ERROR(f"Error occurred: {str(e)}"))
            raise e

================
File: clubs/management/commands/check_leagues.py
================
from django.core.management.base import BaseCommand
from django.db import transaction
from clubs.models import Club
from tournaments.models import League
from django.db.models import Count

class Command(BaseCommand):
    help = 'Checks current distribution of clubs in leagues'

    def handle(self, *args, **options):
        # Считаем команды без лиги
        unassigned_clubs = Club.objects.filter(league__isnull=True).count()
        self.stdout.write(f"\nКоманды без лиги: {unassigned_clubs}")

        # Группируем по странам
        countries = set(Club.objects.values_list('country', flat=True))
        
        self.stdout.write("\nРаспределение по странам:")
        for country in sorted(countries):
            clubs = Club.objects.filter(country=country)
            leagues = League.objects.filter(country=country).order_by('level')
            
            self.stdout.write(f"\n{country}:")
            self.stdout.write(f"Всего команд: {clubs.count()}")
            self.stdout.write(f"Количество лиг: {leagues.count()}")
            
            if leagues.exists():
                self.stdout.write("Распределение по лигам:")
                for league in leagues:
                    club_count = Club.objects.filter(league=league).count()
                    self.stdout.write(f"  {league.name} (уровень {league.level}): {club_count} команд")
            
            unassigned = clubs.filter(league__isnull=True).count()
            if unassigned > 0:
                self.stdout.write(f"Не распределено: {unassigned} команд")

================
File: clubs/management/commands/generate_players.py
================
from django.core.management.base import BaseCommand
from clubs.models import Club
from players.models import Player
from django.db import transaction
from faker import Faker
from players.utils import generate_player_stats
from clubs.views import get_locale_from_country_code
from tqdm import tqdm
import random

class Command(BaseCommand):
    help = 'Generates 5 random players for each club'

    def handle(self, *args, **options):
        clubs = Club.objects.all()
        total_clubs = clubs.count()
        
        self.stdout.write(f"Found {total_clubs} clubs. Starting player generation...")
        
        positions = [
            "Goalkeeper",
            "Right Back",
            "Center Back",
            "Left Back",
            "Defensive Midfielder",
            "Central Midfielder",
            "Attacking Midfielder",
            "Right Midfielder",
            "Left Midfielder",
            "Center Forward"
        ]

        with transaction.atomic():
            for club in tqdm(clubs, desc="Generating players"):
                # Создаем Faker с локалью, соответствующей стране клуба
                locale = get_locale_from_country_code(club.country.code)
                fake = Faker(locale)

                # Обязательно создаем вратаря
                self.create_player_for_club(
                    club=club,
                    fake=fake,
                    position="Goalkeeper",
                    player_class=random.randint(1, 4)
                )
                
                # Создаем еще 4 случайных полевых игрока
                for _ in range(4):
                    # Исключаем вратаря из случайного выбора позиций
                    position = random.choice([pos for pos in positions if pos != "Goalkeeper"])
                    self.create_player_for_club(
                        club=club,
                        fake=fake,
                        position=position,
                        player_class=random.randint(1, 4)
                    )
        
        self.stdout.write(self.style.SUCCESS(
            f'Successfully generated {total_clubs * 5} players for {total_clubs} clubs'
        ))

    def create_player_for_club(self, club, fake, position, player_class):
        """Создает одного игрока для клуба"""
        # Генерируем уникальное имя
        while True:
            first_name = fake.first_name_male()
            last_name = fake.last_name_male() if hasattr(fake, 'last_name_male') else fake.last_name()
            if not Player.objects.filter(first_name=first_name, last_name=last_name).exists():
                break

        # Генерируем характеристики в зависимости от позиции
        stats = generate_player_stats(position, player_class)

        if position == 'Goalkeeper':
            player = Player.objects.create(
                club=club,
                first_name=first_name,
                last_name=last_name,
                nationality=club.country,
                age=17,
                position=position,
                player_class=player_class,
                strength=stats['strength'],
                stamina=stats['stamina'],
                pace=stats['pace'],
                positioning=stats['positioning'],
                reflexes=stats['reflexes'],
                handling=stats['handling'],
                aerial=stats['aerial'],
                jumping=stats['jumping'],
                command=stats['command'],
                throwing=stats['throwing'],
                kicking=stats['kicking']
            )
        else:
            player = Player.objects.create(
                club=club,
                first_name=first_name,
                last_name=last_name,
                nationality=club.country,
                age=17,
                position=position,
                player_class=player_class,
                strength=stats['strength'],
                stamina=stats['stamina'],
                pace=stats['pace'],
                marking=stats['marking'],
                tackling=stats['tackling'],
                work_rate=stats['work_rate'],
                positioning=stats['positioning'],
                passing=stats['passing'],
                crossing=stats['crossing'],
                dribbling=stats['dribbling'],
                ball_control=stats['ball_control'],
                heading=stats['heading'],
                finishing=stats['finishing'],
                long_range=stats['long_range'],
                vision=stats['vision']
            )

        return player

================
File: clubs/models.py
================
from django.db import models
from django.conf import settings
from django_countries.fields import CountryField
from django.core.exceptions import ValidationError

class Club(models.Model):
    name = models.CharField(max_length=100, verbose_name="Club Name")
    country = CountryField(blank_label='(select country)', verbose_name="Country")
    owner = models.OneToOneField(
        settings.AUTH_USER_MODEL, 
        on_delete=models.CASCADE, 
        verbose_name="Owner", 
        related_name="club",
        null=True,
        blank=True
    )
    league = models.ForeignKey(
        'tournaments.League',
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='clubs'
    )
    lineup = models.JSONField(null=True, blank=True)
    is_bot = models.BooleanField(
        default=False,
        verbose_name="Bot Team",
        help_text="Indicates if this team is controlled by AI"
    )
    promoted = models.BooleanField(
        default=False,
        help_text="Команда повышена в классе"
    )
    relegated = models.BooleanField(
        default=False,
        help_text="Команда понижена в классе"
    )

    def __str__(self):
        return self.name

    def clean(self):
        if hasattr(self, '_skip_clean'):
            return
            
        if not self.is_bot and not self.owner:
            raise ValidationError("Non-bot teams must have an owner")

    def save(self, *args, **kwargs):
        if not hasattr(self, '_skip_clean'):
            self.full_clean()
        super().save(*args, **kwargs)

================
File: clubs/templates/clubs/club_detail.html
================
{% extends 'core/base.html' %}

{% block title %}{{ club.name }}{% endblock %}

{% block content %}
<div class="container">
    <!-- Club Header Section -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="d-flex justify-content-between align-items-start">
                <div>
                    <h1>
                        {{ club.name }}
                        {% if club.is_bot %}
                            <span class="badge bg-secondary">BOT</span>
                        {% endif %}
                    </h1>
                    <div class="club-info">
                        <p class="mb-1">
                            <strong>Country:</strong> {{ club.country }}
                        </p>
                        <p class="mb-1">
                            <strong>League:</strong> {{ club.league.name }} (Division {{ club.league.level }})
                        </p>
                        <p class="mb-1">
                            <strong>Status:</strong>
                            {% if club.is_bot %}
                                <span class="text-muted">AI Controlled</span>
                            {% else %}
                                Owned by {{ club.owner.username }}
                            {% endif %}
                        </p>
                        {% if user == club.owner %}
                            <p class="mb-1">
                                <strong>Your tokens:</strong> {{ user.tokens }}
                            </p>
                        {% endif %}
                    </div>
                </div>
                {% if user == club.owner %}
                <div>
                    <a href="{% url 'clubs:team_selection' club.id %}" class="btn btn-primary">
                        Select Team Lineup
                    </a>
                </div>
                {% endif %}
            </div>
        </div>
    </div>

    <!-- Players Section -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title h4 mb-0">Players</h2>
                </div>
                <div class="card-body">
                    {% if user == club.owner %}
                    <!-- Player Cost Info -->
                    <div class="alert alert-info mb-3">
                        <h5>Cost to create a player:</h5>
                        <ul class="mb-2">
                            <li>Class 1: {{ player_prices.1 }} tokens</li>
                            <li>Class 2: {{ player_prices.2 }} tokens</li>
                            <li>Class 3: {{ player_prices.3 }} tokens</li>
                            <li>Class 4: {{ player_prices.4 }} tokens</li>
                        </ul>
                        <strong>Your current balance: {{ user.tokens }} tokens</strong>
                    </div>
                    
                    <div class="row mb-3">
                        <div class="col-12">
                            <form method="get" action="{% url 'clubs:create_player' club.id %}" class="row g-3">
                                <div class="col-md-4">
                                    <label for="position" class="form-label">Choose Position:</label>
                                    <select class="form-select" id="position" name="position" required>
                                        <option value="">Select a position</option>
                                        <option value="Goalkeeper">Goalkeeper</option>
                                        <option value="Right Back">Right Back</option>
                                        <option value="Left Back">Left Back</option>
                                        <option value="Center Back">Center Back</option>
                                        <option value="Defensive Midfielder">Defensive Midfielder</option>
                                        <option value="Right Midfielder">Right Midfielder</option>
                                        <option value="Central Midfielder">Central Midfielder</option>
                                        <option value="Left Midfielder">Left Midfielder</option>
                                        <option value="Attacking Midfielder">Attacking Midfielder</option>
                                        <option value="Center Forward">Center Forward</option>
                                    </select>
                                </div>
                                <div class="col-md-4">
                                    <label for="player_class" class="form-label">Choose Player Class:</label>
                                    <select class="form-select" id="player_class" name="player_class" required>
                                        <option value="">Select a class</option>
                                        <option value="1">Class 1</option>
                                        <option value="2">Class 2</option>
                                        <option value="3">Class 3</option>
                                        <option value="4">Class 4</option>
                                    </select>
                                </div>
                                <div class="col-md-4 d-flex align-items-end gap-2">
                                    <button type="submit" class="btn btn-primary">Create Player</button>
                                    <a href="{% url 'matches:simulate_match' 0 %}" class="btn btn-primary" target="_blank">Create New Match</a>
                                </div>
                            </form>
                        </div>
                    </div>
                    {% endif %}
                    
                    <div class="table-responsive">
                        <table class="table">
                            <thead>
                                <tr>
                                    <th>Name</th>
                                    <th>Position</th>
                                    <th>Class</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                {% for player in players %}
                                <tr>
                                    <td>{{ player.first_name }} {{ player.last_name }}</td>
                                    <td>
                                        <span class="badge bg-primary">{{ player.position }}</span>
                                    </td>
                                    <td>
                                        {% if player.player_class %}
                                            <span class="badge bg-info">Class {{ player.player_class }}</span>
                                        {% endif %}
                                    </td>
                                    <td>
                                        <a href="{% url 'players:player_detail' player.pk %}" 
                                           class="btn btn-sm btn-outline-primary">
                                            View Details
                                        </a>
                                    </td>
                                </tr>
                                {% empty %}
                                <tr>
                                    <td colspan="4" class="text-center">No players found</td>
                                </tr>
                                {% endfor %}
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

================
File: clubs/templates/clubs/create_club.html
================
{% extends 'core/base.html' %}
{% block title %}Create Club{% endblock %}

{% block content %}
<div class="container">
    <div class="row">
        <div class="col-md-6 offset-md-3">
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title mb-0">Create New Club</h3>
                </div>
                <div class="card-body">
                    <form method="post">
                        {% csrf_token %}
                        {% for field in form %}
                            <div class="form-group mb-3">
                                <label for="{{ field.id_for_label }}" class="form-label">{{ field.label }}</label>
                                {{ field }}
                                {% if field.help_text %}
                                    <small class="form-text text-muted">{{ field.help_text }}</small>
                                {% endif %}
                                {% if field.errors %}
                                    {% for error in field.errors %}
                                        <div class="alert alert-danger mt-1">
                                            {{ error }}
                                        </div>
                                    {% endfor %}
                                {% endif %}
                            </div>
                        {% endfor %}
                        {% if form.non_field_errors %}
                            {% for error in form.non_field_errors %}
                                <div class="alert alert-danger">
                                    {{ error }}
                                </div>
                            {% endfor %}
                        {% endif %}
                        <div class="d-grid">
                            <button type="submit" class="btn btn-primary">Create Club</button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

================
File: clubs/templates/clubs/team_selection.html
================
{% extends 'core/base.html' %}
{% load static %}

{% block title %}Team Selection - {{ club.name }}{% endblock %}

{% block content %}
{% csrf_token %}
<div class="container">
    <div class="row">
        <div class="col-12">
            <div class="card mb-4">
                <div class="card-header">
                    <div class="d-flex justify-content-between align-items-center">
                        <h2 class="mb-0">Team Selection</h2>
                        <a href="{% url 'clubs:club_detail' club.id %}" class="btn btn-outline-secondary">Back to Club</a>
                    </div>
                </div>
                <div class="card-body">
                    <div class="tactics-section">
                        <label for="tacticSelect"><strong>Select Tactic:</strong></label>
                        <select id="tacticSelect">
                            <option value="attacking">Attacking</option>
                            <option value="balanced" selected>Balanced</option>
                            <option value="defensive">Defensive</option>
                        </select>
                    </div>

                    <div class="pitch" id="pitch">
                        <!-- Player slots will be added here dynamically -->
                    </div>

                    <div class="text-center mt-4">
                        <button id="resetButton" class="btn btn-warning">Reset Lineup</button>
                        <div id="saveStatus" class="mt-2"></div>
                    </div>

                    <div class="mt-4">
                        <h3 class="h4 mb-3">Available Players</h3>
                        <div class="player-list" id="playerList">
                            <!-- Available players will be added here dynamically -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<input type="hidden" id="clubId" value="{{ club.id }}">

<style>
    .pitch {
        width: 100%;
        max-width: 800px;
        height: 600px;
        background-color: #4CAF50;
        background-image: 
            linear-gradient(#ffffff 1px, transparent 1px),
            linear-gradient(90deg, #ffffff 1px, transparent 1px);
        background-size: 50px 50px;
        position: relative;
        margin: 0 auto;
        border: 2px solid #388E3C;
        border-radius: 8px;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }

    .pitch::before {
        content: '';
        position: absolute;
        top: 50%;
        left: 0;
        right: 0;
        height: 2px;
        background-color: rgba(255, 255, 255, 0.5);
    }

    .pitch::after {
        content: '';
        position: absolute;
        top: 25%;
        bottom: 25%;
        left: 50%;
        width: 2px;
        background-color: rgba(255, 255, 255, 0.5);
        transform: translateX(-50%);
    }

    .player-slot {
        width: 70px;
        height: 70px;
        position: absolute;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 12px;
        transition: all 0.2s ease;
        transform: translate(-50%, -50%);
        border-radius: 50%;
    }

    .player-slot.empty {
        background-color: transparent;
        border: none;
    }

    .player-slot.empty .position-label {
        opacity: 0;
        transition: opacity 0.2s ease;
    }

    .player-slot.highlight {
        background-color: rgba(255, 255, 255, 0.2);
        border: 2px dashed rgba(255, 255, 255, 0.8);
    }

    .player-slot.highlight .position-label {
        opacity: 1;
    }

    .player-slot.dragover {
        background-color: rgba(255, 255, 255, 0.4);
        border: 2px solid rgba(255, 255, 255, 0.9);
        box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
    }

    .player-slot:not(.empty) {
        background-color: rgba(255, 255, 255, 0.8);
        border: 2px solid #fff;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .player-slot:not(.empty) .position-label {
        opacity: 1;
    }

    .position-label {
        position: absolute;
        bottom: -20px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 12px;
        color: white;
        text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        font-weight: bold;
        background-color: rgba(0,0,0,0.3);
        padding: 2px 6px;
        border-radius: 3px;
        pointer-events: none;
        transition: opacity 0.2s ease;
    }

    .player-list {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        padding: 15px;
        background-color: #f8f9fa;
        border-radius: 8px;
        min-height: 100px;
    }

    .player-item {
        width: 130px;
        height: 70px;
        background-color: #fff;
        padding: 8px;
        cursor: move;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        font-size: 12px;
        text-align: center;
        border-radius: 6px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        transition: all 0.2s ease;
        margin: 0;
    }

    .player-item:hover {
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        transform: translateY(-2px);
    }

    .player-item.goalkeeper {
        background-color: #fff3cd;
        border-left: 4px solid #ffc107;
    }

    .player-item.defender {
        background-color: #cfe2ff;
        border-left: 4px solid #0d6efd;
    }

    .player-item.midfielder {
        background-color: #d1e7dd;
        border-left: 4px solid #198754;
    }

    .player-item.forward {
        background-color: #f8d7da;
        border-left: 4px solid #dc3545;
    }

    .player-name {
        font-weight: bold;
        margin-bottom: 4px;
    }

    .player-position {
        font-size: 11px;
        color: #6c757d;
    }

    .sortable-ghost {
        opacity: 0.4;
    }

    .sortable-chosen {
        opacity: 0.8;
        transform: scale(1.05);
    }

    .sortable-drag {
        opacity: 0.8;
    }

    #saveStatus {
        min-height: 24px;
        transition: all 0.3s ease;
    }

    #saveStatus.alert {
        display: inline-block;
        padding: 0.5rem 1rem;
        margin: 0;
        font-size: 14px;
    }
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.14.0/Sortable.min.js"></script>
<script src="{% static 'js/team_selection.js' %}"></script>
{% endblock %}

================
File: clubs/tests.py
================
from django.test import TestCase

# Create your tests here.

================
File: clubs/urls.py
================
from django.urls import path
from . import views

app_name = 'clubs'

urlpatterns = [
    path('create/', views.CreateClubView.as_view(), name='create_club'),
    path('detail/<int:pk>/', views.ClubDetailView.as_view(), name='club_detail'),
    path('detail/<int:pk>/create_player/', views.create_player, name='create_player'),
    path('detail/<int:pk>/team-selection/', views.team_selection_view, name='team_selection'),
    path('detail/<int:pk>/get-players/', views.get_players, name='get_players'),
    path('detail/<int:pk>/save-team-lineup/', views.save_team_lineup, name='save_team_lineup'),
    path('detail/<int:pk>/get-team-lineup/', views.get_team_lineup, name='get_team_lineup'),
    
]

================
File: clubs/views.py
================
# clubs/views.py
import json
import random
import logging

from django.shortcuts import redirect, render, get_object_or_404
from django.views.generic import CreateView, DetailView
from django.contrib import messages
from django.http import JsonResponse, HttpResponse
from django.views.decorators.http import require_http_methods
from django.views.decorators.csrf import ensure_csrf_cookie
from django.db import transaction
from faker import Faker

from .models import Club
from .forms import ClubForm
from .country_locales import country_locales
from players.models import Player
from players.utils import generate_player_stats
from players.constants import PLAYER_PRICES
from tournaments.models import Championship, League

logger = logging.getLogger(__name__)


class CreateClubView(CreateView):
    """
    Представление для создания нового клуба.
    """
    model = Club
    form_class = ClubForm
    template_name = 'clubs/create_club.html'

    def form_valid(self, form):
        try:
            with transaction.atomic():
                club = form.save(commit=False)
                club.owner = self.request.user
                club.is_bot = False
                club._skip_clean = True

                league = League.objects.filter(
                    country=club.country,
                    level=1
                ).first()
                if not league:
                    messages.error(
                        self.request,
                        f'League not found for country {club.country.name}'
                    )
                    return self.form_invalid(form)

                club.league = league
                club.save()

                if not club.id:
                    messages.error(
                        self.request,
                        "Error creating club: no ID received"
                    )
                    return self.form_invalid(form)

                messages.info(self.request, f"Club created with ID: {club.id}")

                championship = Championship.objects.filter(
                    teams=club,
                    season__is_active=True
                ).first()
                if championship:
                    messages.success(
                        self.request,
                        f'Club "{club.name}" successfully created and added to {championship.league.name}!'
                    )
                else:
                    active_season = Championship.objects.filter(
                        season__is_active=True
                    ).exists()
                    if not active_season:
                        messages.warning(
                            self.request,
                            'No active season in the system.'
                        )
                    else:
                        messages.warning(
                            self.request,
                            f'Club "{club.name}" created but not added to championship. Possibly no free spots.'
                        )

                return redirect('clubs:club_detail', pk=club.id)

        except Exception as e:
            logger.error(f'Error creating club: {str(e)}')
            messages.error(self.request, f'Error creating club: {str(e)}')
            return self.form_invalid(form)

    def form_invalid(self, form):
        messages.error(
            self.request,
            'Error creating club. Please check your input.'
        )
        return super().form_invalid(form)


class ClubDetailView(DetailView):
    """
    Детальная страница клуба, где отображаются игроки и другая информация.
    """
    model = Club
    template_name = 'clubs/club_detail.html'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['players'] = Player.objects.filter(club=self.object)
        context['player_prices'] = PLAYER_PRICES

        championship = Championship.objects.filter(
            teams=self.object,
            season__is_active=True
        ).first()
        context['championship'] = championship

        return context


def get_locale_from_country_code(country_code):
    """
    Возвращает строку локали (например, 'en_GB') для заданного кода страны.
    """
    return country_locales.get(country_code, 'en_US')


@require_http_methods(["GET"])
def create_player(request, pk):
    """
    Создаёт нового игрока в клубе (через GET-параметры: position, player_class).
    """
    club = get_object_or_404(Club, pk=pk)
    if club.owner != request.user:
        return HttpResponse("You don't have permission to create players in this club.", status=403)

    position = request.GET.get('position')
    player_class = int(request.GET.get('player_class', 1))

    cost = PLAYER_PRICES.get(player_class, 200)

    if request.user.tokens < cost:
        messages.error(request, f'Insufficient tokens. Required: {cost}')
        return redirect('clubs:club_detail', pk=pk)

    if not position:
        return HttpResponse("Please select a position.")

    country_code = club.country.code
    locale = get_locale_from_country_code(country_code)
    fake = Faker(locale)

    attempts = 0
    max_attempts = 100
    while attempts < max_attempts:
        first_name = fake.first_name_male()
        last_name = (
            fake.last_name_male()
            if hasattr(fake, 'last_name_male')
            else fake.last_name()
        )
        if not Player.objects.filter(first_name=first_name, last_name=last_name).exists():
            break
        attempts += 1

    if attempts >= max_attempts:
        messages.error(request, 'Failed to create unique name for player')
        return redirect('clubs:club_detail', pk=pk)

    try:
        stats = generate_player_stats(position, player_class)

        player = Player.objects.create(
            club=club,
            first_name=first_name,
            last_name=last_name,
            nationality=club.country,
            age=random.randint(17, 35),
            position=position,
            player_class=player_class,
            **stats
        )

        request.user.tokens -= cost
        request.user.save()

        messages.success(request, f'Successfully deducted {cost} tokens')
        messages.success(
            request,
            f'Player {player.first_name} {player.last_name} successfully created!'
        )
    except Exception as e:
        messages.error(request, f'Error creating player: {str(e)}')
        logger.error(f'Error creating player: {str(e)}')

    return redirect('clubs:club_detail', pk=pk)


@require_http_methods(["GET"])
def team_selection_view(request, pk):
    """
    Страница выбора состава (drag-and-drop).
    """
    club = get_object_or_404(Club, pk=pk)
    if club.owner != request.user:
        messages.error(request, "You don't have permission to view this page.")
        return redirect('clubs:club_detail', pk=pk)

    context = {
        'club': club,
        'current_section': 'team_selection'
    }
    return render(request, 'clubs/team_selection.html', context)


@require_http_methods(["GET"])
def get_players(request, pk):
    """
    Возвращает JSON со списком игроков клуба.
    """
    club = get_object_or_404(Club, pk=pk)
    if club.owner != request.user:
        return JsonResponse({"error": "Access denied"}, status=403)

    players = Player.objects.filter(club=club)
    data = []
    for p in players:
        data.append({
            'id': p.id,
            'name': f"{p.first_name} {p.last_name}",
            'position': p.position,  # например "Attacking Midfielder"
            'playerClass': p.player_class,
            'attributes': {
                'stamina': p.stamina,
                'strength': p.strength,
                'speed': p.pace
            }
        })
    return JsonResponse(data, safe=False)


@ensure_csrf_cookie
@require_http_methods(["POST"])
def save_team_lineup(request, pk):
    """
    Сохраняет состав (lineup) и тактику.
    Ожидаем структуру вида:
      {
        "lineup": {
          "0": {
            "playerId": "123",
            "playerPosition": "Defensive Midfielder",
            "slotType": "ldm",
            "slotLabel": "LDM"
          },
          ...
        },
        "tactic": "balanced"
      }
    """
    try:
        club = get_object_or_404(Club, pk=pk)
        if club.owner != request.user:
            return JsonResponse({"error": "Access denied"}, status=403)

        data = json.loads(request.body)
        raw_lineup = data.get('lineup', {})
        tactic = data.get('tactic', 'balanced')

        logger.debug(f"save_team_lineup() received data: {data}")

        if len(raw_lineup) > 11:
            return JsonResponse({
                "success": False,
                "error": "Squad cannot have more than 11 players"
            }, status=400)

        has_goalkeeper = False

        for slot_idx, slot_info in raw_lineup.items():
            if not isinstance(slot_info, dict):
                return JsonResponse({
                    "success": False,
                    "error": "Invalid format: each slot must be an object"
                }, status=400)

            p_id  = slot_info.get("playerId")
            p_pos = slot_info.get("playerPosition", "")
            s_type = slot_info.get("slotType", "")
            s_label = slot_info.get("slotLabel", "")

            try:
                p_obj = Player.objects.get(id=p_id)
            except Player.DoesNotExist:
                return JsonResponse({
                    "success": False,
                    "error": f"Player {p_id} does not exist"
                }, status=400)

            if p_obj.club_id != club.id:
                return JsonResponse({
                    "success": False,
                    "error": f"Player {p_id} does not belong to club {club.id}"
                }, status=400)

            # Проверяем наличие хотя бы одного вратаря
            if "goalkeeper" in p_pos.lower():
                has_goalkeeper = True

            # Дополнительная валидация можно делать здесь, если нужно.

            # Пример: если slotType = "ldm", убедиться, что p_pos включает "Defensive Midfielder"

        if not has_goalkeeper:
            return JsonResponse({
                "success": False,
                "error": "Squad must include a goalkeeper"
            }, status=400)

        # Сохраняем
        club.lineup = {
            "lineup": raw_lineup,
            "tactic": tactic
        }
        club.save()

        return JsonResponse({
            "success": True,
            "message": "Lineup and tactics saved successfully"
        })

    except json.JSONDecodeError:
        logger.error("JSONDecodeError: Cannot decode JSON from request body")
        return JsonResponse({"success": False, "error": "Invalid JSON"}, status=400)
    except Exception as e:
        logger.error(f"Error saving team lineup: {str(e)}")
        return JsonResponse({"success": False, "error": str(e)}, status=500)


@require_http_methods(["GET"])
def get_team_lineup(request, pk):
    """
    Возвращаем сохранённый состав.
    """
    club = get_object_or_404(Club, pk=pk)
    if club.owner != request.user:
        return JsonResponse({"error": "Access denied"}, status=403)

    data = club.lineup or {}
    lineup_data = data.get('lineup', {})
    tactic = data.get('tactic', 'balanced')

    response = {
        'lineup': lineup_data,
        'tactic': tactic,
        'players': {}
    }

    pids = []
    for info in lineup_data.values():
        if isinstance(info, dict):
            pid = info.get('playerId')
            if pid:
                pids.append(pid)

    if pids:
        qs = Player.objects.filter(id__in=pids)
        for pl in qs:
            response['players'][str(pl.id)] = {
                'name': f"{pl.first_name} {pl.last_name}",
                'position': pl.position,
                'playerClass': pl.player_class
            }

    return JsonResponse(response)

================
File: core/admin.py
================
from django.contrib import admin

# Register your models here.

================
File: core/apps.py
================
from django.apps import AppConfig


class CoreConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'core'

================
File: core/models.py
================
from django.db import models

# Create your models here.

================
File: core/templates/core/base.html
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Football Manager{% endblock %}</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    {% block extra_css %}{% endblock %}
</head>
<body>
    {% csrf_token %}
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container">
            <a class="navbar-brand" href="{% url 'home' %}">Football Manager</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav me-auto">
                    {% if user.is_authenticated %}
                        <li class="nav-item">
                            {% if user.club and user.club.id %}
                                <a class="nav-link" href="{% url 'clubs:club_detail' user.club.id %}">My Club</a>
                            {% else %}
                                <a class="nav-link" href="{% url 'clubs:create_club' %}">Create Club</a>
                            {% endif %}
                        </li>
                        <li class="nav-item">
                            {% if user.club and user.club.id %}
                                <a class="nav-link" href="{% url 'tournaments:my_championship' %}">Tournaments</a>
                            {% else %}
                                <a class="nav-link" href="{% url 'tournaments:championship_list' %}">Tournaments</a>
                            {% endif %}
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="{% url 'matches:match_list' %}">Matches</a>
                        </li>
                    {% endif %}
                </ul>
                <ul class="navbar-nav">
                    {% if user.is_authenticated %}
                        <li class="nav-item">
                            <a class="nav-link" href="{% url 'accounts:logout' %}">Logout</a>
                        </li>
                    {% else %}
                        <li class="nav-item">
                            <a class="nav-link" href="{% url 'accounts:login' %}">Login</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="{% url 'accounts:register' %}">Register</a>
                        </li>
                    {% endif %}
                </ul>
            </div>
        </div>
    </nav>

    <div class="container mt-4">
        {% if messages %}
            {% for message in messages %}
                <div class="alert alert-{{ message.tags }} alert-dismissible fade show" role="alert">
                    {{ message }}
                    <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                </div>
            {% endfor %}
        {% endif %}
        
        {% block content %}{% endblock %}
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    {% block extra_js %}{% endblock %}
</body>
</html>

================
File: core/templates/core/home.html
================
{% extends 'core/base.html' %}

{% block content %}
<div class="container">
    <div class="row justify-content-center">
        <div class="col-md-10">
            <div class="text-center mb-5">
                <h1 class="display-4">Welcome to Football Manager</h1>
                <p class="lead">Manage your team and compete in championships!</p>
            </div>

            {% if user.is_authenticated %}
                {% if user.club %}
                <div class="row mb-4">
                    <div class="col-md-6">
                        <div class="card">
                            <div class="card-header">
                                <h3 class="card-title h5 mb-0">Your Club</h3>
                            </div>
                            <div class="card-body">
                                <h4 class="h5">{{ user.club.name }}</h4>
                                <p class="mb-2">
                                    <strong>League:</strong> {{ user.club.league.name }}
                                </p>
                                <a href="{% url 'clubs:club_detail' user.club.id %}" 
                                   class="btn btn-primary">View Club</a>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="card">
                            <div class="card-header">
                                <h3 class="card-title h5 mb-0">Quick Actions</h3>
                            </div>
                            <div class="card-body">
                                <div class="d-grid gap-2">
                                    <a href="{% url 'tournaments:championship_detail' user.club.championship_set.first.id %}" 
                                       class="btn btn-outline-primary">View Championship</a>
                                    <a href="{% url 'clubs:team_selection' user.club.id %}" 
                                       class="btn btn-outline-primary">Select Team</a>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                {% else %}
                <div class="text-center mb-4">
                    <a href="{% url 'clubs:create_club' %}" class="btn btn-primary btn-lg">Create Your Club</a>
                </div>
                {% endif %}
            {% else %}
            <div class="row justify-content-center">
                <div class="col-md-6">
                    <div class="card">
                        <div class="card-body text-center">
                            <h3 class="h4 mb-4">Get Started</h3>
                            <div class="d-grid gap-3">
                                <a href="{% url 'login' %}" class="btn btn-primary btn-lg">Login</a>
                                <a href="{% url 'register' %}" class="btn btn-outline-primary btn-lg">Register</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            {% endif %}

            {% if championships %}
            <div class="mt-5">
                <h2 class="h3 mb-4">Active Championships</h2>
                <div class="row">
                    {% for championship in championships %}
                    <div class="col-md-4 mb-3">
                        <div class="card h-100">
                            <div class="card-body">
                                <h5 class="card-title">{{ championship.league.name }}</h5>
                                <p class="card-text">
                                    <small class="text-muted">
                                        {{ championship.league.country.name }} - 
                                        Division {{ championship.league.level }}
                                    </small>
                                </p>
                                <a href="{% url 'tournaments:championship_detail' championship.id %}" 
                                   class="btn btn-outline-primary btn-sm">View Details</a>
                            </div>
                        </div>
                    </div>
                    {% endfor %}
                </div>
            </div>
            {% endif %}
        </div>
    </div>
</div>
{% endblock %}

================
File: core/tests.py
================
from django.test import TestCase

# Create your tests here.

================
File: core/urls.py
================
from django.urls import path
from .views import home

urlpatterns = [
    path('', home, name='home'),
]

================
File: core/views.py
================
from django.shortcuts import render, redirect
from django.contrib.auth.decorators import login_required

def home(request):
    if request.user.is_authenticated:
        if hasattr(request.user, 'club'):
            return redirect('clubs:club_detail', pk=request.user.club.id)
        return redirect('clubs:create_club')
    return redirect('accounts:login')  # Исправлено: добавлен namespace

================
File: manage.py
================
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'realfootballsim.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()

================
File: matches/admin.py
================
from django.contrib import admin
from django.contrib.admin import DateFieldListFilter
from .models import Match, MatchEvent

@admin.register(Match)
class MatchAdmin(admin.ModelAdmin):
    list_display = ('home_team', 'away_team', 'datetime', 'status', 'processed')
    list_filter = ('status', ('datetime', DateFieldListFilter), 'processed')
    search_fields = ('home_team__name', 'away_team__name')

@admin.register(MatchEvent)
class MatchEventAdmin(admin.ModelAdmin):
    list_display = ('match', 'minute', 'event_type', 'player')
    list_filter = ('event_type', 'match')
    search_fields = ('match__home_team__name', 'match__away_team__name', 'player__first_name', 'player__last_name')

================
File: matches/apps.py
================
from django.apps import AppConfig


class MatchesConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'matches'

================
File: matches/consumers.py
================
import json
from channels.generic.websocket import AsyncWebsocketConsumer
from channels.db import database_sync_to_async
from .models import Match

class MatchConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        print("WebSocket connect attempt...")
        self.match_id = self.scope['url_route']['kwargs']['match_id']
        self.group_name = f"match_{self.match_id}"

        try:
            await self.channel_layer.group_add(
                self.group_name,
                self.channel_name
            )
            
            await self.accept()
            
            # Получаем и отправляем начальные данные
            match = await self.get_match_data()
            if match:
                await self.send(text_data=json.dumps(match))
                print("Initial match data sent")
            else:
                print(f"No match data found for ID: {self.match_id}")
                
        except Exception as e:
            print(f"Error in connect: {str(e)}")
            raise

    async def disconnect(self, close_code):
        print(f"WebSocket disconnecting... Code: {close_code}")
        try:
            await self.channel_layer.group_discard(
                self.group_name,
                self.channel_name
            )
            print("Successfully removed from channel group")
        except Exception as e:
            print(f"Error in disconnect: {str(e)}")

    async def match_update(self, event):
        """Стандартное событие для отправки полного обновления матча"""
        try:
            data = event['data']
            # Проверяем наличие всех необходимых полей
            required_fields = ['minute', 'home_score', 'away_score', 'events', 'status']
            if not all(field in data for field in required_fields):
                print(f"Warning: missing required fields in update. Got: {data.keys()}")
                # Получаем недостающие данные из БД
                match_data = await self.get_match_data()
                if match_data:
                    # Обновляем только новые данные
                    match_data.update(data)
                    data = match_data

            await self.send(text_data=json.dumps(data))
            print("Successfully sent match update to client")
            
        except Exception as e:
            print(f"Error in match_update: {str(e)}")

    async def match_partial_update(self, event):
        """Частичное обновление тоже должно содержать все поля"""
        await self.match_update(event)

    @database_sync_to_async
    def get_match_data(self):
        try:
            match = Match.objects.get(id=self.match_id)
            return {
                "minute": match.current_minute,
                "home_score": match.home_score,
                "away_score": match.away_score,
                "events": list(
                    match.events.all().values(
                        'minute', 
                        'event_type', 
                        'description'
                    ).order_by('-minute')[:10]  # Последние 10 событий
                ),
                "status": match.status
            }
        except Match.DoesNotExist:
            print(f"Match {self.match_id} not found")
            return None
        except Exception as e:
            print(f"Error getting match data: {str(e)}")
            return None

================
File: matches/management/commands/test_match.py
================
from django.core.management.base import BaseCommand
from django.utils import timezone
from clubs.models import Club
from matches.models import Match
from matches.match_simulation import MatchSimulation
import random

class Command(BaseCommand):
    help = 'Tests match simulation with random teams'

    def handle(self, *args, **options):
        try:
            # Get random teams
            teams = list(Club.objects.all().order_by('?')[:2])
            if len(teams) < 2:
                self.stdout.write(self.style.ERROR('Not enough teams in database'))
                return

            home_team = teams[0]
            away_team = teams[1]

            # Display team information
            self.stdout.write('\nTeam Information:')
            self.stdout.write(f'\nHome team: {home_team.name}')
            self.stdout.write(f'Players: {home_team.player_set.count()}')
            
            self.stdout.write(f'\nAway team: {away_team.name}')
            self.stdout.write(f'Players: {away_team.player_set.count()}\n')

            # Create test match
            match = Match.objects.create(
                home_team=home_team,
                away_team=away_team,
                date=timezone.now(),
                status='scheduled'
            )

            # Initialize simulation
            simulation = MatchSimulation(match)
            
            # Simulate match
            self.stdout.write('\n=== MATCH START ===\n')
            
            for minute in range(90):
                if minute % 5 == 0:  # Show status every 5 minutes
                    self.stdout.write(f'\n=== MINUTE {minute} ===')
                    self.stdout.write(f'Score: {match.home_score} - {match.away_score}')
                    self.stdout.write(f'Possession: {simulation.match_stats["home"]["possession"]}% - {simulation.match_stats["away"]["possession"]}%')
                    self.stdout.write(f'Shots (on target): {simulation.match_stats["home"]["shots"]} ({simulation.match_stats["home"]["shots_on_target"]}) - {simulation.match_stats["away"]["shots"]} ({simulation.match_stats["away"]["shots_on_target"]})')
                
                simulation.simulate_minute(minute)
                
                # Show events immediately after they happen
                events = match.events.filter(minute=minute)
                for event in events:
                    self.stdout.write(f'{event.minute}\' - {event.description}')
            
            # Final statistics
            self.stdout.write('\n=== FINAL STATISTICS ===')
            self.stdout.write(f'\nFinal score: {match.home_score} - {match.away_score}')
            
            self.stdout.write('\nHome team statistics:')
            self.stdout.write(f'Possession: {simulation.match_stats["home"]["possession"]}%')
            self.stdout.write(f'Shots (on target): {simulation.match_stats["home"]["shots"]} ({simulation.match_stats["home"]["shots_on_target"]})')
            self.stdout.write(f'Corners: {simulation.match_stats["home"]["corners"]}')
            self.stdout.write(f'Fouls: {simulation.match_stats["home"]["fouls"]}')
            self.stdout.write(f'Attacks (dangerous): {simulation.match_stats["home"]["attacks"]} ({simulation.match_stats["home"]["dangerous_attacks"]})')
            
            self.stdout.write('\nAway team statistics:')
            self.stdout.write(f'Possession: {simulation.match_stats["away"]["possession"]}%')
            self.stdout.write(f'Shots (on target): {simulation.match_stats["away"]["shots"]} ({simulation.match_stats["away"]["shots_on_target"]})')
            self.stdout.write(f'Corners: {simulation.match_stats["away"]["corners"]}')
            self.stdout.write(f'Fouls: {simulation.match_stats["away"]["fouls"]}')
            self.stdout.write(f'Attacks (dangerous): {simulation.match_stats["away"]["attacks"]} ({simulation.match_stats["away"]["dangerous_attacks"]})')

        except Exception as e:
            self.stdout.write(self.style.ERROR(f'\nError occurred: {str(e)}'))

================
File: matches/match_preparation.py
================
from typing import Dict, List
from .models import Match
from clubs.models import Club
from players.models import Player
import logging

logger = logging.getLogger(__name__)

class PreMatchPreparation:
    """Класс для подготовки и анализа матча перед его началом"""

    DEFENDER_WEIGHTS = {
        'marking': 0.3,
        'tackling': 0.3,
        'strength': 0.2,
        'positioning': 0.2
    }

    MIDFIELDER_WEIGHTS = {
        'passing': 0.3,
        'vision': 0.3,
        'stamina': 0.2,
        'work_rate': 0.2
    }

    FORWARD_WEIGHTS = {
        'finishing': 0.3,
        'dribbling': 0.3,
        'long_range': 0.2,
        'accuracy': 0.2
    }

    GOALKEEPER_WEIGHTS = {
        'reflexes': 0.25,
        'handling': 0.25,
        'positioning': 0.2,
        'aerial': 0.1,
        'command': 0.1,
        'shot_reading': 0.1
    }

    def __init__(self, match: Match):
        self.match = match
        self.home_team = match.home_team
        self.away_team = match.away_team

        # 1) Берём состав из match.home_lineup / match.away_lineup
        #    Если там пусто — пытаемся взять из club.lineup
        #    Если и там пусто — авто-выбор (4-4-2)
        self.home_lineup = match.home_lineup or self.get_lineup_from_club(self.home_team) or self.auto_select_lineup(self.home_team)
        self.away_lineup = match.away_lineup or self.get_lineup_from_club(self.away_team) or self.auto_select_lineup(self.away_team)

        # 2) Сохраняем обратно в match (чтобы зафиксировать)
        if not match.home_lineup:
            match.home_lineup = self.home_lineup
        if not match.away_lineup:
            match.away_lineup = self.away_lineup
        match.save()

        # Итог: теперь match.home_lineup/match.away_lineup заполнены

        self.validation_results = {
            'home_valid': False,
            'away_valid': False,
            'errors': []
        }

        self.team_strengths = {
            'home': 0,
            'away': 0
        }

        self.match_parameters = {
            'home': {
                'players_condition': {},
                'team_attack': 0,
                'team_defense': 0,
                'team_midfield': 0,
                'goalkeeper_strength': 0
            },
            'away': {
                'players_condition': {},
                'team_attack': 0,
                'team_defense': 0,
                'team_midfield': 0,
                'goalkeeper_strength': 0
            }
        }

    def get_lineup_from_club(self, club: Club) -> dict:
        """
        Берём lineup из club.lineup (если он есть).
        club.lineup — это dict вида: {'lineup': {...}, 'tactic': '???'}
        
        Возвращает именно 'lineup' или None, если что-то не так.
        """
        if not club.lineup:
            return None
        if 'lineup' not in club.lineup:
            return None

        # Пример: club.lineup = {"lineup": {"0": 123, "1": 456, ...}, "tactic": "balanced"}
        # Тут lineup = {"0": 123, "1": 456, ...}
        lineup_dict = club.lineup.get('lineup', {})
        if not isinstance(lineup_dict, dict):
            return None

        if len(lineup_dict) < 11:
            # Либо считаем, что lineup неполный => None
            return None

        logger.info(f"[PreMatch] Using club.lineup for {club.name}: {lineup_dict}")
        return lineup_dict

    def auto_select_lineup(self, team: Club) -> dict:
        """
        Автоматически формирует состав команды (4-4-2).
        """
        players = team.player_set.all()
        lineup = {}

        # Сначала вратарь
        goalkeeper = players.filter(position='Goalkeeper').first()
        if goalkeeper:
            lineup['0'] = goalkeeper.id

        # Защитники (4)
        defenders = players.filter(
            position__in=['Right Back', 'Left Back', 'Center Back']
        )[:4]
        idx = 1
        for player in defenders:
            lineup[str(idx)] = player.id
            idx += 1

        # Полузащитники (4)
        midfielders = players.filter(
            position__icontains='Midfielder'
        )[:4]
        for m in midfielders:
            lineup[str(idx)] = m.id
            idx += 1

        # Нападающие (2)
        forwards = players.filter(position='Center Forward')[:2]
        for f in forwards:
            lineup[str(idx)] = f.id
            idx += 1

        logger.info(f"[PreMatch] Auto lineup (4-4-2) for {team.name}: {lineup}")
        return lineup

    def validate_lineup(self, lineup: Dict, team: Club) -> bool:
        """
        Проверяет валидность состава (11 человек, 1 GK, и т.д.)
        """
        errors = []

        # 11 игроков
        if len(lineup) != 11:
            errors.append(f"Team {team.name} must have exactly 11 players in lineup.")
            self.validation_results['errors'].extend(errors)
            return False

        position_counts = {
            'Goalkeeper': 0,
            'Defender': 0,
            'Midfielder': 0,
            'Forward': 0
        }

        for pos_key, player_id in lineup.items():
            try:
                player = Player.objects.get(id=player_id)
                if player.position == 'Goalkeeper':
                    position_counts['Goalkeeper'] += 1
                elif 'Back' in player.position:
                    position_counts['Defender'] += 1
                elif 'Midfielder' in player.position:
                    position_counts['Midfielder'] += 1
                else:
                    # Считаем всё остальное форвардом (Center Forward etc.)
                    position_counts['Forward'] += 1
            except Player.DoesNotExist:
                errors.append(f"Player with ID {player_id} not found.")
                self.validation_results['errors'].extend(errors)
                return False

        if position_counts['Goalkeeper'] != 1:
            errors.append(f"Team {team.name} must have exactly 1 goalkeeper.")
        if position_counts['Defender'] < 3 or position_counts['Defender'] > 5:
            errors.append(f"Team {team.name} must have between 3 and 5 defenders.")
        if position_counts['Midfielder'] < 2 or position_counts['Midfielder'] > 5:
            errors.append(f"Team {team.name} must have between 2 and 5 midfielders.")
        if position_counts['Forward'] < 1 or position_counts['Forward'] > 4:
            errors.append(f"Team {team.name} must have between 1 and 4 forwards.")

        if errors:
            self.validation_results['errors'].extend(errors)
            return False

        return True

    def calculate_player_strength(self, player: Player) -> float:
        """
        Рассчитываем силу игрока на его позиции (простейшая схема).
        """
        if player.position == 'Goalkeeper':
            weights = self.GOALKEEPER_WEIGHTS
            attributes = {
                'reflexes': player.reflexes,
                'handling': player.handling,
                'positioning': player.positioning,
                'aerial': player.aerial,
                'command': player.command,
                'shot_reading': player.shot_reading
            }
        elif 'Back' in player.position:
            # Защитник
            weights = self.DEFENDER_WEIGHTS
            attributes = {
                'marking': player.marking,
                'tackling': player.tackling,
                'strength': player.strength,
                'positioning': player.positioning
            }
        elif 'Midfielder' in player.position:
            # Полузащитник
            weights = self.MIDFIELDER_WEIGHTS
            attributes = {
                'passing': player.passing,
                'vision': player.vision,
                'stamina': player.stamina,
                'work_rate': player.work_rate
            }
        else:
            # Форвард
            weights = self.FORWARD_WEIGHTS
            attributes = {
                'finishing': player.finishing,
                'dribbling': player.dribbling,
                'long_range': player.long_range,
                'accuracy': player.accuracy
            }

        strength = sum(weights[attr] * attributes[attr] for attr in weights)
        return round(strength, 2)

    def calculate_team_strength(self, lineup: Dict, team: Club, is_home: bool=False) -> float:
        total_strength = 0
        for player_id in lineup.values():
            try:
                player = Player.objects.get(id=player_id)
                total_strength += self.calculate_player_strength(player)
            except Player.DoesNotExist:
                pass

        # Среднее
        avg_strength = total_strength / 11 if len(lineup) == 11 else 0
        if is_home:
            avg_strength *= 1.1
        return round(avg_strength, 2)

    def _calculate_initial_parameters(self, team_type: str):
        """
        Заполняем match_parameters[...] какими-то начальными значениями 
        (атака, защита, и т.д.).
        """
        lineup = self.home_lineup if team_type == 'home' else self.away_lineup
        parameters = self.match_parameters[team_type]

        # Примерная логика
        for _, player_id in lineup.items():
            parameters['players_condition'][player_id] = 100

        # Здесь можно делать любые расчёты, как у вас в коде
        parameters['team_attack'] = self.calculate_team_strength(lineup, None, is_home=(team_type=='home'))
        parameters['team_defense'] = parameters['team_attack'] * 0.8
        parameters['team_midfield'] = parameters['team_attack'] * 0.9
        parameters['goalkeeper_strength'] = parameters['team_attack'] * 0.7

    def prepare_match(self) -> bool:
        # 1) Проверяем составы
        self.validation_results['home_valid'] = self.validate_lineup(self.home_lineup, self.home_team)
        self.validation_results['away_valid'] = self.validate_lineup(self.away_lineup, self.away_team)

        if not (self.validation_results['home_valid'] and self.validation_results['away_valid']):
            return False

        # 2) Рассчитываем силы
        self.team_strengths['home'] = self.calculate_team_strength(self.home_lineup, self.home_team, True)
        self.team_strengths['away'] = self.calculate_team_strength(self.away_lineup, self.away_team, False)

        # 3) Начальные параметры
        self._calculate_initial_parameters('home')
        self._calculate_initial_parameters('away')

        # Если надо, можно логировать
        logger.info(f"[PreMatch] {self.home_team.name} strength={self.team_strengths['home']} lineup={self.home_lineup}")
        logger.info(f"[PreMatch] {self.away_team.name} strength={self.team_strengths['away']} lineup={self.away_lineup}")

        return True

    def get_validation_errors(self) -> List[str]:
        return self.validation_results['errors']

================
File: matches/match_simulation.py
================
import random
import logging

from django.utils import timezone
from asgiref.sync import async_to_sync
from channels.layers import get_channel_layer

from .models import Match, MatchEvent
from .player_agent import PlayerAgent
from players.models import Player

logger = logging.getLogger(__name__)


class MatchSimulation:
    def __init__(self, match: Match):
        self.match = match

        # Изначально, в базе у нас:
        # match.home_lineup = {
        #   "lineup": {
        #       "0": { "playerId": "8001", "slotType": "goalkeeper", "slotLabel": "GK" },
        #       "1": { "playerId": "8002", "slotType": "defender",   "slotLabel": "LB" },
        #       ...
        #   },
        #   "tactic": "balanced"
        # }
        #
        # Аналогично для match.away_lineup

        self.match_stats = {
            'home': {
                'possession': 50,
                'shots': 0,
                'goals': 0,
                'passes': 0,
                'tackles': 0,
                'team_attack': 0,
                'team_defense': 0,
                'team_midfield': 0,
                'tactics': 'balanced',  # по умолчанию
            },
            'away': {
                'possession': 50,
                'shots': 0,
                'goals': 0,
                'passes': 0,
                'tackles': 0,
                'team_attack': 0,
                'team_defense': 0,
                'team_midfield': 0,
                'tactics': 'balanced',
            },
        }

        # При инициализации сразу прочитаем tactic:
        if isinstance(self.match.home_lineup, dict):
            self.match_stats['home']['tactics'] = self.match.home_lineup.get('tactic', 'balanced')
        if isinstance(self.match.away_lineup, dict):
            self.match_stats['away']['tactics'] = self.match.away_lineup.get('tactic', 'balanced')

        # Разберём home_lineup
        home_lineup_dict = {}
        if self.match.home_lineup and isinstance(self.match.home_lineup, dict):
            home_lineup_dict = self.match.home_lineup.get('lineup', {})
        away_lineup_dict = {}
        if self.match.away_lineup and isinstance(self.match.away_lineup, dict):
            away_lineup_dict = self.match.away_lineup.get('lineup', {})

        # Сохраним в self.home_slots / self.away_slots
        self.home_slots = self._build_slot_map(home_lineup_dict)
        self.away_slots = self._build_slot_map(away_lineup_dict)

        # Для удобства также соберём списки игроков (их атрибутов) и рассчитаем командные параметры
        self._calculate_team_parameters()

        # Изначально "владелец мяча" и "зона" не заданы
        self.ball_owner = None
        self.current_zone = None

        # Подготовим списки минут, когда возникают опасные моменты
        self._setup_moments()

    def _build_slot_map(self, lineup_dict):
        """
        На входе: { "0": { "playerId": "8001", "slotType": "goalkeeper", ... }, "1": {...}, ... }
        Возвращаем: dict, ключ=строка слота, значение={
           "playerObj": <Player>,
           "agent": <PlayerAgent>,
           "slotType": ...,
           "slotLabel": ...,
        }
        """
        result = {}
        for slot_index, slot_info in lineup_dict.items():
            # slot_info => {playerId, slotType, slotLabel, ...}
            player_id_str = slot_info.get("playerId")
            if not player_id_str:
                continue
            try:
                player_id = int(player_id_str)
                player_obj = Player.objects.get(pk=player_id)
            except (ValueError, Player.DoesNotExist):
                logger.warning(f"Slot {slot_index}: invalid playerId={player_id_str}, skipping.")
                continue

            agent = PlayerAgent(player_obj)
            result[slot_index] = {
                "playerObj": player_obj,
                "agent": agent,
                "slotType": slot_info.get("slotType"),    # "goalkeeper", "defender", ...
                "slotLabel": slot_info.get("slotLabel"),  # "GK", "LB", "CB", ...
            }
        return result

    def _calculate_team_parameters(self):
        """
        Для каждой команды (home/away) вычисляем "team_attack", "team_defense", "team_midfield"
        на основе игроков, лежащих в self.home_slots / self.away_slots.
        """
        # Собираем список всех Player-объектов для home:
        home_players = [slot["playerObj"] for slot in self.home_slots.values()]

        # Аналогично для away:
        away_players = [slot["playerObj"] for slot in self.away_slots.values()]

        self.match_stats['home']['team_attack'] = self._calculate_team_parameter(home_players, 'attack')
        self.match_stats['home']['team_defense'] = self._calculate_team_parameter(home_players, 'defense')
        self.match_stats['home']['team_midfield'] = self._calculate_team_parameter(home_players, 'midfield')

        self.match_stats['away']['team_attack'] = self._calculate_team_parameter(away_players, 'attack')
        self.match_stats['away']['team_defense'] = self._calculate_team_parameter(away_players, 'defense')
        self.match_stats['away']['team_midfield'] = self._calculate_team_parameter(away_players, 'midfield')

    def _calculate_team_parameter(self, players, parameter_type):
        """
        Рассчитываем некое «среднее» параметра (атака/защита/центр) по набору игроков.
        """
        total = 0
        count = 0

        for player in players:
            experience_multiplier = 1 + player.experience * 0.01

            if parameter_type == 'attack':
                if player.position in ['Center Forward', 'Attacking Midfielder']:
                    base_value = player.finishing + player.heading + player.long_range
                    weight = 1.5
                else:
                    base_value = player.finishing + player.long_range
                    weight = 1.0

            elif parameter_type == 'defense':
                if player.position in ['Center Back', 'Right Back', 'Left Back', 'Defensive Midfielder']:
                    base_value = player.marking + player.tackling + player.heading
                    weight = 1.5
                else:
                    base_value = player.marking + player.tackling
                    weight = 1.0

            else:  # 'midfield'
                if player.position in ['Central Midfielder', 'Defensive Midfielder', 'Attacking Midfielder']:
                    base_value = player.passing + player.vision + player.work_rate
                    weight = 1.5
                else:
                    base_value = player.passing + player.work_rate
                    weight = 1.0

            final_value = base_value * experience_multiplier
            total += (final_value * weight)
            count += weight

        if count > 0:
            return round(total / count)
        else:
            return 50

    def _setup_moments(self):
        """
        Определяем, на каких минутах будет опасный момент у home/away (упрощённо).
        """
        base_min, base_max = 10, 20
        home_strength = (self.match_stats['home']['team_attack'] + self.match_stats['home']['team_midfield']) / 2
        away_strength = (self.match_stats['away']['team_attack'] + self.match_stats['away']['team_midfield']) / 2

        home_factor = min(home_strength / 100, 1.0)
        away_factor = min(away_strength / 100, 1.0)

        home_chances = int(base_min + (base_max - base_min) * home_factor)
        away_chances = int(base_min + (base_max - base_min) * away_factor)

        all_minutes = list(range(1, 90))
        random.shuffle(all_minutes)

        self.home_moments_minutes = sorted(all_minutes[:home_chances])
        self.away_moments_minutes = sorted(all_minutes[home_chances : home_chances + away_chances])

    def create_match_event(self, minute, event_type, agent, description):
        """
        Создаём MatchEvent в БД (запись о событии).
        agent.player_model — ссылка на Player (или None).
        """
        player_model = agent.player_model if agent else None
        MatchEvent.objects.create(
            match=self.match,
            minute=minute,
            event_type=event_type,
            player=player_model,
            description=description
        )

    def simulate_minute(self, minute):
        """
        Логика "1 минута матча": упрощённая схема выбора атакующей команды и рандомного игрока.
        """
        if minute in self.home_moments_minutes:
            attacking_team = 'home'
        elif minute in self.away_moments_minutes:
            attacking_team = 'away'
        else:
            # Ни у кого нет опасного момента
            return

        self.create_match_event(minute, 'info', None,
                                f"MOMENT at minute {minute}: {attacking_team.upper()} tries to attack!")

        # Соберём список «подходящих» слотов для атаки.
        # Допустим, хотим только slotType = 'midfielder' или 'forward'.
        if attacking_team == 'home':
            slot_map = self.home_slots
            defending_team = 'away'
        else:
            slot_map = self.away_slots
            defending_team = 'home'

        attacking_slots = [
            idx
            for idx, data in slot_map.items()
            if data["slotType"] in ('midfielder', 'forward')
        ]

        if not attacking_slots:
            logger.warning(f"No attacking slots found for {attacking_team}.")
            return

        chosen_slot_index = random.choice(attacking_slots)
        slot_data = slot_map[chosen_slot_index]
        agent = slot_data["agent"]

        self.create_match_event(
            minute,
            'info',
            agent,
            f"Ball owned by {agent.full_name} (slot {slot_data['slotLabel']})"
        )

        # Определим вероятность гола (упрощённо 25%)
        goal_probability = 0.25

        # Усилим шанс, если это чистый «forward»:
        if slot_data["slotType"] == 'forward':
            goal_probability += 0.10  # +10% если тип «forward»

        if random.random() < goal_probability:
            # Гол
            self.match_stats[attacking_team]['goals'] += 1
            if attacking_team == 'home':
                self.match.home_score += 1
            else:
                self.match.away_score += 1
            self.match.save()

            self.create_match_event(
                minute,
                'goal',
                agent,
                f"GOAL by {agent.full_name}!"
            )
        else:
            # Блок/промах
            self.create_match_event(
                minute,
                'info',
                agent,
                "Shot blocked by defenders or missed!"
            )


def simulate_one_minute(match_id: int):
    """
    Функция, которую может вызывать Celery периодически.
    """
    try:
        match = Match.objects.get(id=match_id)

        if match.status != 'in_progress':
            logger.info(f"Match {match_id} is not in progress, skipping simulate_one_minute.")
            return

        # Если >=90, завершаем
        if match.current_minute >= 90:
            if match.status != 'finished':
                match.status = 'finished'
                match.save()
            return

        # Запускаем симуляцию 1 минуты
        sim = MatchSimulation(match)
        sim.simulate_minute(match.current_minute + 1)

        # Увеличиваем current_minute
        match.current_minute += 1

        if match.current_minute >= 90:
            match.status = 'finished'
        match.save()

        # Отправляем обновление через WebSocket (если нужно)
        channel_layer = get_channel_layer()
        if channel_layer is not None:
            latest_events = list(match.events.order_by('-minute')[:10].values(
                'minute', 'event_type', 'description'
            ))
            match_data = {
                "minute": match.current_minute,
                "home_score": match.home_score,
                "away_score": match.away_score,
                "status": match.status,
                "events": latest_events
            }
            async_to_sync(channel_layer.group_send)(
                f"match_{match.id}",
                {
                    "type": "match_update",
                    "data": match_data
                }
            )
            logger.info(f"WebSocket update sent for match {match_id}")

    except Exception as e:
        logger.error(f"Error in simulate_one_minute for match {match_id}: {str(e)}")
        raise

================
File: matches/models.py
================
from django.db import models
from django.conf import settings
from clubs.models import Club
from django.utils import timezone

class Match(models.Model):
    home_team = models.ForeignKey(Club, on_delete=models.CASCADE, related_name='home_matches')
    away_team = models.ForeignKey(Club, on_delete=models.CASCADE, related_name='away_matches')
    datetime = models.DateTimeField(
        verbose_name="Match Date and Time",
        db_index=True,
        null=True,
        blank=True
    )
    processed = models.BooleanField(
        default=False,
        db_index=True,
        help_text="Indicates if match has been processed"
    )
    home_score = models.PositiveIntegerField(default=0)
    away_score = models.PositiveIntegerField(default=0)
    status = models.CharField(
        max_length=20,
        choices=[
            ('scheduled', 'Scheduled'),
            ('in_progress', 'In Progress'),
            ('finished', 'Finished'),
            ('cancelled', 'Cancelled')
        ],
        default='scheduled',
        db_index=True
    )
    
    # Составы команд
    home_lineup = models.JSONField(null=True, blank=True)
    away_lineup = models.JSONField(null=True, blank=True)

    # Тактики команд
    home_tactic = models.CharField(max_length=20, default='balanced')
    away_tactic = models.CharField(max_length=20, default='balanced')

    # Текущая минута матча
    current_minute = models.PositiveIntegerField(default=0)

    def __str__(self):
        return f"{self.home_team} vs {self.away_team} - {self.datetime}"


class MatchEvent(models.Model):
    match = models.ForeignKey(Match, on_delete=models.CASCADE, related_name='events')
    minute = models.PositiveIntegerField()
    event_type = models.CharField(max_length=20, choices=[
        ('goal', 'Goal'),
        ('miss', 'Miss'),
        ('possession', 'Possession Change'),
        ('defense_to_midfield', 'Defense to Midfield Transition'),
        ('midfield_to_attack', 'Midfield to Attack Transition'),
        ('attack_to_shot', 'Attack to Shot Opportunity'),
        ('interception', 'Interception'),
        ('yellow_card', 'Yellow Card'),
        ('red_card', 'Red Card'),
        ('substitution', 'Substitution')
    ])
    player = models.ForeignKey('players.Player', on_delete=models.CASCADE, null=True, blank=True)
    description = models.TextField()

    def __str__(self):
        return f"{self.match} - {self.event_type} at {self.minute}'"

================
File: matches/pitch.py
================
import random
from typing import Dict, List, Tuple, Optional
from players.models import Player

class Pitch:
    """
    Класс, представляющий футбольное поле как сетку.
    
    WIDTH = 100: ширина поля в клетках
    HEIGHT = 60: высота поля в клетках
    """
    WIDTH = 100
    HEIGHT = 60
    
    def __init__(self):
        # Позиции игроков в формате {(team_type, player_id): (x, y)}
        self.positions: Dict[Tuple[str, int], Tuple[int, int]] = {}
        # Позиция мяча (x, y)
        self.ball_position: Tuple[int, int] = (self.WIDTH // 2, self.HEIGHT // 2)
        # ID игрока, владеющего мячом
        self.ball_owner: Optional[Tuple[str, int]] = None
        
    def set_initial_positions(self, home_players: List[Player], away_players: List[Player]):
        """
        Расставляет игроков по начальным позициям в зависимости от их ролей.
        """
        # Очищаем текущие позиции
        self.positions.clear()
        
        # Расставляем домашнюю команду (атакует справа налево)
        self._set_team_positions(home_players, 'home')
        # Расставляем гостевую команду (атакует слева направо)
        self._set_team_positions(away_players, 'away')
        
    def _set_team_positions(self, players: List[Player], team_type: str):
        """
        Расставляет одну команду по позициям.
        """
        for player in players:
            x, y = self._get_initial_position(player.position, team_type)
            # Добавляем случайное смещение для разнообразия
            x += random.randint(-5, 5)
            y += random.randint(-3, 3)
            # Проверяем границы поля
            x = max(0, min(self.WIDTH - 1, x))
            y = max(0, min(self.HEIGHT - 1, y))
            self.positions[(team_type, player.id)] = (x, y)
    
    def _get_initial_position(self, position: str, team_type: str) -> Tuple[int, int]:
        """
        Определяет начальную позицию игрока в зависимости от его роли.
        """
        # Базовая x-координата зависит от команды
        if team_type == 'home':
            base_x = self.WIDTH * 3 // 4  # правая половина
        else:
            base_x = self.WIDTH // 4  # левая половина
            
        # Y-координата и смещение по X зависят от позиции игрока
        if 'Goalkeeper' in position:
            return (5 if team_type == 'away' else self.WIDTH - 5, self.HEIGHT // 2)
        elif 'Center Back' in position:
            return (base_x + (-10 if team_type == 'home' else 10), self.HEIGHT // 2)
        elif 'Right Back' in position:
            return (base_x + (-10 if team_type == 'home' else 10), self.HEIGHT * 3 // 4)
        elif 'Left Back' in position:
            return (base_x + (-10 if team_type == 'home' else 10), self.HEIGHT // 4)
        elif 'Defensive Midfielder' in position:
            return (base_x + (-5 if team_type == 'home' else 5), self.HEIGHT // 2)
        elif 'Central Midfielder' in position:
            return (base_x, self.HEIGHT // 2)
        elif 'Right Midfielder' in position:
            return (base_x, self.HEIGHT * 3 // 4)
        elif 'Left Midfielder' in position:
            return (base_x, self.HEIGHT // 4)
        elif 'Attacking Midfielder' in position:
            return (base_x + (5 if team_type == 'home' else -5), self.HEIGHT // 2)
        elif 'Center Forward' in position:
            return (base_x + (10 if team_type == 'home' else -10), self.HEIGHT // 2)
        else:
            return (base_x, self.HEIGHT // 2)

    def move_player(self, team_type: str, player_id: int, dx: int, dy: int) -> bool:
        """
        Перемещает игрока на dx, dy клеток.
        Возвращает True, если перемещение успешно.
        """
        if (team_type, player_id) not in self.positions:
            return False
            
        x, y = self.positions[(team_type, player_id)]
        new_x = max(0, min(self.WIDTH - 1, x + dx))
        new_y = max(0, min(self.HEIGHT - 1, y + dy))
        
        # Проверяем, не занята ли новая позиция
        for pos in self.positions.values():
            if pos == (new_x, new_y):
                return False
                
        self.positions[(team_type, player_id)] = (new_x, new_y)
        
        # Если у игрока был мяч, мяч движется с ним
        if self.ball_owner == (team_type, player_id):
            self.ball_position = (new_x, new_y)
            
        return True
        
    def move_towards(self, team_type: str, player_id: int, target_x: int, target_y: int, 
                    speed: int = 1) -> bool:
        """
        Перемещает игрока в направлении целевой точки.
        """
        if (team_type, player_id) not in self.positions:
            return False
            
        x, y = self.positions[(team_type, player_id)]
        dx = 0
        dy = 0
        
        if x < target_x:
            dx = min(speed, target_x - x)
        elif x > target_x:
            dx = max(-speed, target_x - x)
            
        if y < target_y:
            dy = min(speed, target_y - y)
        elif y > target_y:
            dy = max(-speed, target_y - y)
            
        return self.move_player(team_type, player_id, dx, dy)
        
    def get_distance(self, pos1: Tuple[int, int], pos2: Tuple[int, int]) -> float:
        """
        Вычисляет расстояние между двумя точками на поле.
        """
        x1, y1 = pos1
        x2, y2 = pos2
        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5
        
    def get_nearest_players(self, x: int, y: int, team_type: str = None, 
                          max_distance: float = None) -> List[Tuple[Tuple[str, int], float]]:
        """
        Находит ближайших игроков к заданной точке.
        Можно отфильтровать по команде и максимальному расстоянию.
        Возвращает список кортежей ((team_type, player_id), distance).
        """
        players = []
        for (t, pid), pos in self.positions.items():
            if team_type and t != team_type:
                continue
                
            dist = self.get_distance((x, y), pos)
            if max_distance is None or dist <= max_distance:
                players.append(((t, pid), dist))
                
        return sorted(players, key=lambda x: x[1])
        
    def is_position_free(self, x: int, y: int, radius: int = 1) -> bool:
        """
        Проверяет, свободна ли позиция (с учетом радиуса).
        """
        for pos in self.positions.values():
            if self.get_distance((x, y), pos) <= radius:
                return False
        return True
        
    def get_team_average_position(self, team_type: str) -> Tuple[float, float]:
        """
        Вычисляет среднюю позицию команды на поле.
        """
        positions = [(x, y) for (t, _), (x, y) in self.positions.items() if t == team_type]
        if not positions:
            return (0, 0)
            
        avg_x = sum(x for x, _ in positions) / len(positions)
        avg_y = sum(y for _, y in positions) / len(positions)
        return (avg_x, avg_y)

================
File: matches/player_agent.py
================
import random

class PlayerAgent:
    def __init__(self, player_model):
        # Базовая информация
        self.player_model = player_model
        self.full_name = player_model.full_name
        self.position = player_model.position
        
        # Базовые характеристики
        self.condition = 100  # Физическое состояние
        self.morale = 100    # Моральное состояние
        
    def decide_action(self, match_state):
        """Принятие решения о следующем действии"""
        if self.position in ['Center Forward', 'Attacking Midfielder']:
            return 'attack' if random.random() < 0.7 else 'position'
        elif self.position == 'Midfielder':
            return 'attack' if random.random() < 0.5 else 'position'
        else:
            return 'position'

    def perform_action(self, action, match_state):
        """Выполнение действия"""
        # Простая реализация - возвращаем True/False для успеха/неудачи
        if action == 'attack':
            return random.random() < 0.4
        elif action == 'position':
            return True
        return False

================
File: matches/static/matches/js/live_match.js
================
document.addEventListener('DOMContentLoaded', function() {
    const matchInfoArea = document.getElementById('matchInfoArea');
    if (!matchInfoArea) {
        console.error('matchInfoArea not found!');
        return;
    }

    const matchId = matchInfoArea.dataset.matchId;
    const isLive = matchInfoArea.dataset.matchStatus === 'in_progress';

    console.log('Match setup:', { matchId, isLive, status: matchInfoArea.dataset.matchStatus });

    if (isLive) {
        console.log('Match is live, attempting WebSocket connection...');
        
        const wsScheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
        const wsUrl = `${wsScheme}://${window.location.host}/ws/match/${matchId}/`;
        console.log('WebSocket URL:', wsUrl);
        
        const matchSocket = new WebSocket(wsUrl);

        matchSocket.onopen = function(e) {
            console.log('WebSocket connection established successfully!');
        };

        matchSocket.onclose = function(e) {
            console.log('WebSocket connection closed:', e.code, e.reason);
            console.error('Match socket closed unexpectedly');
        };

        matchSocket.onerror = function(e) {
            console.error('WebSocket error occurred:', e);
        };

        matchSocket.onmessage = function(e) {
            console.log('Received WebSocket message:', e.data);
            
            try {
                const data = JSON.parse(e.data);
                console.log('Parsed data:', data);
                
                // Обновляем время
                const timeElement = document.getElementById('matchTime');
                if (timeElement) {
                    timeElement.textContent = `${data.minute}'`;
                } else {
                    console.warn('matchTime element not found');
                }

                // Обновляем счет
                const scoreElement = document.getElementById('score');
                if (scoreElement) {
                    scoreElement.textContent = `${data.home_score} - ${data.away_score}`;
                } else {
                    console.warn('score element not found');
                }

                // Добавляем новые события
                if (data.events && data.events.length > 0) {
                    const eventsList = document.getElementById('originalEvents');
                    if (eventsList) {
                        const listGroup = eventsList.querySelector('.list-group');
                        if (listGroup) {
                            data.events.forEach(event => {
                                const eventDiv = document.createElement('div');
                                if (data.events && data.events.length > 0) {
                                    const eventsList = document.getElementById('originalEvents');
                                    if (eventsList) {
                                        const listGroup = eventsList.querySelector('.list-group');
                                        if (listGroup) {
                                            data.events.sort((a, b) => a.minute - b.minute).forEach(event => {
                                                const eventDiv = document.createElement('div');
                                                eventDiv.className = 'list-group-item';
                                                
                                                let icon = '📝';
                                                if (event.event_type === 'goal') icon = '⚽';
                                                else if (event.event_type === 'yellow_card') icon = '🟨';
                                                else if (event.event_type === 'red_card') icon = '🟥';
                                
                                                eventDiv.innerHTML = `
                                                    <div class="d-flex justify-content-between align-items-center">
                                                        <div>
                                                            <strong>${event.minute}'</strong> 
                                                            <span class="event-icon">${icon}</span>
                                                            ${event.description}
                                                        </div>
                                                    </div>
                                                `;
                                                
                                                listGroup.appendChild(eventDiv);
                                            });
                                        } else {
                                            console.warn('list-group element not found in originalEvents');
                                        }
                                    } else {
                                        console.warn('originalEvents element not found');
                                    }
                                }
                                
            } catch (error) {
                console.error('Error parsing WebSocket message:', error);
                console.error('Raw message:', e.data);
            }
        };
    } else {
        console.log('Match is not live, skipping WebSocket setup');
    }
});

================
File: matches/static/matches/js/match_replay.js
================
document.addEventListener('DOMContentLoaded', function() {
    const startButton = document.getElementById('startReplayBtn');
    const replayTime = document.getElementById('replayTime');
    const replayScore = document.getElementById('replayScore');
    const replayEventsList = document.getElementById('replayEvents');
    const matchInfoArea = document.getElementById('matchInfoArea');
    const replayArea = document.getElementById('replayArea');

    let eventsData = [];
    let matchData = null;
    let currentMinute = 0;
    let homeScore = 0;
    let awayScore = 0;
    let replayInterval = null;

    if (startButton) {
        startButton.addEventListener('click', startReplay);
    }

    function startReplay() {
        // Блокируем кнопку на время реплея
        startButton.disabled = true;
        startButton.textContent = 'Replay in progress...';
        
        // Получаем события с бэкенда
        const matchId = matchInfoArea.dataset.matchId;
        
        fetch(`/matches/${matchId}/events-json/`)
            .then(resp => resp.json())
            .then(data => {
                eventsData = data.events;
                matchData = data.match;
                
                // Обнуляем всё
                currentMinute = 0;
                homeScore = 0;
                awayScore = 0;
                replayEventsList.innerHTML = '';
                
                // Показываем область реплея
                replayArea.style.display = 'block';
                
                // Обновляем заголовок
                replayTime.textContent = "0'";
                replayScore.textContent = `${matchData.home_team} 0 - 0 ${matchData.away_team}`;
                
                // Запускаем таймер
                if (replayInterval) {
                    clearInterval(replayInterval);
                }
                
                replayInterval = setInterval(() => {
                    currentMinute += 1;
                    if (currentMinute > 90) {
                        clearInterval(replayInterval);
                        startButton.disabled = false;
                        startButton.textContent = 'Restart Replay';
                        return;
                    }
                    
                    // Обновляем время
                    replayTime.textContent = currentMinute + "'";
                    
                    // Показываем события текущей минуты
                    showEventsUpTo(currentMinute);
                    
                }, 3000); // 3 секунды на каждую минуту матча
            })
            .catch(error => {
                console.error('Error fetching match events:', error);
                startButton.disabled = false;
                startButton.textContent = 'Start Replay';
            });
    }

    function showEventsUpTo(minute) {
        const currentEvents = eventsData.filter(ev => ev.minute === minute);
        
        currentEvents.forEach(ev => {
            // Создаем элемент события
            const eventDiv = document.createElement('div');
            eventDiv.className = 'match-event';
            
            // Добавляем иконку в зависимости от типа события
            let icon = '📝'; // default icon
            if (ev.event_type === 'goal') {
                icon = '⚽';
                if (ev.description.includes(matchData.home_team)) {
                    homeScore++;
                } else if (ev.description.includes(matchData.away_team)) {
                    awayScore++;
                }
            } else if (ev.event_type === 'yellow_card') {
                icon = '🟨';
            } else if (ev.event_type === 'red_card') {
                icon = '🟥';
            }
            
            eventDiv.innerHTML = `
                <span class="event-time">${ev.minute}'</span>
                <span class="event-icon">${icon}</span>
                <span class="event-description">${ev.description}</span>
            `;
            
            // Добавляем событие в список
            replayEventsList.insertBefore(eventDiv, replayEventsList.firstChild);
            
            // Обновляем счет
            replayScore.textContent = 
                `${matchData.home_team} ${homeScore} - ${awayScore} ${matchData.away_team}`;
        });
    }
});

================
File: matches/static/matches/js/team_selection.js
================
document.addEventListener('DOMContentLoaded', function() {
    const pitch = document.getElementById('pitch');
    const playerList = document.getElementById('playerList');
    const clubId = document.getElementById('clubId').value;
    const resetButton = document.getElementById('resetButton');
    const saveStatus = document.getElementById('saveStatus');
    const tacticSelect = document.getElementById('tacticSelect');

    // Конфигурация слотов
    const positions = [
        { top: '10%', left: '50%', type: 'goalkeeper', label: 'GK' },  
        { top: '30%', left: '20%', type: 'defender',   label: 'LB' },  
        { top: '30%', left: '40%', type: 'defender',   label: 'CB' },
        { top: '30%', left: '60%', type: 'defender',   label: 'CB' },
        { top: '30%', left: '80%', type: 'defender',   label: 'RB' },
        { top: '60%', left: '30%', type: 'midfielder', label: 'LM' },  
        { top: '60%', left: '50%', type: 'midfielder', label: 'CM' },
        { top: '60%', left: '70%', type: 'midfielder', label: 'RM' },
        { top: '80%', left: '30%', type: 'forward',    label: 'LF' },  
        { top: '80%', left: '50%', type: 'forward',    label: 'ST' },
        { top: '80%', left: '70%', type: 'forward',    label: 'RF' }
    ];

    // Создаём слоты на поле
    positions.forEach((pos, index) => {
        const slot = document.createElement('div');
        slot.className = 'player-slot empty';  // Добавляем класс empty
        slot.style.top = pos.top;
        slot.style.left = pos.left;

        slot.dataset.position = index;
        slot.dataset.type = pos.type;

        const label = document.createElement('div');
        label.className = 'position-label';
        label.textContent = pos.label;
        slot.appendChild(label);

        pitch.appendChild(slot);
    });

    function getPlayerType(position) {
        if (!position) return 'other';
        if (position.toLowerCase().includes('goalkeeper')) return 'goalkeeper';
        if (position.toLowerCase().includes('back') ||
            position.toLowerCase().includes('defender')) return 'defender';
        if (position.toLowerCase().includes('midfielder')) return 'midfielder';
        if (position.toLowerCase().includes('forward') ||
            position.toLowerCase().includes('striker')) return 'forward';
        return 'other';
    }

    function isValidPosition(playerType, slotType) {
        switch (slotType) {
            case 'goalkeeper':
                return playerType === 'goalkeeper';
            case 'defender':
                return playerType === 'defender';
            case 'midfielder':
                return playerType === 'midfielder';
            case 'forward':
                return playerType === 'forward';
            default:
                return false;
        }
    }

    function createPlayerElement(player) {
        const playerElement = document.createElement('div');
        const playerType = getPlayerType(player.position);

        playerElement.className = `player-item ${playerType}`;
        playerElement.dataset.playerId = player.id;
        playerElement.dataset.playerPosition = player.position || ''; 

        const nameElement = document.createElement('div');
        nameElement.className = 'player-name';
        nameElement.textContent = player.name;

        const positionElement = document.createElement('div');
        positionElement.className = 'player-position text-muted';
        positionElement.textContent = player.position;

        playerElement.appendChild(nameElement);
        playerElement.appendChild(positionElement);

        return playerElement;
    }

    function showMessage(text, type = 'success') {
        saveStatus.textContent = text;
        saveStatus.className = `alert alert-${type} mt-2`;
        setTimeout(() => {
            saveStatus.textContent = '';
            saveStatus.className = '';
        }, 4000);
    }

    function saveTeamLineup() {
        const lineup = {};
        document.querySelectorAll('.player-slot').forEach(slot => {
            const playerElem = slot.querySelector('.player-item');
            if (playerElem) {
                lineup[slot.dataset.position] = {
                    playerId: playerElem.dataset.playerId,
                    playerPosition: playerElem.dataset.playerPosition,
                    slotType: slot.dataset.type,
                    slotLabel: slot.querySelector('.position-label').textContent
                };
            }
        });

        const tacticValue = tacticSelect ? tacticSelect.value : 'balanced';
        const payload = {
            lineup: lineup,
            tactic: tacticValue
        };

        console.log('Sending lineup payload:', payload);

        fetch(`/clubs/detail/${clubId}/save-team-lineup/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': document.querySelector('input[name="csrfmiddlewaretoken"]').value
            },
            body: JSON.stringify(payload),
            credentials: 'include'
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showMessage('Lineup saved!');
            } else {
                showMessage(`Error saving lineup: ${data.error || ''}`, 'danger');
            }
        })
        .catch(error => {
            showMessage('Server error', 'danger');
            console.error('Error saving lineup:', error);
        });
    }

    function loadTeamLineup() {
        fetch(`/clubs/detail/${clubId}/get-team-lineup/`)
            .then(response => response.json())
            .then(data => {
                if (data.lineup) {
                    Object.entries(data.lineup).forEach(([slotIndex, details]) => {
                        const slot = document.querySelector(`.player-slot[data-position="${slotIndex}"]`);
                        if (!slot || !details) return;

                        const playerId = details.playerId;
                        const playerElem = document.querySelector(`.player-item[data-player-id="${playerId}"]`);
                        if (playerElem) {
                            slot.classList.remove('empty');  // Убираем класс empty
                            slot.appendChild(playerElem);
                        }
                    });
                }
                if (data.tactic) {
                    tacticSelect.value = data.tactic;
                }
            })
            .catch(error => {
                showMessage('Error loading lineup', 'danger');
                console.error('Error loading lineup:', error);
            });
    }

    function resetLineup() {
        document.querySelectorAll('.player-slot .player-item').forEach(player => {
            playerList.appendChild(player);
        });
        document.querySelectorAll('.player-slot').forEach(slot => {
            slot.classList.add('empty');
        });
        saveTeamLineup();
        showMessage('Lineup has been reset');
    }

    if (resetButton) {
        resetButton.addEventListener('click', resetLineup);
    }

    function initializeSortable() {
        new Sortable(playerList, {
            group: 'shared',
            animation: 150,
            onStart: function(evt) {
                const playerType = getPlayerType(evt.item.dataset.playerPosition);
                document.querySelectorAll('.player-slot.empty').forEach(slot => {
                    if (isValidPosition(playerType, slot.dataset.type)) {
                        slot.classList.add('highlight');
                    }
                });
            },
            onEnd: function(evt) {
                document.querySelectorAll('.player-slot').forEach(slot => {
                    slot.classList.remove('highlight');
                    slot.classList.remove('dragover');
                });
                saveTeamLineup();
            }
        });

        document.querySelectorAll('.player-slot').forEach(slot => {
            new Sortable(slot, {
                group: 'shared',
                animation: 150,
                onAdd: function(evt) {
                    const slotElement = evt.to;
                    const newPlayer = evt.item;
                    
                    if (isValidPosition(getPlayerType(newPlayer.dataset.playerPosition), slotElement.dataset.type)) {
                        slotElement.classList.remove('empty');
                        slotElement.classList.remove('highlight');
                        
                        slotElement.querySelectorAll('.player-item').forEach(existingPlayer => {
                            if (existingPlayer !== newPlayer) {
                                playerList.appendChild(existingPlayer);
                                slotElement.classList.add('empty');
                            }
                        });
                        
                        slotElement.appendChild(newPlayer);
                        saveTeamLineup();
                    } else {
                        playerList.appendChild(newPlayer);
                        showMessage('Invalid player position!', 'danger');
                    }
                },
                onRemove: function(evt) {
                    const slot = evt.from;
                    slot.classList.add('empty');
                }
            });

            slot.addEventListener('dragenter', function(e) {
                if (slot.classList.contains('empty') && slot.classList.contains('highlight')) {
                    slot.classList.add('dragover');
                }
            });
            
            slot.addEventListener('dragleave', function(e) {
                slot.classList.remove('dragover');
            });
        });
    }

    fetch(`/clubs/detail/${clubId}/get-players/`)
        .then(response => response.json())
        .then(players => {
            players.forEach(player => {
                const playerElement = createPlayerElement(player);
                playerList.appendChild(playerElement);
            });
            initializeSortable();
            loadTeamLineup();
        })
        .catch(error => {
            showMessage('Error loading players', 'danger');
            console.error('Error loading players:', error);
        });
});

================
File: matches/tasks.py
================
import time
import logging
from celery import shared_task
from django.utils import timezone
from channels.layers import get_channel_layer
from asgiref.sync import async_to_sync

from .models import Match, MatchEvent
from .match_simulation import simulate_one_minute

logger = logging.getLogger(__name__)


@shared_task(name='matches.simulate_match_minute')
def simulate_match_minute(match_id: int):
    """
    Запускает симуляцию 1 виртуальной минуты матча (через match_simulation).
    Это вызывается, например, каждые 5 секунд, 
    или любым другим механизмом.
    """
    try:
        simulate_one_minute(match_id)
        logger.info(f"Successfully simulated minute for match {match_id}")
    except Exception as e:
        logger.error(f"Error simulating minute for match {match_id}: {str(e)}")
        raise


@shared_task(name='matches.broadcast_minute_events_in_chunks')
def broadcast_minute_events_in_chunks(match_id: int, minute: int, duration: int = 10):
    """
    Поштучно (с паузой) отправляет по WebSocket все события, 
    созданные в указанную минуту матча.

    :param match_id: ID матча
    :param minute: виртуальная футбольная минута, события которой нужно разослать
    :param duration: за сколько секунд мы хотим показать все события этой минуты
                     (напр. если в минуте 5 событий и duration=10, то каждые ~2с отправляем событие)
    """
    try:
        match = Match.objects.get(id=match_id)

        # Если матч уже 'finished', просто игнорируем
        if match.status == 'finished':
            logger.info(f"Match {match_id} is finished. No chunked broadcast needed.")
            return

        # Получаем все события, относящиеся к этой минуте
        # и сортируем их в порядке добавления (в базе может быть порядок по id).
        events = list(
            MatchEvent.objects.filter(match=match, minute=minute).order_by('id')
        )
        total_events = len(events)

        if total_events == 0:
            logger.info(f"No events to broadcast for match {match_id}, minute {minute}")
            return

        logger.info(
            f"Will broadcast {total_events} events for match {match_id}, minute {minute}, "
            f"spread over {duration} seconds."
        )

        # Подключаемся к каналам
        channel_layer = get_channel_layer()

        # Рассчитываем, через какой интервал отправлять события
        # Например, если 5 событий и duration=10, то каждые 2 секунды.
        chunk_time = duration / float(total_events)

        for i, event in enumerate(events):
            # Формируем "mini-update" со списком из 1 события
            single_event_data = {
                "minute": event.minute,
                "event_type": event.event_type,
                "description": event.description,
            }

            # Собираем структуру данных для отправки
            update_data = {
                "minute": match.current_minute,
                "home_score": match.home_score,
                "away_score": match.away_score,
                "status": match.status,
                # В этот раз отправляем только 1 событие (event),
                # чтобы на фронте поочередно "проигрывать" их внутри одной минуты
                "events": [single_event_data]
            }

            # Логируем
            logger.info(
                f"Broadcasting event {i+1}/{total_events} for match {match_id}, minute {minute}"
            )

            # Отправляем в WebSocket (через group_send)
            async_to_sync(channel_layer.group_send)(
                f"match_{match_id}",
                {
                    "type": "match_update",
                    "data": update_data
                }
            )

            # Делаем паузу между событиями
            if i < total_events - 1:
                logger.debug(f"Sleeping {chunk_time:.2f} seconds before next event...")
                time.sleep(chunk_time)

        logger.info(f"Finished broadcasting {total_events} events for match {match_id}, minute {minute}")

    except Match.DoesNotExist:
        logger.error(f"Match {match_id} does not exist")
    except Exception as e:
        logger.error(f"Error in broadcast_minute_events_in_chunks for match {match_id}: {str(e)}")
        raise

================
File: matches/templates/matches/create_match.html
================
{% extends 'core/base.html' %}

{% block content %}
<div class="container">
    <div class="row justify-content-center">
        <div class="col-md-8">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title h4 mb-0">Create New Match</h2>
                </div>
                <div class="card-body">
                    <form method="post">
                        {% csrf_token %}
                        
                        {% for field in form %}
                        <div class="mb-3">
                            <label for="{{ field.id_for_label }}" class="form-label">
                                {{ field.label }}
                            </label>
                            {% if field.field.widget.input_type == 'select' %}
                                <select name="{{ field.name }}" id="{{ field.id_for_label }}" 
                                        class="form-select {% if field.errors %}is-invalid{% endif %}">
                                    {% for value, label in field.field.choices %}
                                        <option value="{{ value }}"
                                                {% if value == field.value|stringformat:"s" %}selected{% endif %}>
                                            {{ label }}
                                        </option>
                                    {% endfor %}
                                </select>
                            {% else %}
                                {{ field.as_widget }}
                            {% endif %}
                            {% if field.errors %}
                                <div class="invalid-feedback">
                                    {{ field.errors|join:", " }}
                                </div>
                            {% endif %}
                            {% if field.help_text %}
                                <small class="form-text text-muted">{{ field.help_text }}</small>
                            {% endif %}
                        </div>
                        {% endfor %}
                        
                        <div class="d-grid gap-2">
                            <button type="submit" class="btn btn-primary">Create Match</button>
                            <a href="{% url 'home' %}" class="btn btn-outline-secondary">Back to Home</a>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

================
File: matches/templates/matches/match_detail.html
================
{% extends 'core/base.html' %}
{% load static %}

{% block content %}
<div class="container">
    <div class="row">
        <div class="col-12">
            <!-- Основная информация о матче -->
            <div class="card mb-4" id="matchInfoArea" data-match-id="{{ match.id }}" data-match-status="{{ match.status }}">
                <div class="card-header">
                    <h2 class="mb-0">Match Details</h2>
                </div>
                <div class="card-body">
                    <div class="text-center mb-4">
                        <div class="row align-items-center">
                            <div class="col-md-5">
                                <a href="{% url 'clubs:club_detail' match.home_team.id %}" class="text-decoration-none">
                                    <h3>{{ match.home_team.name }}</h3>
                                    {% if match.home_team.is_bot %}
                                        <span class="badge bg-secondary">Bot</span>
                                    {% endif %}
                                </a>
                            </div>
                            <div class="col-md-2">
                                {% if match.status == 'finished' %}
                                    <h3 class="score" id="finalScore">{{ match.home_score }} - {{ match.away_score }}</h3>
                                {% else %}
                                    <h3 class="score" id="score">{{ match.home_score }} - {{ match.away_score }}</h3>
                                {% endif %}
                            </div>
                            <div class="col-md-5">
                                <a href="{% url 'clubs:club_detail' match.away_team.id %}" class="text-decoration-none">
                                    <h3>{{ match.away_team.name }}</h3>
                                    {% if match.away_team.is_bot %}
                                        <span class="badge bg-secondary">Bot</span>
                                    {% endif %}
                                </a>
                            </div>
                        </div>
                    </div>

                    <div class="row mb-4">
                        <div class="col-md-6">
                            <p><strong>Date:</strong> {{ match.datetime|date:"d M Y H:i" }}</p>
                            <p><strong>Status:</strong> 
                                <span class="badge {% if match.status == 'finished' %}bg-success{% elif match.status == 'in_progress' %}bg-warning{% else %}bg-secondary{% endif %}">
                                    {{ match.get_status_display }}
                                </span>
                            </p>
                            <p><strong>Time:</strong> <span id="matchTime">{% if match.status == 'in_progress' %}{{ match.current_minute }}'{% else %}90'{% endif %}</span></p>
                        </div>
                        <div class="col-md-6 text-end">
                            {% if match.status == 'finished' %}
                                <button id="startReplayBtn" class="btn btn-primary">Watch Replay</button>
                            {% endif %}
                        </div>
                    </div>

                    <!-- Область реплея (скрыта, если match.status != 'finished') -->
                    <div id="replayArea" style="display: none;">
                        <div class="card mb-4">
                            <div class="card-header">
                                <div class="d-flex justify-content-between align-items-center">
                                    <h4 class="mb-0" id="replayTime">0'</h4>
                                    <h4 class="mb-0" id="replayScore"></h4>
                                </div>
                            </div>
                            <div class="card-body">
                                <div id="replayEvents" class="list-group">
                                    <!-- События реплея будут добавляться сюда динамически -->
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Изначальный список событий -->
                    <div id="originalEvents">
                        <h4>Match Events</h4>
                        <div class="list-group">
                            {% for event in match_events %}
                                <div class="list-group-item">
                                    <div class="d-flex justify-content-between align-items-center">
                                        <div>
                                            <strong>{{ event.minute }}'</strong> - 
                                            {{ event.event_type }}: {{ event.description }}
                                        </div>
                                    </div>
                                </div>
                            {% empty %}
                                <div class="list-group-item text-center text-muted">
                                    No events recorded
                                </div>
                            {% endfor %}
                        </div>
                    </div>
                </div>
            </div>

            <!-- Добавляем РАЗДЕЛ ДЛЯ ВЫВОДА СОСТАВОВ -->
            <div class="row mb-4">
                <div class="col-md-6">
                    <div class="card">
                        <div class="card-header">
                            <h3 class="mb-0 h5">Home Lineup</h3>
                        </div>
                        <div class="card-body p-0">
                            <ul class="list-group list-group-flush">
                                {% for slot, player in home_lineup_list %}
                                <li class="list-group-item">
                                    Slot {{ slot }}:
                                    {% if player %}
                                        {{ player.first_name }} {{ player.last_name }} ({{ player.position }})
                                    {% else %}
                                        <em class="text-muted">No player assigned</em>
                                    {% endif %}
                                </li>
                                {% endfor %}
                            </ul>
                        </div>
                    </div>
                </div><!-- /.col-md-6 -->

                <div class="col-md-6">
                    <div class="card">
                        <div class="card-header">
                            <h3 class="mb-0 h5">Away Lineup</h3>
                        </div>
                        <div class="card-body p-0">
                            <ul class="list-group list-group-flush">
                                {% for slot, player in away_lineup_list %}
                                <li class="list-group-item">
                                    Slot {{ slot }}:
                                    {% if player %}
                                        {{ player.first_name }} {{ player.last_name }} ({{ player.position }})
                                    {% else %}
                                        <em class="text-muted">No player assigned</em>
                                    {% endif %}
                                </li>
                                {% endfor %}
                            </ul>
                        </div>
                    </div>
                </div><!-- /.col-md-6 -->
            </div>

            <div class="text-center">
                <a href="{% url 'matches:match_list' %}" class="btn btn-outline-primary">Back to Matches</a>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script src="{% static 'matches/js/match_replay.js' %}"></script>
{% if match.status == 'in_progress' %}
<script src="{% static 'matches/js/live_match.js' %}"></script>
{% endif %}

<style>
    .match-event {
        padding: 10px;
        border-bottom: 1px solid #eee;
        animation: fadeIn 0.5s;
    }
    
    .event-time {
        font-weight: bold;
        margin-right: 10px;
    }
    
    .event-icon {
        margin-right: 10px;
    }
    
    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(-10px); }
        to { opacity: 1; transform: translateY(0); }
    }
</style>
{% endblock %}

================
File: matches/templates/matches/match_list.html
================
{% extends 'base.html' %}

{% block content %}
<div class="container mt-4">
    <div class="card">
        <div class="card-header">
            <h2 class="card-title mb-0">
                {% if championship %}
                    Matches - {{ championship.league.name }} ({{ championship.season.name }})
                {% else %}
                    Your Team's Matches
                {% endif %}
            </h2>
        </div>
        <div class="card-body">
            {% if matches %}
                {% regroup matches by championshipmatch.round as rounds_list %}
                {% for round in rounds_list %}
                    <div class="mb-4">
                        <h4 class="mb-3">Round {{ round.grouper }}</h4>
                        <div class="list-group">
                            {% for match in round.list %}
                                <a href="{% url 'matches:match_detail' match.id %}" 
                                   class="list-group-item list-group-item-action">
                                    <div class="d-flex justify-content-between align-items-center">
                                        <div>
                                            <span class="{% if match.home_team == user.club %}fw-bold{% endif %}">
                                                {{ match.home_team.name }}
                                            </span>
                                            {% if match.status == 'finished' %}
                                                <strong>{{ match.home_score }} - {{ match.away_score }}</strong>
                                            {% else %}
                                                vs
                                            {% endif %}
                                            <span class="{% if match.away_team == user.club %}fw-bold{% endif %}">
                                                {{ match.away_team.name }}
                                            </span>
                                        </div>
                                        <div>
                                            <span class="badge {% if match.status == 'finished' %}bg-success{% else %}bg-secondary{% endif %}">
                                                {{ match.get_status_display }}
                                            </span>
                                            <small class="text-muted ms-2">
                                                {{ match.datetime|date:"d M Y H:i" }}
                                            </small>
                                        </div>
                                    </div>
                                </a>
                            {% endfor %}
                        </div>
                    </div>
                {% empty %}
                    <p class="text-muted">No matches found.</p>
                {% endfor %}
            {% else %}
                <p class="text-muted">No matches found.</p>
            {% endif %}
        </div>
    </div>
</div>
{% endblock %}

================
File: matches/templates/matches/team_selection.html
================
{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Team Selection for {{ club.name }}</title>
    <style>
        .pitch {
            width: 600px;
            height: 400px;
            background-color: #4CAF50;
            position: relative;
            margin: 20px auto;
        }
        .player-slot {
            width: 50px;
            height: 50px;
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
        }
        .player-slot.empty {
            background-color: transparent;
            border: none;
        }
        .player-slot.highlight {
            background-color: rgba(255, 255, 255, 0.5);
            border: 2px solid #fff;
        }
        .player-slot:not(.empty) {
            background-color: rgba(255, 255, 255, 0.5);
            border: 2px solid #fff;
        }
        .player-slot.dragover {
            background-color: rgba(255, 255, 255, 0.7);
            border: 2px dashed #fff;
        }
        .player-list {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 20px;
        }
        .player-item {
            width: 100px;
            height: 50px;
            background-color: #f1f1f1;
            margin: 5px;
            padding: 5px;
            cursor: move;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
            text-align: center;
        }
        .tactics-section {
            text-align: center;
            margin-top: 20px;
        }
        .tactics-section select {
            font-size: 14px;
            padding: 5px;
        }
        .position-label {
            color: #fff;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <h1 style="text-align: center;">Select Your Team Lineup for {{ club.name }}</h1>

    <div class="tactics-section">
        <label for="tacticSelect"><strong>Select Tactic:</strong></label>
        <select id="tacticSelect">
            <option value="attacking">Attacking</option>
            <option value="balanced" selected>Balanced</option>
            <option value="defensive">Defensive</option>
        </select>
    </div>
    
    <div class="pitch" id="pitch">
        <!-- Player slots will be added here dynamically -->
    </div>

    <h2 style="text-align: center;">Available Players</h2>
    <div class="player-list" id="playerList">
        <!-- Available players will be added here dynamically -->
    </div>

    <!-- Добавляем скрытое поле с ID клуба -->
    <input type="hidden" id="clubId" value="{{ club.id }}">

    <button id="resetButton" style="display:block;margin:20px auto;">Reset Selection</button>
    <span id="saveStatus" style="display:block;text-align:center;"></span>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.14.0/Sortable.min.js"></script>
    <script src="{% static 'matches/js/team_selection.js' %}"></script>
</body>
</html>

================
File: matches/tests.py
================
from django.test import TestCase

# Create your tests here.

================
File: matches/urls.py
================
from django.urls import path
from . import views

app_name = 'matches'

urlpatterns = [
    path('', views.MatchListView.as_view(), name='match_list'),
    path('create/', views.CreateMatchView.as_view(), name='create_match'),
    path('<int:pk>/', views.match_detail, name='match_detail'),  # Изменили на функцию
    path('<int:match_id>/simulate/', views.simulate_match_view, name='simulate_match'),
    path('championship/<int:championship_id>/matches/', views.MatchListView.as_view(), name='championship_matches'),
    path('<int:match_id>/events-json/', views.get_match_events, name='match_events_json'),
]

================
File: matches/views.py
================
from django.shortcuts import render, redirect, get_object_or_404
from django.views.generic import CreateView, DetailView, ListView
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib.auth.decorators import login_required
from django.urls import reverse
from django.http import JsonResponse, HttpResponseNotAllowed
from django.utils.decorators import method_decorator
from django.utils import timezone
from django.db.models import Q

from .models import Match, MatchEvent
from clubs.models import Club
from players.models import Player

# Импорт Celery-задач
from .tasks import simulate_match_minute, broadcast_minute_events_in_chunks


def get_match_lineups(match):
    """
    Получает составы матча и связанных игроков оптимизированным способом.
    """
    home_lineup_list = []
    away_lineup_list = []

    # Домашний состав
    if match.home_lineup and isinstance(match.home_lineup, dict):
        # Если это вложенный словарь с 'lineup'
        if 'lineup' in match.home_lineup:
            lineup_dict = match.home_lineup['lineup']
        else:
            lineup_dict = match.home_lineup
        
        # Получаем ID игроков и объекты одним запросом
        home_ids = [int(val) for val in lineup_dict.values()]
        home_players = {str(p.id): p for p in Player.objects.filter(id__in=home_ids)}
        
        # Формируем список в нужном порядке
        for slot_num in range(11):
            slot_key = str(slot_num)
            player_id = lineup_dict.get(slot_key)
            player_obj = home_players.get(str(player_id)) if player_id else None
            home_lineup_list.append((slot_key, player_obj))

    # Гостевой состав
    if match.away_lineup and isinstance(match.away_lineup, dict):
        # Если это вложенный словарь с 'lineup'
        if 'lineup' in match.away_lineup:
            lineup_dict = match.away_lineup['lineup']
        else:
            lineup_dict = match.away_lineup

        # Получаем ID игроков и объекты одним запросом
        away_ids = [int(val) for val in lineup_dict.values()]
        away_players = {str(p.id): p for p in Player.objects.filter(id__in=away_ids)}
        
        # Формируем список в нужном порядке
        for slot_num in range(11):
            slot_key = str(slot_num)
            player_id = lineup_dict.get(slot_key)
            player_obj = away_players.get(str(player_id)) if player_id else None
            away_lineup_list.append((slot_key, player_obj))

    return home_lineup_list, away_lineup_list


@login_required
def match_detail(request, pk):
    match = get_object_or_404(Match, pk=pk)
    
    # Получаем события матча
    match_events = match.events.order_by('minute')
    
    # Получаем составы и добавляем отладочный вывод
    home_lineup_list, away_lineup_list = get_match_lineups(match)
    print(f"\nDEBUG Match {match.id}")
    print("Raw home_lineup:", match.home_lineup)
    print("Raw away_lineup:", match.away_lineup)
    print("Processed home_lineup:", [(slot, player.first_name if player else 'Empty') for slot, player in home_lineup_list])
    print("Processed away_lineup:", [(slot, player.first_name if player else 'Empty') for slot, player in away_lineup_list])
    
    # Проверяем, является ли пользователь членом одной из команд
    is_user_team = (
        request.user.is_authenticated
        and (
            request.user.club == match.home_team
            or request.user.club == match.away_team
        )
    )
    
    context = {
        'match': match,
        'match_events': match_events,
        'is_user_team': is_user_team,
        'home_lineup_list': home_lineup_list,
        'away_lineup_list': away_lineup_list
    }
    
    return render(request, 'matches/match_detail.html', context)


class CreateMatchView(CreateView):
    model = Match
    fields = ['home_team', 'away_team', 'datetime']
    template_name = 'matches/create_match.html'

    def form_valid(self, form):
        match = form.save()
        return redirect(reverse('matches:match_detail', kwargs={'pk': match.pk}))


class MatchListView(LoginRequiredMixin, ListView):
    model = Match
    template_name = 'matches/match_list.html'
    context_object_name = 'matches'

    def get_queryset(self):
        championship_id = self.kwargs.get('championship_id')
        if championship_id:
            return Match.objects.filter(
                championshipmatch__championship_id=championship_id
            ).order_by('championshipmatch__round', 'datetime')

        return Match.objects.filter(
            Q(home_team=self.request.user.club) | 
            Q(away_team=self.request.user.club)
        )


@login_required
def get_match_events(request, match_id):
    match = get_object_or_404(Match, id=match_id)
    events = match.events.order_by('minute').values('minute', 'event_type', 'description')
    return JsonResponse({
        'events': list(events), 
        'match': {
            'home_team': match.home_team.name,
            'away_team': match.away_team.name,
            'final_score': {
                'home': match.home_score,
                'away': match.away_score
            }
        }
    })


@login_required
def simulate_match_view(request, match_id):
    if match_id == 0:
        club = request.user.club
        opponent = Club.objects.filter(is_bot=True).exclude(id=club.id).order_by('?').first()
        if not opponent:
            return render(request, 'matches/no_opponent.html', {'club': club})
        
        match = Match.objects.create(
            home_team=club,
            away_team=opponent,
            datetime=timezone.now(),
            status='in_progress',
            current_minute=0,
            # Добавляем тактики
            home_tactic='balanced',
            away_tactic='balanced',
        )
        match_id = match.id
    
    return redirect('matches:match_detail', pk=match_id)


@login_required
def simulate_match_minute_view(request, match_id):
    if request.method != 'POST':
        return HttpResponseNotAllowed(['POST'], "This endpoint requires POST request")

    match = get_object_or_404(Match, id=match_id)
    simulate_match_minute.delay(match_id)
    next_minute = match.current_minute + 1
    broadcast_minute_events_in_chunks.delay(match_id, next_minute, duration=10)

    return JsonResponse({
        'status': 'ok',
        'message': f"Requested simulation of 1 minute for match {match_id} + chunked broadcast."
    })

================
File: players/admin.py
================
from django.contrib import admin
from .models import Player

@admin.register(Player)
class PlayerAdmin(admin.ModelAdmin):
    list_display = ('last_name', 'first_name', 'club', 'nationality')
    list_filter = ('club', 'nationality')
    search_fields = ('last_name', 'first_name', 'club__name', 'nationality')

# или можно использовать
# admin.site.register(Player, PlayerAdmin)

================
File: players/apps.py
================
from django.apps import AppConfig


class PlayersConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'players'

================
File: players/constants.py
================
PLAYER_PRICES = {
    1: 500,  # 1 класс - 500 токенов
    2: 300,  # 2 класс - 300 токенов
    3: 200,  # 3 класс - 200 токенов
    4: 100,  # 4 класс - 100 токенов
}

================
File: players/management/commands/update_player_attributes.py
================
from django.core.management.base import BaseCommand
from django.db import transaction
from players.models import Player
from players.utils import generate_player_stats
from tqdm import tqdm

class Command(BaseCommand):
    help = 'Updates existing players with new attributes'

    def add_arguments(self, parser):
        parser.add_argument(
            '--batch-size',
            type=int,
            default=100,
            help='How many players to update in one batch'
        )

    def handle(self, *args, **options):
        batch_size = options['batch_size']
        
        try:
            # Получаем общее количество игроков
            total_players = Player.objects.count()
            self.stdout.write(f"Found {total_players} players to update")

            # Используем tqdm для отображения прогресса
            with tqdm(total=total_players) as pbar:
                # Обрабатываем игроков батчами для экономии памяти
                for i in range(0, total_players, batch_size):
                    with transaction.atomic():
                        players = Player.objects.all()[i:i+batch_size]
                        
                        for player in players:
                            # Генерируем новые характеристики
                            stats = generate_player_stats(
                                player.position,
                                player.player_class
                            )
                            
                            # Обновляем характеристики игрока
                            for attr, value in stats.items():
                                setattr(player, attr, value)
                            
                            player.save()
                            pbar.update(1)
                
                self.stdout.write(
                    self.style.SUCCESS(
                        f'Successfully updated {total_players} players'
                    )
                )

        except Exception as e:
            self.stdout.write(
                self.style.ERROR(
                    f'Error updating players: {str(e)}'
                )
            )
            raise e

================
File: players/models.py
================
from django.db import models
from django_countries.fields import CountryField

class Player(models.Model):
    POSITIONS = [
        ('Goalkeeper', 'Goalkeeper'),
        ('Right Back', 'Right Back'),
        ('Left Back', 'Left Back'),
        ('Center Back', 'Center Back'),
        ('Defensive Midfielder', 'Central Defensive Midfielder'),
        ('Right Midfielder', 'Right Midfielder'),
        ('Central Midfielder', 'Central Midfielder'),
        ('Left Midfielder', 'Left Midfielder'),
        ('Attacking Midfielder', 'Attacking Midfielder'),
        ('Center Forward', 'Center Forward'),
    ]

    # Базовая информация
    first_name = models.CharField(max_length=100, default='', verbose_name="First Name")
    last_name = models.CharField(max_length=100, default='', verbose_name="Last Name")
    age = models.PositiveIntegerField(default=17, verbose_name="Age")
    club = models.ForeignKey(
        'clubs.Club',
        on_delete=models.CASCADE,
        verbose_name="Club",
        null=True,
        blank=True
    )
    nationality = CountryField(
        blank_label='(select country)',
        verbose_name="Nationality",
        default="Unknown"
    )
    position = models.CharField(
        max_length=50,
        choices=POSITIONS,
        default='Unknown',
        verbose_name="Position"
    )
    player_class = models.IntegerField(
        default=1,
        verbose_name="Player Class"
    )

    # Общие характеристики
    strength = models.IntegerField(default=0, verbose_name="Strength")
    stamina = models.IntegerField(default=0, verbose_name="Stamina")
    pace = models.IntegerField(default=0, verbose_name="Pace")
    positioning = models.IntegerField(default=0, verbose_name="Positioning")

    # Характеристики для вратарей
    reflexes = models.IntegerField(default=0, verbose_name="Reflexes")
    handling = models.IntegerField(default=0, verbose_name="Handling")
    aerial = models.IntegerField(default=0, verbose_name="Aerial")
    command = models.IntegerField(default=0, verbose_name="Command")
    from .constants import PLAYER_PRICES
    
    def get_purchase_cost(self):
        """Возвращает стоимость покупки игрока в зависимости от класса"""
        return PLAYER_PRICES.get(self.player_class, 200)  # По умолчанию 200 токенов
    
    distribution = models.IntegerField(default=0, verbose_name="Distribution")
    one_on_one = models.IntegerField(default=0, verbose_name="One on One")
    rebound_control = models.IntegerField(default=0, verbose_name="Rebound Control")
    shot_reading = models.IntegerField(default=0, verbose_name="Shot Reading")

    # Характеристики для полевых игроков
    marking = models.IntegerField(default=0, verbose_name="Marking")
    tackling = models.IntegerField(default=0, verbose_name="Tackling")
    work_rate = models.IntegerField(default=0, verbose_name="Work Rate")
    passing = models.IntegerField(default=0, verbose_name="Passing")
    crossing = models.IntegerField(default=0, verbose_name="Crossing")
    dribbling = models.IntegerField(default=0, verbose_name="Dribbling")
    flair = models.IntegerField(default=0, verbose_name="Flair")
    heading = models.IntegerField(default=0, verbose_name="Heading")
    finishing = models.IntegerField(default=0, verbose_name="Finishing")
    long_range = models.IntegerField(default=0, verbose_name="Long Range")
    vision = models.IntegerField(default=0, verbose_name="Vision")
    accuracy = models.IntegerField(default=0, verbose_name="Accuracy")

    # Новое поле опыта
    experience = models.FloatField(default=0.0, verbose_name="Experience")

    # Счётчик, сколько раз уже прокачивали игрока за токены
    boost_count = models.PositiveIntegerField(
        default=0,
        help_text="How many times this player was boosted via tokens."
    )

    class Meta:
        unique_together = ('first_name', 'last_name')
        verbose_name = 'Player'
        verbose_name_plural = 'Players'
        ordering = ['last_name', 'first_name']

    # === Группы характеристик (полевые игроки) ===
    FIELD_PLAYER_GROUPS = {
        # Физические
        'physical': ('strength', 'stamina', 'pace'),
        # Защитные
        'defensive': ('marking', 'tackling', 'heading'),
        # Атакующие
        'attacking': ('finishing', 'heading', 'long_range'),
        # Ментальные
        'mental': ('vision', 'flair'),
        # Технические
        'technical': ('dribbling', 'crossing', 'passing'),
        # Тактические
        'tactical': ('work_rate', 'positioning', 'accuracy'),
    }

    # === Группы характеристик (вратари) ===
    GOALKEEPER_GROUPS = {
        'physical': ('strength', 'stamina', 'pace'),
        'core_gk_skills': ('reflexes', 'handling', 'positioning', 'aerial'),
        'additional_gk_skills': (
            'command',
            'distribution',
            'one_on_one',
            'shot_reading',
            'rebound_control'
        ),
    }

    def __str__(self):
        club_name = self.club.name if self.club else 'No Club'
        return f"{self.first_name} {self.last_name} ({club_name}) - {self.position}"

    def save(self, *args, **kwargs):
        if not self.nationality and self.club:
            self.nationality = self.club.country
        super().save(*args, **kwargs)

    @property
    def full_name(self):
        return f"{self.first_name} {self.last_name}"

    @property
    def is_goalkeeper(self):
        return self.position == 'Goalkeeper'

    @property
    def overall_rating(self):
        """
        Вычисляет общий рейтинг игрока на основе его характеристик,
        учитывая опыт. Допустим, за каждый 1.0 опыта характеристики растут на 1%.
        """
        # Коэффициент влияния опыта (1% за единицу опыта)
        experience_multiplier = 1 + self.experience * 0.01

        if self.is_goalkeeper:
            attributes = [
                self.reflexes, self.handling, self.aerial,
                self.command, self.distribution, self.one_on_one,
                self.rebound_control, self.shot_reading,
                self.strength, self.stamina, self.pace, self.positioning
            ]
        else:
            attributes = [
                self.strength, self.stamina, self.pace,
                self.marking, self.tackling, self.work_rate,
                self.positioning, self.passing, self.crossing,
                self.dribbling, self.flair, self.heading,
                self.finishing, self.long_range, self.vision,
                self.accuracy
            ]

        # Применяем опытный множитель
        adjusted_attributes = [int(attr * experience_multiplier) for attr in attributes]
        return sum(adjusted_attributes) // len(adjusted_attributes)

    def get_position_specific_attributes(self):
        """Возвращает атрибуты, специфичные для позиции игрока."""
        if self.is_goalkeeper:
            return {
                'reflexes': self.reflexes,
                'handling': self.handling,
                'aerial': self.aerial,
                'command': self.command,
                'distribution': self.distribution,
                'one_on_one': self.one_on_one,
                'rebound_control': self.rebound_control,
                'shot_reading': self.shot_reading
            }
        else:
            return {
                'marking': self.marking,
                'tackling': self.tackling,
                'work_rate': self.work_rate,
                'passing': self.passing,
                'crossing': self.crossing,
                'dribbling': self.dribbling,
                'flair': self.flair,
                'heading': self.heading,
                'finishing': self.finishing,
                'long_range': self.long_range,
                'vision': self.vision,
                'accuracy': self.accuracy
            }

    def get_boost_cost(self) -> int:
        """
        Возвращает стоимость (в токенах) следующей «платной» тренировки:
          1-я тренировка: 0 токенов
          2-я тренировка: 1 токен
          3-я тренировка: 2 токена
          4-я тренировка: 4 токенов
          5-я тренировка: 8 токенов
          ...
        """
        # Если ещё не было прокачек (boost_count=0), значит первая прокачка бесплатна
        if self.boost_count == 0:
            return 0
        # Если boost_count=1 => следующая (вторая) тренировка = 2^(1-1)=1, и т.д.
        return 2 ** (self.boost_count - 1)

================
File: players/player_attributes_config.py
================
# player_attributes_config.py

CLASS_1_WEIGHTS = {
    'Goalkeeper': {
        'attributes': {
            'reflexes': [(1.0, 0.40), (1.0, 0.35), (1.0, 0.25)],
            'handling': [(1.0, 0.40), (1.0, 0.35), (1.0, 0.25)],
            'positioning': [(1.0, 0.40), (1.0, 0.35), (1.0, 0.25)],
            'aerial': [(1.0, 0.50), (1.0, 0.30), (1.0, 0.20)],
            'jumping': [(1.0, 0.50), (1.0, 0.30), (1.0, 0.20)],
            'command': [(1.0, 0.50), (1.0, 0.30), (1.0, 0.20)],
            'throwing': [(1.0, 0.50), (1.0, 0.30), (1.0, 0.20)],
            'kicking': [(1.0, 0.50), (1.0, 0.30), (1.0, 0.20)],
            'strength': [(1.0, 0.50), (1.0, 0.30), (1.0, 0.20)],
            'stamina': [(1.0, 0.50), (1.0, 0.30), (1.0, 0.20)],
            'pace': [(1.0, 0.50), (1.0, 0.30), (1.0, 0.20)],
        }
    },
    'Right Back': {
        'attributes': {
            'tackling': [(2.3, 0.40), (1.3, 0.35), (3.3, 0.25)],
            'marking': [(2.2, 0.40), (1.2, 0.35), (3.2, 0.25)],
            'crossing': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'strength': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'pace': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'passing': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'dribbling': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'ball_control': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)],
            'vision': [(1.0, 1.0)]
        }
    },
    'Left Back': {
        'attributes': {
            'tackling': [(2.3, 0.40), (1.3, 0.35), (3.3, 0.25)],
            'marking': [(2.2, 0.40), (1.2, 0.35), (3.2, 0.25)],
            'crossing': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'strength': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'pace': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'passing': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'dribbling': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'ball_control': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)],
            'vision': [(1.0, 1.0)]
        }
    },
    'Center Back': {
        'attributes': {
            'marking': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'tackling': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'heading': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'strength': [(2.5, 0.50), (2.0, 0.30), (3.0, 0.20)],
            'stamina': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'pace': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'work_rate': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'positioning': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'passing': [(1.0, 1.0)],
            'dribbling': [(1.0, 1.0)],
            'ball_control': [(1.0, 1.0)],
            'crossing': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)],
            'vision': [(1.0, 1.0)]
        }
    },
    'Defensive Midfielder': {
        'attributes': {
            'tackling': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'marking': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'passing': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'strength': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'pace': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'work_rate': [(2.5, 0.50), (2.0, 0.30), (3.0, 0.20)],
            'positioning': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'vision': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'ball_control': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'heading': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'crossing': [(1.0, 1.0)],
            'dribbling': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)]
        }
    },
    'Central Midfielder': {
        'attributes': {
            'passing': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'vision': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'work_rate': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'ball_control': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'positioning': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'strength': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'pace': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'tackling': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'marking': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'dribbling': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'long_range': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'crossing': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)]
        }
    },
    'Right Midfielder': {
        'attributes': {
            'crossing': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'pace': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'dribbling': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'ball_control': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'passing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'vision': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'strength': [(1.0, 1.0)],
            'marking': [(1.0, 1.0)],
            'tackling': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)]
        }
    },
    'Left Midfielder': {
        'attributes': {
            'crossing': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'pace': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'dribbling': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'ball_control': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'passing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'vision': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'strength': [(1.0, 1.0)],
            'marking': [(1.0, 1.0)],
            'tackling': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)]
        }
    },
    'Attacking Midfielder': {
        'attributes': {
            'dribbling': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'vision': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'ball_control': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'passing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'finishing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'long_range': [(2.0, 0.50)],
            'strength': [(1.0, 1.0)],
            'stamina': [(1.0, 1.0)],
            'pace': [(1.0, 1.0)],
            'work_rate': [(1.0, 1.0)],
            'positioning': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)]
        }
    },
    'Center Forward': {
        'attributes': {
            'crossing': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'pace': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'dribbling': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'ball_control': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'passing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'vision': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'strength': [(1.0, 1.0)],
            'marking': [(1.0, 1.0)],
            'tackling': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)]
        }
    },
}

CLASS_2_WEIGHTS = {
    'Goalkeeper': {
        'attributes': {
            'reflexes': [(3.3, 0.40), (2.3, 0.35), (1.3, 0.25)],
            'handling': [(3.2, 0.40), (2.2, 0.35), (1.2, 0.25)],
            'positioning': [(3.1, 0.40), (2.1, 0.35), (1.1, 0.25)],
            'aerial': [(2.0, 0.50), (1.5, 0.30), (1.0, 0.20)],
            'jumping': [(2.0, 0.50), (1.5, 0.30), (1.0, 0.20)],
            'command': [(2.0, 0.50), (1.5, 0.30), (1.0, 0.20)],
            'throwing': [(1.5, 0.50), (1.0, 0.30), (0.5, 0.20)],
            'kicking': [(1.5, 0.50), (1.0, 0.30), (0.5, 0.20)],
            'strength': [(1.5, 0.50), (1.0, 0.30), (0.5, 0.20)],
            'stamina': [(1.0, 1.0)],
            'pace': [(1.0, 1.0)]
        }
    },
    'Right Back': {
        'attributes': {
            'tackling': [(2.3, 0.40), (1.3, 0.35), (3.3, 0.25)],
            'marking': [(2.2, 0.40), (1.2, 0.35), (3.2, 0.25)],
            'crossing': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'strength': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'pace': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'passing': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'dribbling': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'ball_control': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)],
            'vision': [(1.0, 1.0)]
        }
    },
    'Left Back': {
        'attributes': {
            'tackling': [(2.3, 0.40), (1.3, 0.35), (3.3, 0.25)],
            'marking': [(2.2, 0.40), (1.2, 0.35), (3.2, 0.25)],
            'crossing': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'strength': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'pace': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'passing': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'dribbling': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'ball_control': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)],
            'vision': [(1.0, 1.0)]
        }
    },
    'Center Back': {
        'attributes': {
            'marking': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'tackling': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'heading': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'strength': [(2.5, 0.50), (2.0, 0.30), (3.0, 0.20)],
            'stamina': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'pace': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'work_rate': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'positioning': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'passing': [(1.0, 1.0)],
            'dribbling': [(1.0, 1.0)],
            'ball_control': [(1.0, 1.0)],
            'crossing': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)],
            'vision': [(1.0, 1.0)]
        }
    },
    'Defensive Midfielder': {
        'attributes': {
            'tackling': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'marking': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'passing': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'strength': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'pace': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'work_rate': [(2.5, 0.50), (2.0, 0.30), (3.0, 0.20)],
            'positioning': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'vision': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'ball_control': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'heading': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'crossing': [(1.0, 1.0)],
            'dribbling': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)]
        }
    },
    'Central Midfielder': {
        'attributes': {
            'passing': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'vision': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'work_rate': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'ball_control': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'positioning': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'strength': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'pace': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'tackling': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'marking': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'dribbling': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'long_range': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'crossing': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)]
        }
    },
    'Right Midfielder': {
        'attributes': {
            'crossing': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'pace': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'dribbling': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'ball_control': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'passing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'vision': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'strength': [(1.0, 1.0)],
            'marking': [(1.0, 1.0)],
            'tackling': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)]
        }
    },
    'Left Midfielder': {
        'attributes': {
            'crossing': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'pace': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'dribbling': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'ball_control': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'passing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'vision': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'strength': [(1.0, 1.0)],
            'marking': [(1.0, 1.0)],
            'tackling': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)]
        }
    },
    'Attacking Midfielder': {
        'attributes': {
            'dribbling': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'vision': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'ball_control': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'passing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'finishing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'long_range': [(2.0, 0.50)],
            'strength': [(1.0, 1.0)],
            'stamina': [(1.0, 1.0)],
            'pace': [(1.0, 1.0)],
            'work_rate': [(1.0, 1.0)],
            'positioning': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)]
        }
    },
    'Center Forward': {
        'attributes': {
            'crossing': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'pace': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'dribbling': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'ball_control': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'passing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'vision': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'strength': [(1.0, 1.0)],
            'marking': [(1.0, 1.0)],
            'tackling': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)]
        }
    },
}

CLASS_3_WEIGHTS = {
    'Goalkeeper': {
        'attributes': {
            'reflexes':  [(3.7, 0.40), (3.7, 0.35), (0.7, 0.25)],
            'handling':  [(3.7, 0.40), (3.7, 0.35), (0.7, 0.25)],
            'positioning':  [(3.7, 0.40), (3.7, 0.35), (0.7, 0.25)],
            'aerial': [(2.0, 0.50), (1.5, 0.30), (1.0, 0.20)],
            'jumping': [(2.0, 0.50), (1.5, 0.30), (1.0, 0.20)],
            'command': [(2.0, 0.50), (1.5, 0.30), (1.0, 0.20)],
            'throwing': [(1.5, 0.50), (1.0, 0.30), (0.5, 0.20)],
            'kicking': [(1.5, 0.50), (1.0, 0.30), (0.5, 0.20)],
            'strength': [(1.5, 0.50), (1.0, 0.30), (0.5, 0.20)],
            'stamina': [(1.0, 1.0)],
            'pace': [(1.0, 1.0)]
        }
    },
    'Right Back': {
        'attributes': {
            'tackling': [(2.3, 0.40), (1.3, 0.35), (3.3, 0.25)],
            'marking': [(2.2, 0.40), (1.2, 0.35), (3.2, 0.25)],
            'crossing': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'strength': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'pace': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'passing': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'dribbling': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'ball_control': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)],
            'vision': [(1.0, 1.0)]
        }
    },
    'Left Back': {
        'attributes': {
            'tackling': [(2.3, 0.40), (1.3, 0.35), (3.3, 0.25)],
            'marking': [(2.2, 0.40), (1.2, 0.35), (3.2, 0.25)],
            'crossing': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'strength': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'pace': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'passing': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'dribbling': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'ball_control': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)],
            'vision': [(1.0, 1.0)]
        }
    },
    'Center Back': {
        'attributes': {
            'marking': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'tackling': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'heading': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'strength': [(2.5, 0.50), (2.0, 0.30), (3.0, 0.20)],
            'stamina': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'pace': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'work_rate': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'positioning': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'passing': [(1.0, 1.0)],
            'dribbling': [(1.0, 1.0)],
            'ball_control': [(1.0, 1.0)],
            'crossing': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)],
            'vision': [(1.0, 1.0)]
        }
    },
    'Defensive Midfielder': {
        'attributes': {
            'tackling': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'marking': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'passing': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'strength': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'pace': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'work_rate': [(2.5, 0.50), (2.0, 0.30), (3.0, 0.20)],
            'positioning': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'vision': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'ball_control': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'heading': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'crossing': [(1.0, 1.0)],
            'dribbling': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)]
        }
    },
    'Central Midfielder': {
        'attributes': {
            'passing': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'vision': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'work_rate': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'ball_control': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'positioning': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'strength': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'pace': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'tackling': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'marking': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'dribbling': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'long_range': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'crossing': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)]
        }
    },
    'Right Midfielder': {
        'attributes': {
            'crossing': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'pace': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'dribbling': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'ball_control': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'passing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'vision': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'strength': [(1.0, 1.0)],
            'marking': [(1.0, 1.0)],
            'tackling': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)]
        }
    },
    'Left Midfielder': {
        'attributes': {
            'crossing': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'pace': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'dribbling': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'ball_control': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'passing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'vision': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'strength': [(1.0, 1.0)],
            'marking': [(1.0, 1.0)],
            'tackling': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)]
        }
    },
    'Attacking Midfielder': {
        'attributes': {
            'dribbling': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'vision': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'ball_control': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'passing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'finishing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'long_range': [(2.0, 0.50)],
            'strength': [(1.0, 1.0)],
            'stamina': [(1.0, 1.0)],
            'pace': [(1.0, 1.0)],
            'work_rate': [(1.0, 1.0)],
            'positioning': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)]
        }
    },
    'Center Forward': {
        'attributes': {
            'crossing': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'pace': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'dribbling': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'ball_control': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'passing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'vision': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'strength': [(1.0, 1.0)],
            'marking': [(1.0, 1.0)],
            'tackling': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)]
        }
    },
}

CLASS_4_WEIGHTS = {
    'Goalkeeper': {
        'attributes': {
            'reflexes': [(0.7, 0.40), (0.7, 0.35), (0.7, 0.25)],
            'handling':  [(0.7, 0.40), (0.7, 0.35), (0.7, 0.25)],
            'positioning':  [(0.7, 0.40), (0.7, 0.35), (0.7, 0.25)],
            'aerial': [(2.0, 0.50), (1.5, 0.30), (1.0, 0.20)],
            'jumping': [(2.0, 0.50), (1.5, 0.30), (1.0, 0.20)],
            'command': [(2.0, 0.50), (1.5, 0.30), (1.0, 0.20)],
            'throwing': [(1.5, 0.50), (1.0, 0.30), (0.5, 0.20)],
            'kicking': [(1.5, 0.50), (1.0, 0.30), (0.5, 0.20)],
            'strength': [(1.5, 0.50), (1.0, 0.30), (0.5, 0.20)],
            'stamina': [(1.0, 1.0)],
            'pace': [(1.0, 1.0)]
        }
    },
    'Right Back': {
        'attributes': {
            'tackling': [(2.3, 0.40), (1.3, 0.35), (3.3, 0.25)],
            'marking': [(2.2, 0.40), (1.2, 0.35), (3.2, 0.25)],
            'crossing': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'strength': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'pace': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'passing': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'dribbling': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'ball_control': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)],
            'vision': [(1.0, 1.0)]
        }
    },
    'Left Back': {
        'attributes': {
            'tackling': [(2.3, 0.40), (1.3, 0.35), (3.3, 0.25)],
            'marking': [(2.2, 0.40), (1.2, 0.35), (3.2, 0.25)],
            'crossing': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'strength': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'pace': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'passing': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'dribbling': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'ball_control': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)],
            'vision': [(1.0, 1.0)]
        }
    },
    'Center Back': {
        'attributes': {
            'marking': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'tackling': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'heading': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'strength': [(2.5, 0.50), (2.0, 0.30), (3.0, 0.20)],
            'stamina': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'pace': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'work_rate': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'positioning': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'passing': [(1.0, 1.0)],
            'dribbling': [(1.0, 1.0)],
            'ball_control': [(1.0, 1.0)],
            'crossing': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)],
            'vision': [(1.0, 1.0)]
        }
    },
    'Defensive Midfielder': {
        'attributes': {
            'tackling': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'marking': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'passing': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'strength': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'pace': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'work_rate': [(2.5, 0.50), (2.0, 0.30), (3.0, 0.20)],
            'positioning': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'vision': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'ball_control': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'heading': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'crossing': [(1.0, 1.0)],
            'dribbling': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)]
        }
    },
    'Central Midfielder': {
        'attributes': {
            'passing': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'vision': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'work_rate': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'ball_control': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'positioning': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'strength': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'pace': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'tackling': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'marking': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'dribbling': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'long_range': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'crossing': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)]
        }
    },
    'Right Midfielder': {
        'attributes': {
            'crossing': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'pace': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'dribbling': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'ball_control': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'passing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'vision': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'strength': [(1.0, 1.0)],
            'marking': [(1.0, 1.0)],
            'tackling': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)]
        }
    },
    'Left Midfielder': {
        'attributes': {
            'crossing': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'pace': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'dribbling': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'ball_control': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'passing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'vision': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'strength': [(1.0, 1.0)],
            'marking': [(1.0, 1.0)],
            'tackling': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)]
        }
    },
    'Attacking Midfielder': {
        'attributes': {
            'dribbling': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'vision': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'ball_control': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'passing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'finishing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'long_range': [(2.0, 0.50)],
            'strength': [(1.0, 1.0)],
            'stamina': [(1.0, 1.0)],
            'pace': [(1.0, 1.0)],
            'work_rate': [(1.0, 1.0)],
            'positioning': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)]
        }
    },
    'Center Forward': {
        'attributes': {
            'crossing': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'pace': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'dribbling': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'ball_control': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'passing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'vision': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'strength': [(1.0, 1.0)],
            'marking': [(1.0, 1.0)],
            'tackling': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)]
        }
    },
}

POSITIONS_WEIGHTS = {
    1: CLASS_1_WEIGHTS,
    2: CLASS_2_WEIGHTS,
    3: CLASS_3_WEIGHTS,
    4: CLASS_4_WEIGHTS
}

================
File: players/templates/players/player_confirm_delete.html
================
{% extends 'core/base.html' %}
{% load static %}

{% block content %}
<div class="container mt-4">
    <div class="card">
        <div class="card-body">
            <h3 class="card-title">Удаление игрока</h3>
            <p class="card-text">
                Вы действительно хотите удалить игрока
                <strong>{{ player.first_name }} {{ player.last_name }}</strong>?
            </p>
            <form method="POST">
                {% csrf_token %}
                <button type="submit" class="btn btn-danger">
                    Удалить
                </button>
                <a href="{% url 'players:player_detail' pk=player.id %}"
                   class="btn btn-secondary">
                    Отмена
                </a>
            </form>
        </div>
    </div>
</div>
{% endblock %}

================
File: players/templates/players/player_detail.html
================
{% extends 'core/base.html' %}
{% load static %}

{% block content %}
<div class="container">
    <div class="row">
        <div class="col-12">
            <div class="card mb-4">
                <div class="card-header">
                    <div class="d-flex justify-content-between align-items-center">
                        <h1 class="h3 mb-0">{{ player.first_name }} {{ player.last_name }}</h1>
                        <span class="badge bg-primary">{{ player.position }}</span>
                    </div>
                </div>
                <div class="card-body">
                    <!-- Player Info -->
                    <div class="row mb-4">
                        <div class="col-md-6">
                            <h4 class="h5 mb-3">Player Info</h4>
                            <ul class="list-unstyled">
                                <li class="mb-2">
                                    <strong>Club:</strong>
                                    <a href="{% url 'clubs:club_detail' player.club.id %}" class="text-decoration-none">
                                        {{ player.club.name }}
                                        {% if player.club.is_bot %}<small>(Bot)</small>{% endif %}
                                    </a>
                                </li>
                                <li class="mb-2"><strong>Age:</strong> {{ player.age }}</li>
                                <li class="mb-2"><strong>Nationality:</strong> {{ player.nationality }}</li>
                                {% if player.player_class %}
                                <li class="mb-2">
                                    <strong>Class:</strong>
                                    <span class="badge bg-info">Class {{ player.player_class }}</span>
                                </li>
                                {% endif %}
                                <!-- Отображение опыта -->
                                <li class="mb-2">
                                    <strong>Experience:</strong> {{ player.experience|floatformat:1 }}
                                </li>
                                <li class="mb-2">
                                    <strong>Overall Rating:</strong>
                                    <span class="badge bg-success">{{ player.overall_rating }}</span>
                                </li>
                            </ul>
                        </div>
                    </div>

                    <!-- Attributes -->
                    <div class="row">
                        {% if player.position == 'Goalkeeper' %}
                            <!-- Physical Attributes -->
                            <div class="col-md-4 mb-3">
                                <div class="card h-100">
                                    <div class="card-header">
                                        <h5 class="card-title h6 mb-0">Physical</h5>
                                    </div>
                                    <div class="card-body">
                                        <div class="attribute-list">
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Strength:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar"
                                                         data-attr="strength"
                                                         style="width: {{ player.strength }}%;"
                                                         aria-valuenow="{{ player.strength }}"
                                                         aria-valuemin="0" aria-valuemax="100">
                                                        {{ player.strength }}
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Stamina:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar"
                                                         data-attr="stamina"
                                                         style="width: {{ player.stamina }}%;"
                                                         aria-valuenow="{{ player.stamina }}"
                                                         aria-valuemin="0" aria-valuemax="100">
                                                        {{ player.stamina }}
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Pace:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar"
                                                         data-attr="pace"
                                                         style="width: {{ player.pace }}%;"
                                                         aria-valuenow="{{ player.pace }}"
                                                         aria-valuemin="0" aria-valuemax="100">
                                                        {{ player.pace }}
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <!-- Goalkeeper Core Skills -->
                            <div class="col-md-4 mb-3">
                                <div class="card h-100">
                                    <div class="card-header">
                                        <h5 class="card-title h6 mb-0">Core Goalkeeper Skills</h5>
                                    </div>
                                    <div class="card-body">
                                        <div class="attribute-list">
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Reflexes:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar"
                                                         data-attr="reflexes"
                                                         style="width: {{ player.reflexes }}%;"
                                                         aria-valuenow="{{ player.reflexes }}"
                                                         aria-valuemin="0" aria-valuemax="100">
                                                        {{ player.reflexes }}
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Handling:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar"
                                                         data-attr="handling"
                                                         style="width: {{ player.handling }}%;"
                                                         aria-valuenow="{{ player.handling }}"
                                                         aria-valuemin="0" aria-valuemax="100">
                                                        {{ player.handling }}
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Positioning:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar"
                                                         data-attr="positioning"
                                                         style="width: {{ player.positioning }}%;"
                                                         aria-valuenow="{{ player.positioning }}"
                                                         aria-valuemin="0" aria-valuemax="100">
                                                        {{ player.positioning }}
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Aerial:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar"
                                                         data-attr="aerial"
                                                         style="width: {{ player.aerial }}%;"
                                                         aria-valuenow="{{ player.aerial }}"
                                                         aria-valuemin="0" aria-valuemax="100">
                                                        {{ player.aerial }}
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Additional Goalkeeper Skills -->
                            <div class="col-md-4 mb-3">
                                <div class="card h-100">
                                    <div class="card-header">
                                        <h5 class="card-title h6 mb-0">Additional Skills</h5>
                                    </div>
                                    <div class="card-body">
                                        <div class="attribute-list">
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Command:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar"
                                                         data-attr="command"
                                                         style="width: {{ player.command }}%;"
                                                         aria-valuenow="{{ player.command }}"
                                                         aria-valuemin="0" aria-valuemax="100">
                                                        {{ player.command }}
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Distribution:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar"
                                                         data-attr="distribution"
                                                         style="width: {{ player.distribution }}%;"
                                                         aria-valuenow="{{ player.distribution }}"
                                                         aria-valuemin="0" aria-valuemax="100">
                                                        {{ player.distribution }}
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>One on One:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar"
                                                         data-attr="one_on_one"
                                                         style="width: {{ player.one_on_one }}%;"
                                                         aria-valuenow="{{ player.one_on_one }}"
                                                         aria-valuemin="0" aria-valuemax="100">
                                                        {{ player.one_on_one }}
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Shot Reading:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar"
                                                         data-attr="shot_reading"
                                                         style="width: {{ player.shot_reading }}%;"
                                                         aria-valuenow="{{ player.shot_reading }}"
                                                         aria-valuemin="0" aria-valuemax="100">
                                                        {{ player.shot_reading }}
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Rebound Control:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar"
                                                         data-attr="rebound_control"
                                                         style="width: {{ player.rebound_control }}%;"
                                                         aria-valuenow="{{ player.rebound_control }}"
                                                         aria-valuemin="0" aria-valuemax="100">
                                                        {{ player.rebound_control }}
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        {% else %}
                            <!-- Physical Attributes -->
                            <div class="col-md-4 mb-3">
                                <div class="card h-100">
                                    <div class="card-header">
                                        <h5 class="card-title h6 mb-0">Physical</h5>
                                    </div>
                                    <div class="card-body">
                                        <div class="attribute-list">
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Strength:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar"
                                                         data-attr="strength"
                                                         style="width: {{ player.strength }}%;"
                                                         aria-valuenow="{{ player.strength }}"
                                                         aria-valuemin="0" aria-valuemax="100">
                                                        {{ player.strength }}
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Stamina:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar"
                                                         data-attr="stamina"
                                                         style="width: {{ player.stamina }}%;"
                                                         aria-valuenow="{{ player.stamina }}"
                                                         aria-valuemin="0" aria-valuemax="100">
                                                        {{ player.stamina }}
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Pace:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar"
                                                         data-attr="pace"
                                                         style="width: {{ player.pace }}%;"
                                                         aria-valuenow="{{ player.pace }}"
                                                         aria-valuemin="0" aria-valuemax="100">
                                                        {{ player.pace }}
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Work Rate:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar"
                                                         data-attr="work_rate"
                                                         style="width: {{ player.work_rate }}%;"
                                                         aria-valuenow="{{ player.work_rate }}"
                                                         aria-valuemin="0" aria-valuemax="100">
                                                        {{ player.work_rate }}
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Technical Skills -->
                            <div class="col-md-4 mb-3">
                                <div class="card h-100">
                                    <div class="card-header">
                                        <h5 class="card-title h6 mb-0">Technical Skills</h5>
                                    </div>
                                    <div class="card-body">
                                        <div class="attribute-list">
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Passing:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar"
                                                         data-attr="passing"
                                                         style="width: {{ player.passing }}%;"
                                                         aria-valuenow="{{ player.passing }}"
                                                         aria-valuemin="0" aria-valuemax="100">
                                                        {{ player.passing }}
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Dribbling:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar"
                                                         data-attr="dribbling"
                                                         style="width: {{ player.dribbling }}%;"
                                                         aria-valuenow="{{ player.dribbling }}"
                                                         aria-valuemin="0" aria-valuemax="100">
                                                        {{ player.dribbling }}
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Crossing:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar"
                                                         data-attr="crossing"
                                                         style="width: {{ player.crossing }}%;"
                                                         aria-valuenow="{{ player.crossing }}"
                                                         aria-valuemin="0" aria-valuemax="100">
                                                        {{ player.crossing }}
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Heading:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar"
                                                         data-attr="heading"
                                                         style="width: {{ player.heading }}%;"
                                                         aria-valuenow="{{ player.heading }}"
                                                         aria-valuemin="0" aria-valuemax="100">
                                                        {{ player.heading }}
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Finishing:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar"
                                                         data-attr="finishing"
                                                         style="width: {{ player.finishing }}%;"
                                                         aria-valuenow="{{ player.finishing }}"
                                                         aria-valuemin="0" aria-valuemax="100">
                                                        {{ player.finishing }}
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Mental & Additional Skills -->
                            <div class="col-md-4 mb-3">
                                <div class="card h-100">
                                    <div class="card-header">
                                        <h5 class="card-title h6 mb-0">Mental & Additional Skills</h5>
                                    </div>
                                    <div class="card-body">
                                        <div class="attribute-list">
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Vision:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar"
                                                         data-attr="vision"
                                                         style="width: {{ player.vision }}%;"
                                                         aria-valuenow="{{ player.vision }}"
                                                         aria-valuemin="0" aria-valuemax="100">
                                                        {{ player.vision }}
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Flair:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar"
                                                         data-attr="flair"
                                                         style="width: {{ player.flair }}%;"
                                                         aria-valuenow="{{ player.flair }}"
                                                         aria-valuemin="0" aria-valuemax="100">
                                                        {{ player.flair }}
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Accuracy:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar"
                                                         data-attr="accuracy"
                                                         style="width: {{ player.accuracy }}%;"
                                                         aria-valuenow="{{ player.accuracy }}"
                                                         aria-valuemin="0" aria-valuemax="100">
                                                        {{ player.accuracy }}
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Long Range:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar"
                                                         data-attr="long_range"
                                                         style="width: {{ player.long_range }}%;"
                                                         aria-valuenow="{{ player.long_range }}"
                                                         aria-valuemin="0" aria-valuemax="100">
                                                        {{ player.long_range }}
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Defense Skills -->
                            <div class="col-md-12 mb-3">
                                <div class="card">
                                    <div class="card-header">
                                        <h5 class="card-title h6 mb-0">Defense Skills</h5>
                                    </div>
                                    <div class="card-body">
                                        <div class="row">
                                            <div class="col-md-4">
                                                <div class="d-flex justify-content-between mb-2">
                                                    <span>Marking:</span>
                                                    <div class="progress w-50">
                                                        <div class="progress-bar"
                                                             data-attr="marking"
                                                             style="width: {{ player.marking }}%;"
                                                             aria-valuenow="{{ player.marking }}"
                                                             aria-valuemin="0" aria-valuemax="100">
                                                            {{ player.marking }}
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="col-md-4">
                                                <div class="d-flex justify-content-between mb-2">
                                                    <span>Tackling:</span>
                                                    <div class="progress w-50">
                                                        <div class="progress-bar"
                                                             data-attr="tackling"
                                                             style="width: {{ player.tackling }}%;"
                                                             aria-valuenow="{{ player.tackling }}"
                                                             aria-valuemin="0" aria-valuemax="100">
                                                            {{ player.tackling }}
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="col-md-4">
                                                <div class="d-flex justify-content-between mb-2">
                                                    <span>Positioning:</span>
                                                    <div class="progress w-50">
                                                        <div class="progress-bar"
                                                             data-attr="positioning"
                                                             style="width: {{ player.positioning }}%;"
                                                             aria-valuenow="{{ player.positioning }}"
                                                             aria-valuemin="0" aria-valuemax="100">
                                                            {{ player.positioning }}
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        {% endif %}
                    </div>

                    <!-- Кнопка "Improve Stats" -->
                    <div class="mt-4 text-center">
                        <!-- При клике открываем модальное окно -->
                        <button type="button" class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#boostModal">
                            Improve Stats
                        </button>
                    </div>

                    <!-- Если текущий пользователь — владелец клуба, показать кнопку «Удалить игрока» -->
                    {% if user.is_authenticated and player.club.owner == user %}
                    <div class="mt-4 text-center">
                        <a href="{% url 'players:player_delete' player_id=player.id %}"
                           class="btn btn-danger">
                            Удалить игрока
                        </a>
                    </div>
                    {% endif %}

                </div>
            </div>
        </div>
    </div>
</div>

<!-- Модальное окно для выбора группы улучшения -->
<div class="modal fade" id="boostModal" tabindex="-1" aria-labelledby="boostModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <!-- Убираем классический method="POST" и action="...", будет AJAX -->
      <form id="boostForm">
        {% csrf_token %}
        <div class="modal-header">
          <h5 class="modal-title" id="boostModalLabel">Choose Group to Improve</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <p class="text-muted mb-2">
            Next training cost:
            <strong id="costLabel">
              {{ player.get_boost_cost }}
            </strong>
            token{{ player.get_boost_cost|pluralize }}
          </p>

          {% if player.is_goalkeeper %}
            <div class="mb-3">
              <label for="groupSelect" class="form-label">Available Groups:</label>
              <select class="form-select" id="groupSelect" name="group">
                <option value="physical">Physical</option>
                <option value="core_gk_skills">Core GK Skills</option>
                <option value="additional_gk_skills">Additional GK Skills</option>
              </select>
            </div>
          {% else %}
            <div class="mb-3">
              <label for="groupSelect" class="form-label">Available Groups:</label>
              <select class="form-select" id="groupSelect" name="group">
                <option value="physical">Physical</option>
                <option value="defensive">Defensive</option>
                <option value="attacking">Attacking</option>
                <option value="mental">Mental</option>
                <option value="technical">Technical</option>
                <option value="tactical">Tactical</option>
              </select>
            </div>
          {% endif %}

          <p class="small text-muted">
            +3 points will be added to the selected group's attributes.
            Then +2 points will be randomly allocated among other attributes.
          </p>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
            Cancel
          </button>
          <!-- При нажатии => AJAX -->
          <button type="submit" class="btn btn-primary" id="improveSubmitBtn">
            Improve Now
          </button>
        </div>
      </form>
    </div>
  </div>
</div>

{% endblock %}

{% block extra_js %}
<script>
/**
 * Функция для получения csrftoken из cookie.
 */
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

document.addEventListener('DOMContentLoaded', function() {
    const boostForm = document.getElementById('boostForm');
    const costLabel = document.getElementById('costLabel');
    const playerId = "{{ player.id }}";
    const csrfToken = getCookie('csrftoken');

    // При сабмите формы делаем AJAX запрос, чтобы улучшить характеристики
    boostForm.addEventListener('submit', function(e) {
        e.preventDefault(); // Не даем форме перейти на новую страницу

        // Собираем данные: group
        const groupSelect = document.getElementById('groupSelect');
        const groupVal = groupSelect.value;

        // Отправляем fetch POST на ваш эндпоинт (players/<id>/boost_player_ajax/)
        fetch("{% url 'players:player_boost_ajax' player.id %}", {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                group: groupVal
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // Обновляем прогресс-бары (анимированно):
                applyStatChanges(data.changes);

                // Обновляем costLabel (следующая стоимость)
                costLabel.textContent = data.next_cost;

                // Закрываем модалку
                const modalEl = document.getElementById('boostModal');
                const modal = bootstrap.Modal.getInstance(modalEl);
                modal.hide();

            } else {
                alert(data.message || 'Error while boosting stats');
            }
        })
        .catch(err => {
            console.error(err);
            alert('Something went wrong');
        });
    });
});

/**
 * Функция, которая анимированно обновляет прогресс-бары.
 * @param {object} changes — словарь { stamina: { old: 50, new: 53 }, ... }
 */
function applyStatChanges(changes) {
    // Для каждого атрибута
    for (let attrName in changes) {
        const oldVal = changes[attrName].old;
        const newVal = changes[attrName].new;

        // Ищем прогресс-бар: data-attr="attrName"
        const bar = document.querySelector(`.progress-bar[data-attr="${attrName}"]`);
        if (!bar) continue;

        // Обновим текст внутри
        bar.textContent = newVal;

        // Начальный width = oldVal
        bar.style.width = oldVal + '%';

        // Если прирост > 0, показываем +N поверх progress
        const diff = newVal - oldVal;
        if (diff > 0) {
            const plusBadge = document.createElement('span');
            plusBadge.className = 'badge bg-success position-absolute translate-middle';
            plusBadge.style.zIndex = '9999';
            plusBadge.textContent = `+${diff}`;
            // Добавляем поверх .progress
            bar.parentNode.appendChild(plusBadge);

            // Через 10 сек удалим badge
            setTimeout(() => {
                plusBadge.remove();
            }, 10000);
        }

        // Анимация плавного перехода
        requestAnimationFrame(() => {
            bar.style.transition = 'width 1s ease';
            bar.style.width = newVal + '%';
        });

        // Через 1.5s убираем transition, чтобы при повторном улучшении анимация сработала снова
        setTimeout(() => {
            bar.style.transition = '';
        }, 1500);
    }
}
</script>
{% endblock %}

================
File: players/tests.py
================
# players/tests.py
from django.test import TestCase, Client
from django.urls import reverse
from accounts.models import CustomUser  # Импортируем пользовательскую модель
from clubs.models import Club
from players.models import Player

class PlayerTests(TestCase):
    def setUp(self):
        # Создаем тестового пользователя с использованием CustomUser
        self.user = CustomUser.objects.create_user(username='testuser', email='testuser@example.com', password='password123')

        # Создаем тестовый клуб и назначаем пользователя владельцем
        self.club = Club.objects.create(name='Test Club', country='Test Country', owner=self.user)

        # Создаем клиента для тестирования запросов
        self.client = Client()
        self.client.login(username='testuser', password='password123')

        # URL для создания игрока
        self.create_player_url = reverse('create_player', kwargs={'pk': self.club.pk})

    def test_generate_player(self):
        """Тест генерации нового игрока"""
        response = self.client.get(self.create_player_url, {'position': 'Midfielder'})

        # Проверяем перенаправление на страницу игрока
        self.assertEqual(response.status_code, 302)
        player = Player.objects.first()
        self.assertIsNotNone(player)
        self.assertEqual(player.position, 'Midfielder')
        self.assertEqual(player.club, self.club)

    def test_player_detail_page(self):
        """Тест страницы деталей игрока, включая отображение характеристик"""
        player = Player.objects.create(
            club=self.club,
            first_name='Test',
            last_name='Player',
            nationality='Test Country',
            age=18,
            position='Midfielder',
            strength=80,
            stamina=75,
            pace=70
        )
        detail_url = reverse('players:player_detail', args=[player.pk])
        response = self.client.get(detail_url)

        # Проверяем корректность отображения страницы деталей игрока
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, player.first_name)
        self.assertContains(response, player.last_name)
        self.assertContains(response, 'Strength: 80')
        self.assertContains(response, 'Stamina: 75')
        self.assertContains(response, 'Pace: 70')

================
File: players/urls.py
================
from django.urls import path
from .views import PlayerDetailView, boost_player, delete_player
from . import views

urlpatterns = [
    path('detail/<int:pk>/', PlayerDetailView.as_view(), name='player_detail'),
    
    # AJAX boost
    path('<int:player_id>/boost_player_ajax/', views.boost_player_ajax, name='player_boost_ajax'),
    
    # Обычная прокачка
    path('boost/<int:player_id>/', boost_player, name='player_boost'),
    
    # Маршрут для удаления игрока
    path('delete/<int:player_id>/', delete_player, name='player_delete'),
]

================
File: players/utils.py
================
from scipy.stats import norm
import random
import sys
import os

def generate_stat(weight=1):
    """Генерирует базовую характеристику"""
    base_value = norm.rvs(50, 10)
    weighted_value = base_value * weight
    return max(1, min(99, int(weighted_value)))

def generate_player_stats(position, player_class):
    """Генерирует характеристики игрока в зависимости от позиции"""
    # Базовые характеристики
    base_stats = {
        'strength': generate_stat(),
        'stamina': generate_stat(),
        'pace': generate_stat(),
        'positioning': generate_stat(),
    }

    if position == 'Goalkeeper':
        # Характеристики вратаря (12 характеристик)
        gk_stats = {
            'reflexes': generate_stat(),
            'handling': generate_stat(),
            'aerial': generate_stat(),
            'command': generate_stat(),
            'distribution': generate_stat(),
            'one_on_one': generate_stat(),
            'rebound_control': generate_stat(),
            'shot_reading': generate_stat()
        }
        stats = {**base_stats, **gk_stats}
    else:
        # Характеристики полевого игрока (16 характеристик)
        field_stats = {
            'marking': generate_stat(),
            'tackling': generate_stat(),
            'work_rate': generate_stat(),
            'passing': generate_stat(),
            'crossing': generate_stat(),
            'dribbling': generate_stat(),
            'flair': generate_stat(),
            'heading': generate_stat(),
            'finishing': generate_stat(),
            'long_range': generate_stat(),
            'vision': generate_stat(),
            'accuracy': generate_stat()
        }
        stats = {**base_stats, **field_stats}

        # Модификаторы позиций
        position_modifiers = {
            'Center Back': {
                'marking': 1.2, 'tackling': 1.2, 'heading': 1.1,
                'strength': 1.1, 'finishing': 0.8, 'dribbling': 0.8
            },
            'Right Back': {
                'pace': 1.1, 'crossing': 1.1, 'stamina': 1.1,
                'tackling': 1.1, 'marking': 1.1
            },
            'Left Back': {
                'pace': 1.1, 'crossing': 1.1, 'stamina': 1.1,
                'tackling': 1.1, 'marking': 1.1
            },
            'Defensive Midfielder': {
                'tackling': 1.2, 'marking': 1.1, 'passing': 1.1,
                'work_rate': 1.2, 'vision': 1.1
            },
            'Central Midfielder': {
                'passing': 1.2, 'vision': 1.2, 'work_rate': 1.1,
                'stamina': 1.1, 'positioning': 1.1
            },
            'Attacking Midfielder': {
                'vision': 1.2, 'passing': 1.2, 'dribbling': 1.1,
                'flair': 1.2, 'finishing': 1.1
            },
            'Center Forward': {
                'finishing': 1.3, 'heading': 1.2, 'positioning': 1.2,
                'strength': 1.1, 'dribbling': 1.1
            }
        }

        # Применяем модификаторы позиции
        if position in position_modifiers:
            for attr, mod in position_modifiers[position].items():
                if attr in stats:
                    stats[attr] = min(99, int(stats[attr] * mod))

    # Модификатор класса игрока
    class_modifier = (5 - player_class) * 0.1  # +10% за каждый класс выше 1
    for key in stats:
        stats[key] = min(99, int(stats[key] * (1 + class_modifier)))

    return stats

def print_player_stats(stats):
    """Вспомогательная функция для вывода характеристик"""
    print("\nХарактеристики игрока:")
    total = 0
    count = 0
    for attr, value in sorted(stats.items()):
        print(f"{attr}: {value}")
        total += value
        count += 1
    if count > 0:
        print(f"\nСредний рейтинг: {total/count:.1f}")

================
File: players/views.py
================
import json
import random

from django.views.generic import DetailView
from django.shortcuts import get_object_or_404, redirect, render
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.http import JsonResponse

from .models import Player


class PlayerDetailView(DetailView):
    """
    Отображение детальной информации об игроке.
    Шаблон: players/player_detail.html
    """
    model = Player
    template_name = 'players/player_detail.html'


@login_required
def boost_player(request, player_id):
    """
    (Старый метод) Повышает характеристики игрока за токены (через обычный POST).
    Делает redirect обратно на страницу игрока.
    """
    player = get_object_or_404(Player, pk=player_id)
    user = request.user

    if request.method == 'POST':
        group_name = request.POST.get('group', '').strip()
        if not group_name:
            messages.error(request, "Не выбрана группа характеристик для улучшения.")
            return redirect('players:player_detail', pk=player_id)

        cost = player.get_boost_cost()
        if user.tokens < cost:
            messages.error(request, f"Недостаточно токенов. Нужно {cost}, а у вас {user.tokens}.")
            return redirect('players:player_detail', pk=player_id)

        # Определяем нужный словарь групп
        if player.is_goalkeeper:
            group_dict = Player.GOALKEEPER_GROUPS
        else:
            group_dict = Player.FIELD_PLAYER_GROUPS

        if group_name not in group_dict:
            messages.error(request, "Некорректная группа характеристик.")
            return redirect('players:player_detail', pk=player_id)

        # Списываем токены
        user.tokens -= cost
        user.save()

        # +3 очка к выбранной группе
        attrs_in_group = group_dict[group_name]
        for attr_name in attrs_in_group:
            current_val = getattr(player, attr_name, 0)
            setattr(player, attr_name, current_val + 1)

        # +2 очка к другим атрибутам
        if player.is_goalkeeper:
            all_attrs = list(set(sum(Player.GOALKEEPER_GROUPS.values(), ())))
        else:
            all_attrs = list(set(sum(Player.FIELD_PLAYER_GROUPS.values(), ())))

        other_attrs = [a for a in all_attrs if a not in attrs_in_group]
        for _ in range(2):
            rand_attr = random.choice(other_attrs)
            cur_val = getattr(player, rand_attr, 0)
            setattr(player, rand_attr, cur_val + 1)

        player.boost_count += 1
        player.save()

        messages.success(request,
                         f"Характеристики игрока успешно улучшены! "
                         f"Тренировка стоила {cost} токенов.")
        return redirect('players:player_detail', pk=player_id)

    # Не POST => просто редиректим на детальную страницу
    return redirect('players:player_detail', pk=player_id)


@login_required
def boost_player_ajax(request, player_id):
    """
    Повышает характеристики игрока за токены (AJAX).
    Возвращает JSON с информацией об изменённых характеристиках.
    """
    if request.method != 'POST':
        return JsonResponse({'success': False, 'message': 'Method not allowed'}, status=405)

    player = get_object_or_404(Player, pk=player_id)
    user = request.user

    try:
        data = json.loads(request.body)
        group_name = data.get('group', '').strip()
    except (json.JSONDecodeError, AttributeError):
        return JsonResponse({'success': False, 'message': 'Invalid JSON'}, status=400)

    if not group_name:
        return JsonResponse({'success': False, 'message': 'No group selected'}, status=400)

    cost = player.get_boost_cost()
    if user.tokens < cost:
        return JsonResponse({
            'success': False,
            'message': f"Недостаточно токенов. Нужно {cost}, а у вас {user.tokens}."
        }, status=400)

    # Определяем нужный словарь групп
    if player.is_goalkeeper:
        group_dict = Player.GOALKEEPER_GROUPS
    else:
        group_dict = Player.FIELD_PLAYER_GROUPS

    if group_name not in group_dict:
        return JsonResponse({'success': False, 'message': 'Некорректная группа'}, status=400)

    # Сохраняем "старые" значения, чтобы вернуть их в ответе
    if player.is_goalkeeper:
        all_attrs = list(set(sum(Player.GOALKEEPER_GROUPS.values(), ())))
    else:
        all_attrs = list(set(sum(Player.FIELD_PLAYER_GROUPS.values(), ())))

    old_values = {}
    for a in all_attrs:
        old_values[a] = getattr(player, a, 0)

    # Списываем токены
    user.tokens -= cost
    user.save()

    # +3 очка в выбранную группу
    attrs_in_group = group_dict[group_name]
    all_changed_attrs = set()
    for attr_name in attrs_in_group:
        cur_val = getattr(player, attr_name, 0)
        setattr(player, attr_name, cur_val + 1)
        all_changed_attrs.add(attr_name)

    # +2 к другим атрибутам
    other_attrs = [a for a in all_attrs if a not in attrs_in_group]
    for _ in range(2):
        rand_attr = random.choice(other_attrs)
        cur_val = getattr(player, rand_attr, 0)
        setattr(player, rand_attr, cur_val + 1)
        all_changed_attrs.add(rand_attr)

    player.boost_count += 1
    player.save()

    changes = {}
    for attr_name in all_changed_attrs:
        old_val = old_values[attr_name]
        new_val = getattr(player, attr_name, 0)
        changes[attr_name] = {
            'old': old_val,
            'new': new_val
        }

    return JsonResponse({
        'success': True,
        'message': f"Характеристики улучшены! Тренировка стоила {cost} токенов.",
        'changes': changes,
        'next_cost': player.get_boost_cost(),
        'tokens_left': user.tokens
    })


@login_required
def delete_player(request, player_id):
    """
    Удаление игрока с подтверждением.
    """
    player = get_object_or_404(Player, pk=player_id)
    # Проверяем, является ли пользователь владельцем клуба
    if player.club and player.club.owner != request.user:
        messages.error(request, "У вас нет прав на удаление этого игрока.")
        return redirect('players:player_detail', pk=player_id)

    if request.method == 'POST':
        club_id = player.club.id if player.club else None
        player_name = f"{player.first_name} {player.last_name}"
        player.delete()

        messages.success(request, f"Игрок {player_name} успешно удалён.")
        
        if club_id:
            return redirect('clubs:club_detail', pk=club_id)
        else:
            # Если вдруг нет клуба, возвращаем на главную
            return redirect('home')

    # Если GET – показываем страницу подтверждения
    return render(request, 'players/player_confirm_delete.html', {'player': player})

================
File: realfootballsim/__init__.py
================
from .celery import app as celery_app

__all__ = ('celery_app',)

================
File: realfootballsim/asgi.py
================
"""
ASGI config for realfootballsim project.
"""

import os
import django

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'realfootballsim.settings')
django.setup()

from channels.routing import ProtocolTypeRouter, URLRouter
from channels.auth import AuthMiddlewareStack
from django.core.asgi import get_asgi_application
from realfootballsim.routing import websocket_urlpatterns

application = ProtocolTypeRouter({
    "http": get_asgi_application(),
    "websocket": AuthMiddlewareStack(
        URLRouter(websocket_urlpatterns)
    ),
})

================
File: realfootballsim/celery.py
================
import os
from celery import Celery

# Устанавливаем переменную окружения для настроек Django
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'realfootballsim.settings')

app = Celery('realfootballsim')

# Загружаем настройки из settings.py
app.config_from_object('django.conf:settings', namespace='CELERY')

# Автоматически обнаруживаем и регистрируем задачи из всех приложений Django
app.autodiscover_tasks()

@app.task(bind=True)
def debug_task(self):
    print(f'Request: {self.request!r}')

================
File: realfootballsim/routing.py
================
from channels.routing import ProtocolTypeRouter, URLRouter
from django.urls import path
from matches.consumers import MatchConsumer

websocket_urlpatterns = [
    path("ws/match/<int:match_id>/", MatchConsumer.as_asgi()),
]

application = ProtocolTypeRouter({
    "websocket": URLRouter(websocket_urlpatterns),
})

================
File: realfootballsim/settings.py
================
from pathlib import Path
import os
from celery.schedules import crontab

# 1) Check if we're in production (IS_PRODUCTION=1) or dev (IS_PRODUCTION != '1')
IS_PRODUCTION = os.environ.get('IS_PRODUCTION')  # If not set, will be None

BASE_DIR = Path(__file__).resolve().parent.parent

# Default dev settings
SECRET_KEY = 'django-insecure-0p3aqax2r2xolyvtfda6q_aa@q1l6n!w4$8sjo1ed&*)h*2l37'
DEBUG = True
ALLOWED_HOSTS = ['127.0.0.1', 'localhost']

# If production environment variable is set, override specific settings
if IS_PRODUCTION == '1':
    DEBUG = False
    ALLOWED_HOSTS = ['128.199.49.228', 'www.realfootballsim.com', 'realfootballsim.com']

    CSRF_TRUSTED_ORIGINS = [
    'https://realfootballsim.com',
    'https://www.realfootballsim.com'
]


INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'accounts',
    'core',
    'players',
    'clubs',
    'matches',
    'tournaments.apps.TournamentsConfig',
    'django_celery_beat',
    'channels',  # Добавляем channels
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'tournaments.timezone_middleware.TimezoneMiddleware',
]

ROOT_URLCONF = 'realfootballsim.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
                'tournaments.context_processors.timezone_context',
            ],
        },
    },
]

WSGI_APPLICATION = 'realfootballsim.wsgi.application'

# Настройка Channels
ASGI_APPLICATION = 'realfootballsim.asgi.application'

# Default DB (dev) - SQLite для локальной разработки
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
        'ATOMIC_REQUESTS': False,
    }
}

# Если установлен IS_PRODUCTION, используем PostgreSQL
if IS_PRODUCTION == '1':
    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.postgresql',
            'NAME': 'rfsimdb',
            'USER': 'nikos',
            'PASSWORD': '5x9t8zy5',
            'HOST': 'localhost',
            'PORT': '5432',
            'ATOMIC_REQUESTS': False,
        }
    }

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'UTC'

USE_I18N = True
USE_TZ = True

STATIC_URL = '/static/'
STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')
STATICFILES_DIRS = [
    os.path.join(BASE_DIR, 'static'),
]

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

AUTH_USER_MODEL = 'accounts.CustomUser'

LOGIN_REDIRECT_URL = 'clubs:club_detail'
LOGIN_URL = 'accounts:login'
LOGOUT_REDIRECT_URL = 'accounts:login'

# Настройки Celery
CELERY_BROKER_URL = 'redis://localhost:6379/0'
CELERY_RESULT_BACKEND = 'redis://localhost:6379/0'
CELERY_ACCEPT_CONTENT = ['json']
CELERY_TASK_SERIALIZER = 'json'
CELERY_RESULT_SERIALIZER = 'json'
CELERY_TIMEZONE = 'UTC'
CELERY_BROKER_CONNECTION_RETRY_ON_STARTUP = True
CELERY_TASK_TIME_LIMIT = 300
CELERY_TASK_SOFT_TIME_LIMIT = 240

CELERY_WORKER_MAX_TASKS_PER_CHILD = 50
CELERY_WORKER_PREFETCH_MULTIPLIER = 1

# Обновляем расписание задач Celery Beat
CELERY_BEAT_SCHEDULE = {
    'simulate-every-5-seconds': {
        'task': 'tournaments.simulate_active_matches',
        'schedule': 5.0,
    },
    'check-season-end': {
        'task': 'tournaments.check_season_end',
        'schedule': crontab(hour=0, minute=0),
    },
    'start-scheduled-matches-every-minute': {
        'task': 'tournaments.start_scheduled_matches',
        'schedule': crontab(minute='*'),
    },
}

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',
            'style': '{',
        },
    },
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'formatter': 'verbose',
        },
        'file': {
            'class': 'logging.FileHandler',
            'filename': 'debug.log',
            'formatter': 'verbose',
        },
    },
    'loggers': {
        'clubs': {
            'handlers': ['console', 'file'],
            'level': 'DEBUG',
            'propagate': True,
        },
        'matches': {
            'handlers': ['console', 'file'],
            'level': 'DEBUG',
            'propagate': True,
        },
        'tournaments': {
            'handlers': ['console', 'file'],
            'level': 'DEBUG',
            'propagate': True,
        },
    },
}

TOURNAMENT_TIMEZONES = [
    ('UTC', 'UTC'),
    ('Europe/London', 'London'),
    ('Europe/Moscow', 'Moscow'),
    ('America/New_York', 'New York'),
    ('Asia/Tokyo', 'Tokyo'),
]

CHANNEL_LAYERS = {
    "default": {
        "BACKEND": "channels_redis.core.RedisChannelLayer",
        "CONFIG": {
            "hosts": [("127.0.0.1", 6379)],
        },
    },
}

================
File: realfootballsim/urls.py
================
from django.contrib import admin
from django.urls import path, include
from django.conf import settings
from django.conf.urls.static import static
from core.views import home

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', home, name='home'),
    path('accounts/', include(('accounts.urls', 'accounts'), namespace='accounts')),
    path('core/', include('core.urls')),
    path('players/', include(('players.urls', 'players'), namespace='players')),
    path('clubs/', include(('clubs.urls', 'clubs'), namespace='clubs')),
    path('matches/', include(('matches.urls', 'matches'), namespace='matches')),
    path('tournaments/', include(('tournaments.urls', 'tournaments'), namespace='tournaments')),
] + static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)

================
File: realfootballsim/wsgi.py
================
"""
WSGI config for realfootballsim project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'realfootballsim.settings')

application = get_wsgi_application()

================
File: requirements.txt
================
amqp==5.3.1
asgiref==3.8.1
async-timeout==5.0.1
attrs==24.3.0
autobahn==24.4.2
Automat==24.8.1
billiard==4.2.1
celery==5.4.0
cffi==1.17.1
channels==4.2.0
channels_redis==4.2.1
click==8.1.7
click-didyoumean==0.3.1
click-plugins==1.1.1
click-repl==0.3.0
colorama==0.4.6
constantly==23.10.4
cron-descriptor==1.4.5
cryptography==44.0.0
daphne==4.1.2
Django==5.1.4
django-celery-beat==2.7.0
django-countries==7.6.1
django-timezone-field==7.0
Faker==33.1.0
gunicorn==23.0.0
h11==0.14.0
hyperlink==21.0.0
idna==3.10
incremental==24.7.2
kombu==5.4.2
msgpack==1.1.0
numpy==2.2.0
packaging==24.2
prompt_toolkit==3.0.48
psycopg2==2.9.10
pyasn1==0.6.1
pyasn1_modules==0.4.1
pycparser==2.22
pyOpenSSL==24.3.0
python-crontab==3.2.0
python-dateutil==2.9.0.post0
pytz==2024.2
redis==5.2.1
scipy==1.14.1
service-identity==24.2.0
six==1.17.0
sqlparse==0.5.3
tomli==2.2.1
Twisted==24.11.0
txaio==23.1.1
typing_extensions==4.12.2
tzdata==2024.2
uvicorn==0.34.0
vine==5.1.0
wcwidth==0.2.13
zope.interface==7.2

================
File: static/js/team_selection.js
================
// team_selection.js
document.addEventListener('DOMContentLoaded', function() {
    const pitch = document.getElementById('pitch');
    const playerList = document.getElementById('playerList');
    const clubId = document.getElementById('clubId').value;
    const resetButton = document.getElementById('resetButton');
    const saveStatus = document.getElementById('saveStatus');
    const tacticSelect = document.getElementById('tacticSelect');

    // -------------------------------
    // Конфигурация слотов
    // 1) GK (1 слот)
    // 2) Защита (defense): 5 слотов (ldef, rdef, cdef1, cdef2, cdef3)
    // 3) Опорная зона (defensive midfield): 5 слотов (ldm, rdm, cdm1, cdm2, cdm3)
    // 4) Полузащита (midfield): 5 слотов (lm, rm, cm1, cm2, cm3)
    // 5) Атакующая полузащита: 4 слота (lam, ram, cam1, cam2)
    // 6) Форварды (3 центральных): cf1, cf2, cf3

    const positions = [
        // GK (1)
        { top: '8%',  left: '50%',  type: 'goalkeeper', label: 'GK' },

        // Защита (5)
        { top: '18%', left: '20%', type: 'ldef',  label: 'LDEF' },
        { top: '18%', left: '80%', type: 'rdef',  label: 'RDEF' },
        { top: '18%', left: '40%', type: 'cdef1', label: 'CDEF1' },
        { top: '18%', left: '50%', type: 'cdef2', label: 'CDEF2' },
        { top: '18%', left: '60%', type: 'cdef3', label: 'CDEF3' },

        // Опорная зона (5)
        { top: '30%', left: '15%', type: 'ldm',  label: 'LDM' },
        { top: '30%', left: '85%', type: 'rdm',  label: 'RDM' },
        { top: '30%', left: '35%', type: 'cdm1', label: 'CDM1' },
        { top: '30%', left: '50%', type: 'cdm2', label: 'CDM2' },
        { top: '30%', left: '65%', type: 'cdm3', label: 'CDM3' },

        // Обычная полузащита (5)
        { top: '45%', left: '15%', type: 'lm',  label: 'LM' },
        { top: '45%', left: '85%', type: 'rm',  label: 'RM' },
        { top: '45%', left: '35%', type: 'cm1', label: 'CM1' },
        { top: '45%', left: '50%', type: 'cm2', label: 'CM2' },
        { top: '45%', left: '65%', type: 'cm3', label: 'CM3' },

        // Атакующая полузащита (4)
        { top: '60%', left: '20%', type: 'lam',  label: 'LAM' },
        { top: '60%', left: '80%', type: 'ram',  label: 'RAM' },
        { top: '60%', left: '40%', type: 'cam1', label: 'CAM1' },
        { top: '60%', left: '60%', type: 'cam2', label: 'CAM2' },

        // 3 центральных форварда
        { top: '75%', left: '35%', type: 'cf1',  label: 'CF1' },
        { top: '75%', left: '50%', type: 'cf2',  label: 'CF2' },
        { top: '75%', left: '65%', type: 'cf3',  label: 'CF3' }
    ];

    // Создаём слоты
    positions.forEach((pos, index) => {
        const slot = document.createElement('div');
        slot.className = 'player-slot empty';  // изначально пуст
        slot.style.top = pos.top;
        slot.style.left = pos.left;

        slot.dataset.position = String(index);
        slot.dataset.type = pos.type;  // напр. "ldef", "cdm2", "cam1", "cf2"

        const label = document.createElement('div');
        label.className = 'position-label';
        label.textContent = pos.label;
        slot.appendChild(label);

        pitch.appendChild(slot);
    });

    // -------------------------------
    // Определяем базовый тип игрока (goalkeeper, defender, midfielder, forward)
    function getPlayerType(positionString) {
        if (!positionString) return 'other';
        const p = positionString.toLowerCase();
        if (p.includes('goalkeeper')) return 'goalkeeper';
        if (p.includes('back') || p.includes('defender')) return 'defender';
        if (p.includes('midfielder')) return 'midfielder';
        if (p.includes('forward') || p.includes('striker')) return 'forward';
        return 'other';
    }

    // -------------------------------
    // Проверка соответствия slotType -> playerType/position
    // Например, slotType "ldm" требует "Defensive Midfielder"
    function isValidPosition(playerType, slotType, fullPositionName) {
        const pLower = (fullPositionName || '').toLowerCase();

        switch (slotType) {
            case 'goalkeeper':
                return (playerType === 'goalkeeper');

            // --- 5 защитников ---
            case 'ldef':
            case 'rdef':
            case 'cdef1':
            case 'cdef2':
            case 'cdef3':
                return (playerType === 'defender');

            // --- опорная зона ---
            case 'ldm':
            case 'rdm':
            case 'cdm1':
            case 'cdm2':
            case 'cdm3':
                // Нужно наличие "defensive midfielder"
                return pLower.includes('defensive midfielder');

            // --- обычная полузащита ---
            case 'lm':
            case 'rm':
            case 'cm1':
            case 'cm2':
            case 'cm3':
                // Должен быть midfielder, но не "defensive" и не "attacking"
                if (playerType !== 'midfielder') return false;
                if (pLower.includes('defensive midfielder')) return false;
                if (pLower.includes('attacking midfielder')) return false;
                return true;

            // --- атакующая полузащита ---
            case 'lam':
            case 'ram':
            case 'cam1':
            case 'cam2':
                // Нужно именно "attacking midfielder"
                return pLower.includes('attacking midfielder');

            // --- форварды (cf1, cf2, cf3)
            case 'cf1':
            case 'cf2':
            case 'cf3':
                return (playerType === 'forward');

            default:
                return false;
        }
    }

    // -------------------------------
    // Создаём DOM-элемент игрока
    function createPlayerElement(player) {
        const playerElement = document.createElement('div');
        const pt = getPlayerType(player.position);

        playerElement.className = `player-item ${pt}`;
        playerElement.dataset.playerId = String(player.id);
        playerElement.dataset.playerPosition = player.position || '';

        const nameEl = document.createElement('div');
        nameEl.className = 'player-name';
        nameEl.textContent = player.name;

        const posEl = document.createElement('div');
        posEl.className = 'player-position text-muted';
        posEl.textContent = player.position;

        playerElement.appendChild(nameEl);
        playerElement.appendChild(posEl);

        return playerElement;
    }

    // -------------------------------
    // Вывод сообщения
    function showMessage(msg, type = 'success') {
        saveStatus.textContent = msg;
        saveStatus.className = `alert alert-${type} mt-2`;
        setTimeout(() => {
            saveStatus.textContent = '';
            saveStatus.className = '';
        }, 4000);
    }

    // -------------------------------
    // Сохранение состава
    function saveTeamLineup() {
        const lineup = {};
        document.querySelectorAll('.player-slot').forEach(slot => {
            const playerItem = slot.querySelector('.player-item');
            if (playerItem) {
                lineup[slot.dataset.position] = {
                    playerId:       playerItem.dataset.playerId,
                    playerPosition: playerItem.dataset.playerPosition,
                    slotType:       slot.dataset.type,
                    slotLabel:      slot.querySelector('.position-label').textContent
                };
            }
        });

        const tacticVal = tacticSelect ? tacticSelect.value : 'balanced';
        const payload = {
            lineup: lineup,
            tactic: tacticVal
        };

        console.log('Sending lineup payload:', payload);

        fetch(`/clubs/detail/${clubId}/save-team-lineup/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': document.querySelector('input[name="csrfmiddlewaretoken"]').value
            },
            body: JSON.stringify(payload),
            credentials: 'include'
        })
        .then(r => r.json())
        .then(data => {
            if (data.success) {
                showMessage('Lineup saved!');
            } else {
                showMessage(`Error saving lineup: ${data.error || ''}`, 'danger');
            }
        })
        .catch(err => {
            showMessage('Server error', 'danger');
            console.error('Error saving lineup:', err);
        });
    }

    // -------------------------------
    // Загрузка уже сохранённого состава
    function loadTeamLineup() {
        fetch(`/clubs/detail/${clubId}/get-team-lineup/`)
            .then(r => r.json())
            .then(data => {
                if (data.lineup) {
                    Object.entries(data.lineup).forEach(([slotIndex, details]) => {
                        const slot = document.querySelector(`.player-slot[data-position="${slotIndex}"]`);
                        if (!slot || !details) return;
                        const pid = details.playerId;
                        const pElem = document.querySelector(`.player-item[data-player-id="${pid}"]`);
                        if (pElem) {
                            slot.classList.remove('empty');
                            slot.appendChild(pElem);
                        }
                    });
                }
                if (data.tactic) {
                    tacticSelect.value = data.tactic;
                }
            })
            .catch(err => {
                showMessage('Error loading lineup', 'danger');
                console.error('Error loading lineup:', err);
            });
    }

    // -------------------------------
    // Сброс состава
    function resetLineup() {
        document.querySelectorAll('.player-slot .player-item').forEach(pl => {
            playerList.appendChild(pl);
        });
        document.querySelectorAll('.player-slot').forEach(s => {
            s.classList.add('empty');
        });
        saveTeamLineup();
        showMessage('Lineup has been reset');
    }

    if (resetButton) {
        resetButton.addEventListener('click', resetLineup);
    }

    // -------------------------------
    // Инициализация перетаскивания
    function initializeSortable() {
        new Sortable(playerList, {
            group: 'shared',
            animation: 150,
            onStart: function(evt) {
                const pPos = evt.item.dataset.playerPosition || '';
                const pType = getPlayerType(pPos);

                // Подсветим все слоты, куда можно положить
                document.querySelectorAll('.player-slot.empty').forEach(slot => {
                    if (isValidPosition(pType, slot.dataset.type, pPos)) {
                        slot.classList.add('highlight');
                    }
                });
            },
            onEnd: function(evt) {
                document.querySelectorAll('.player-slot').forEach(slot => {
                    slot.classList.remove('highlight');
                    slot.classList.remove('dragover');
                });
                saveTeamLineup();
            }
        });

        document.querySelectorAll('.player-slot').forEach(slot => {
            new Sortable(slot, {
                group: 'shared',
                animation: 150,
                onAdd: function(evt) {
                    const slotEl = evt.to;
                    const newPlayer = evt.item;
                    const pPos = newPlayer.dataset.playerPosition || '';
                    const pType = getPlayerType(pPos);
                    const stype = slotEl.dataset.type;

                    if (isValidPosition(pType, stype, pPos)) {
                        slotEl.classList.remove('empty');
                        slotEl.classList.remove('highlight');

                        slotEl.querySelectorAll('.player-item').forEach(ex => {
                            if (ex !== newPlayer) {
                                playerList.appendChild(ex);
                                slotEl.classList.add('empty');
                            }
                        });

                        slotEl.appendChild(newPlayer);
                        saveTeamLineup();
                    } else {
                        playerList.appendChild(newPlayer);
                        showMessage('Invalid player position!', 'danger');
                    }
                },
                onRemove: function(evt) {
                    const oldSlot = evt.from;
                    oldSlot.classList.add('empty');
                }
            });

            slot.addEventListener('dragenter', function() {
                if (slot.classList.contains('empty') && slot.classList.contains('highlight')) {
                    slot.classList.add('dragover');
                }
            });
            slot.addEventListener('dragleave', function() {
                slot.classList.remove('dragover');
            });
        });
    }

    // -------------------------------
    // 1) Загрузить список игроков,
    // 2) Инициализировать перетаскивание,
    // 3) Загрузить уже сохранённый состав
    fetch(`/clubs/detail/${clubId}/get-players/`)
        .then(r => r.json())
        .then(players => {
            playerList.innerHTML = '';
            players.forEach(pl => {
                const pel = createPlayerElement(pl);
                playerList.appendChild(pel);
            });
            initializeSortable();
            loadTeamLineup();
        })
        .catch(err => {
            showMessage('Error loading players', 'danger');
            console.error('Error loading players:', err);
        });
});

================
File: tournaments/admin.py
================
from django.contrib import admin
from django.core.management import call_command
from django.contrib import messages

from .models import (
    Season,
    League,
    Championship,
    ChampionshipTeam,
    ChampionshipMatch
)


@admin.register(Season)
class SeasonAdmin(admin.ModelAdmin):
    list_display = ('number', 'name', 'start_date', 'end_date', 'is_active')
    list_filter = ('is_active',)
    search_fields = ('name',)
    ordering = ('-start_date',)
    actions = ['end_season', 'force_end_season']

    def end_season(self, request, queryset):
        """Завершает выбранный сезон через management-команду."""
        if queryset.count() > 1:
            messages.error(request, "Can only end one season at a time.")
            return

        season = queryset.first()
        if not season.is_active:
            messages.error(request, "Can only end active season.")
            return

        try:
            call_command('end_season')
            messages.success(request, f"Successfully ended season {season.number}")
        except Exception as e:
            messages.error(request, f"Error ending season: {str(e)}")

    end_season.short_description = "End selected season"

    def force_end_season(self, request, queryset):
        """Принудительно завершает сезон (пропускает валидации)."""
        if queryset.count() > 1:
            messages.error(request, "Can only end one season at a time.")
            return

        season = queryset.first()
        if not season.is_active:
            messages.error(request, "Can only end active season.")
            return

        try:
            call_command('end_season', '--force')
            messages.success(request, f"Successfully force ended season {season.number}")
        except Exception as e:
            messages.error(request, f"Error force ending season: {str(e)}")

    force_end_season.short_description = "Force end selected season (skip validations)"


@admin.register(League)
class LeagueAdmin(admin.ModelAdmin):
    list_display = ('name', 'country', 'level', 'max_teams')
    list_filter = ('country', 'level')
    search_fields = ('name',)
    ordering = ['country', 'level']


class ChampionshipTeamInline(admin.TabularInline):
    model = ChampionshipTeam
    extra = 0
    fields = (
        'team', 'points', 'matches_played',
        'wins', 'draws', 'losses',
        'goals_for', 'goals_against', 'goals_difference'
    )
    readonly_fields = (
        'points', 'matches_played',
        'wins', 'draws', 'losses',
        'goals_for', 'goals_against', 'goals_difference'
    )
    ordering = ('-points', '-goals_for')
    can_delete = False

    def has_add_permission(self, request, obj=None):
        return False


class ChampionshipMatchInline(admin.TabularInline):
    model = ChampionshipMatch
    extra = 0
    show_change_link = True


@admin.register(Championship)
class ChampionshipAdmin(admin.ModelAdmin):
    list_display = (
        'league', 'season', 'status', 'start_date',
        'end_date', 'total_matches', 'finished_matches', 'match_time'
    )
    list_filter = ('status', 'season', 'league')
    search_fields = ('league__name', 'season__name')
    inlines = [ChampionshipTeamInline, ChampionshipMatchInline]

    def get_readonly_fields(self, request, obj=None):
        # Когда статус != 'pending', запрещаем редактировать часть полей.
        if obj and obj.status != 'pending':
            return ['season', 'league', 'start_date']
        return []

    def change_view(self, request, object_id, form_url='', extra_context=None):
        return super().change_view(
            request, object_id, form_url, extra_context=extra_context,
        )

    def total_matches(self, obj):
        return obj.championshipmatch_set.count()

    total_matches.short_description = "Total Matches"

    def finished_matches(self, obj):
        return obj.championshipmatch_set.filter(match__status='finished').count()

    finished_matches.short_description = "Finished Matches"


@admin.register(ChampionshipTeam)
class ChampionshipTeamAdmin(admin.ModelAdmin):
    list_display = (
        'team', 'championship', 'points',
        'matches_played', 'wins', 'draws',
        'losses', 'goals_for', 'goals_against',
        'goals_difference'
    )
    list_filter = ('championship',)
    search_fields = ('team__name', 'championship__league__name')
    readonly_fields = (
        'points', 'matches_played', 'wins',
        'draws', 'losses', 'goals_for',
        'goals_against', 'goals_difference'
    )
    ordering = ('-points', '-goals_for')


@admin.register(ChampionshipMatch)
class ChampionshipMatchAdmin(admin.ModelAdmin):
    list_display = (
        'match', 'championship', 'round',
        'match_day', 'status', 'score'
    )
    list_filter = ('championship', 'round', 'match__status')
    search_fields = ('match__home_team__name', 'match__away_team__name')
    readonly_fields = ('processed',)

    def status(self, obj):
        return obj.match.get_status_display()

    status.short_description = "Status"

    def score(self, obj):
        if obj.match.status == 'finished':
            return f"{obj.match.home_score} - {obj.match.away_score}"
        return "-"

    score.short_description = "Score"

================
File: tournaments/apps.py
================
from django.apps import AppConfig

class TournamentsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'tournaments'
    verbose_name = 'Tournaments Management'

    def ready(self):
        import tournaments.signals

================
File: tournaments/context_processors.py
================
from django.conf import settings

def timezone_context(request):
    return {
        'TOURNAMENT_TIMEZONES': settings.TOURNAMENT_TIMEZONES,
        'user_timezone': request.session.get('django_timezone', 'UTC')
    }

================
File: tournaments/date_utils.py
================
import calendar
from datetime import date
from django.utils import timezone

def get_next_season_dates():
    """
    Вычисляет даты начала и конца следующего сезона.
    Использует реальное количество дней в каждом месяце.
    Возвращает кортеж (start_date, end_date).
    """
    today = timezone.now().date()
    
    # Определяем начало сезона - первое число следующего месяца
    if today.day != 1:
        year = today.year
        month = today.month
        if month == 12:
            month = 1
            year += 1
        else:
            month += 1
        start_date = date(year, month, 1)
    else:
        # Если сегодня 1 число, начинаем сезон сегодня
        start_date = today

    # Определяем последний день месяца используя calendar.monthrange
    _, last_day = calendar.monthrange(start_date.year, start_date.month)
    end_date = start_date.replace(day=last_day)
    
    return start_date, end_date

================
File: tournaments/management/commands/check_matches.py
================
# tournaments/management/commands/check_matches.py
from django.core.management.base import BaseCommand
from django.utils import timezone
from matches.models import Match
from matches.match_simulation import simulate_match
import logging
from datetime import datetime

logger = logging.getLogger('matches')

class Command(BaseCommand):
    help = 'Checks and simulates matches that should start now'

    def add_arguments(self, parser):
        # Добавляем опциональный аргумент для тестирования
        parser.add_argument(
            '--debug',
            action='store_true',
            help='Print additional debug information',
        )

    def handle(self, *args, **options):
        now = timezone.now()
        debug = options['debug']

        if debug:
            self.stdout.write(f'Current time: {now}')
            logger.info(f'Starting match check at {now}')

        # Находим матчи, которые должны были начаться
        matches = Match.objects.filter(
            status='scheduled',
            date__lte=now
        ).select_related('home_team', 'away_team')

        if debug:
            self.stdout.write(f'Found {matches.count()} matches to simulate')
            for match in matches:
                self.stdout.write(
                    f'- {match.date}: {match.home_team} vs {match.away_team}'
                )

        if matches.exists():
            logger.info(f'Found {matches.count()} matches to simulate')
            
            for match in matches:
                try:
                    msg = f'Simulating match: {match.home_team} vs {match.away_team} (scheduled for {match.date})'
                    self.stdout.write(msg)
                    logger.info(msg)
                    
                    simulate_match(match.id)
                    
                    logger.info(
                        f'Match completed: {match.home_team} {match.home_score} - {match.away_score} {match.away_team}'
                    )
                except Exception as e:
                    error_msg = f'Error simulating match {match.id}: {str(e)}'
                    self.stdout.write(self.style.ERROR(error_msg))
                    logger.error(error_msg)

            self.stdout.write(
                self.style.SUCCESS(f'Successfully simulated {matches.count()} matches')
            )
        else:
            if debug:
                self.stdout.write('No matches to simulate')

================
File: tournaments/management/commands/create_new_season.py
================
from django.core.management.base import BaseCommand
from django.db import transaction
from django.utils import timezone
from tournaments.models import Championship, Season, League
from tournaments.utils import create_championship_matches
from datetime import timedelta

class Command(BaseCommand):
    help = 'Creates new season with championships based on current league assignments'

    def add_arguments(self, parser):
        parser.add_argument(
            '--days',
            type=int,
            default=30,
            help='Duration of the season in days'
        )

    def handle(self, *args, **options):
        try:
            with transaction.atomic():
                # Находим последний сезон для определения номера нового
                last_season = Season.objects.order_by('-number').first()
                new_season_number = 1 if not last_season else last_season.number + 1
                
                # Определяем даты сезона
                start_date = timezone.now().date()
                duration = timedelta(days=options['days'])
                end_date = start_date + duration

                # Создаем новый сезон
                new_season = Season.objects.create(
                    number=new_season_number,
                    name=f"Season {new_season_number}",
                    start_date=start_date,
                    end_date=end_date,
                    is_active=True
                )
                
                self.stdout.write(f"Created new season: {new_season}")

                # Получаем все лиги
                leagues = League.objects.all().order_by('country', 'level')
                
                championships_created = 0
                matches_created = 0

                # Создаем чемпионаты для каждой лиги
                for league in leagues:
                    # Проверяем количество команд в лиге
                    teams_in_league = league.clubs.count()
                    if teams_in_league != 16:
                        self.stdout.write(
                            self.style.WARNING(
                                f"Skipping {league}: has {teams_in_league} teams instead of 16"
                            )
                        )
                        continue

                    # Создаем чемпионат
                    championship = Championship.objects.create(
                        season=new_season,
                        league=league,
                        status='pending',
                        start_date=start_date,
                        end_date=end_date
                    )

                    # Добавляем команды в чемпионат
                    for team in league.clubs.all():
                        championship.teams.add(team)

                    # Генерируем расписание матчей
                    create_championship_matches(championship)
                    
                    championships_created += 1
                    matches_created += championship.championshipmatch_set.count()

                    self.stdout.write(
                        f"Created championship for {league.name} with "
                        f"{championship.teams.count()} teams"
                    )

                self.stdout.write(
                    self.style.SUCCESS(
                        f"Successfully created new season {new_season_number} with "
                        f"{championships_created} championships and "
                        f"{matches_created} matches"
                    )
                )

        except Exception as e:
            self.stdout.write(
                self.style.ERROR(f"Error creating new season: {str(e)}")
            )
            raise

================
File: tournaments/management/commands/create_second_division_championships.py
================
from django.core.management.base import BaseCommand
from django.db import transaction
from tournaments.models import League, Championship, Season
from django.utils import timezone

class Command(BaseCommand):
    help = 'Creates championships for second divisions in current season'

    def handle(self, *args, **options):
        try:
            with transaction.atomic():
                # Получаем текущий активный сезон
                current_season = Season.objects.get(is_active=True)
                
                # Получаем все вторые дивизионы
                second_divisions = League.objects.filter(level=2)
                
                championships_created = 0
                for league in second_divisions:
                    # Проверяем, нет ли уже чемпионата для этой лиги в текущем сезоне
                    exists = Championship.objects.filter(
                        season=current_season,
                        league=league
                    ).exists()
                    
                    if not exists:
                        # Создаем чемпионат
                        championship = Championship.objects.create(
                            season=current_season,
                            league=league,
                            status='in_progress',
                            start_date=current_season.start_date,
                            end_date=current_season.end_date,
                            match_time=timezone.now().time().replace(hour=18, minute=0)
                        )
                        
                        # Добавляем все команды лиги в чемпионат
                        for club in league.clubs.all():
                            championship.teams.add(club)
                            
                        championships_created += 1
                        self.stdout.write(f"Created championship for {league.name}")
                
                self.stdout.write(
                    self.style.SUCCESS(
                        f'Successfully created {championships_created} championships'
                    )
                )
                
        except Exception as e:
            self.stdout.write(
                self.style.ERROR(f'Error creating championships: {str(e)}')
            )

================
File: tournaments/management/commands/create_second_divisions.py
================
# tournaments/management/commands/create_second_divisions.py
from django.core.management.base import BaseCommand
from django.db import transaction
from tournaments.models import League
from django_countries import countries

class Command(BaseCommand):
    help = 'Creates second divisions for all countries'

    def handle(self, *args, **options):
        try:
            with transaction.atomic():
                top_leagues = League.objects.filter(level=1)
                
                for league in top_leagues:
                    # Проверяем, нет ли уже второго дивизиона
                    second_div_exists = League.objects.filter(
                        country=league.country,
                        level=2
                    ).exists()
                    
                    if not second_div_exists:
                        League.objects.create(
                            name=f"{league.country.name} Second Division",
                            country=league.country,
                            level=2,
                            max_teams=16,
                            foreign_players_limit=5
                        )
                        self.stdout.write(
                            self.style.SUCCESS(
                                f"Created second division for {league.country.name}"
                            )
                        )
                
                self.stdout.write(self.style.SUCCESS("All second divisions created!"))
                
        except Exception as e:
            self.stdout.write(
                self.style.ERROR(f"Error creating second divisions: {str(e)}")
            )

================
File: tournaments/management/commands/end_season.py
================
from django.core.management.base import BaseCommand
from django.db import transaction
from django.utils import timezone
from tournaments.models import Season, Championship
from django.core.management import call_command
from django.db.models import Count, Q

class Command(BaseCommand):
    help = 'Handles the end of season process'

    def add_arguments(self, parser):
        parser.add_argument(
            '--force',
            action='store_true',
            help='Force end season even if not all matches are finished'
        )

    def handle(self, *args, **options):
        try:
            with transaction.atomic():
                # Получаем текущий активный сезон
                current_season = Season.objects.get(is_active=True)
                
                # Проверяем завершение всех матчей
                championships = Championship.objects.filter(season=current_season)
                
                unfinished_matches = 0
                for championship in championships:
                    unfinished = championship.championshipmatch_set.filter(
                        ~Q(match__status='finished')
                    ).count()
                    unfinished_matches += unfinished
                
                if unfinished_matches > 0 and not options['force']:
                    self.stdout.write(
                        self.style.WARNING(
                            f"Cannot end season: {unfinished_matches} matches not finished. "
                            "Use --force to override."
                        )
                    )
                    return
                
                # Проверяем все чемпионаты на правильное количество команд
                invalid_championships = []
                for championship in championships:
                    team_count = championship.teams.count()
                    if team_count != 16:
                        invalid_championships.append(
                            f"{championship}: {team_count} teams"
                        )
                
                if invalid_championships and not options['force']:
                    self.stdout.write(
                        self.style.WARNING(
                            "Invalid team counts in championships:\n" + 
                            "\n".join(invalid_championships) +
                            "\nUse --force to override."
                        )
                    )
                    return

                # Завершаем текущий сезон
                self.stdout.write("Processing end of season transitions...")
                
                # Обрабатываем переходы между дивизионами
                call_command('handle_season_transitions')
                
                # Деактивируем текущий сезон
                current_season.is_active = False
                current_season.save()
                
                # Создаем новый сезон
                self.stdout.write("Creating new season...")
                call_command('create_new_season')
                
                self.stdout.write(
                    self.style.SUCCESS(
                        f"Successfully ended season {current_season.number}"
                    )
                )

        except Season.DoesNotExist:
            self.stdout.write(
                self.style.ERROR("No active season found")
            )
        except Exception as e:
            self.stdout.write(
                self.style.ERROR(f"Error ending season: {str(e)}")
            )
            raise

    def validate_championship_results(self, championship):
        """
        Проверяет корректность результатов чемпионата
        """
        # Проверяем количество сыгранных матчей для каждой команды
        team_stats = championship.championshipteam_set.all()
        total_teams = team_stats.count()
        expected_matches = (total_teams - 1) * 2  # Каждая команда играет со всеми дважды
        
        for stats in team_stats:
            if stats.matches_played != expected_matches:
                return False, f"Team {stats.team.name} played {stats.matches_played} matches instead of {expected_matches}"
        
        return True, None

================
File: tournaments/management/commands/generate_all_matches.py
================
from django.core.management.base import BaseCommand
from django.db import transaction
from tournaments.models import Championship
from tournaments.utils import create_championship_matches
import logging

logger = logging.getLogger(__name__)

class Command(BaseCommand):
    help = 'Generates matches for all divisions'

    def handle(self, *args, **options):
        try:
            with transaction.atomic():
                # Получаем все активные чемпионаты
                championships = Championship.objects.filter(
                    status='in_progress'
                ).select_related('league')
                
                total_matches = 0
                for championship in championships:
                    self.stdout.write(
                        f"Generating matches for {championship} "
                        f"(Division {championship.league.level})"
                    )
                    create_championship_matches(championship)
                    matches_count = championship.championshipmatch_set.count()
                    total_matches += matches_count
                    self.stdout.write(
                        f"Created {matches_count} matches for "
                        f"{championship.league.name} (Division {championship.league.level})"
                    )
                    
                self.stdout.write(
                    self.style.SUCCESS(
                        f'Successfully generated {total_matches} matches '
                        f'for {championships.count()} championships'
                    )
                )
                
        except Exception as e:
            self.stdout.write(
                self.style.ERROR(f'Error generating matches: {str(e)}')
            )
            logger.error(f"Error generating matches: {str(e)}")

================
File: tournaments/management/commands/generate_championships.py
================
from django.core.management.base import BaseCommand
from django.db import transaction
from django_countries import countries
from faker import Faker
from tournaments.models import League, Championship, Season
from clubs.models import Club
from tqdm import tqdm
import sys
import random  # Добавляем импорт random

class Command(BaseCommand):
    help = 'Generates championships for all countries with bot teams'

    def __init__(self):
        super().__init__()
        self.fake = Faker()
        self.team_adjectives = [
            'Red', 'Blue', 'Golden', 'Silver', 'Black', 'White', 'Royal',
            'Imperial', 'Northern', 'United', 'Real', 'Crystal', 'Athletic',
            'Sporting', 'Racing', 'Phoenix', 'Elite', 'Supreme', 'Ancient',
            'Mighty', 'Green', 'Purple', 'Bronze', 'Iron', 'Steel', 
            'Eastern', 'Western', 'Southern', 'Central', 'Inter',
            'Dynamic', 'Olympic', 'Spartak', 'Victoria', 'Glory',
            'Freedom', 'Unity', 'Progressive', 'Classic', 'Modern'
        ]
        self.team_nouns = [
            'Lions', 'Eagles', 'Dragons', 'Warriors', 'Knights', 'Rovers',
            'Rangers', 'Wanderers', 'Stars', 'Kings', 'Legends', 'Phoenix',
            'Tigers', 'Panthers', 'Wolves', 'Falcons', 'Titans', 'Giants',
            'Heroes', 'Guardians', 'Hawks', 'Bears', 'Sharks', 'Vipers',
            'Scorpions', 'Pythons', 'Cobras', 'Stallions', 'Bulls', 'Raiders',
            'Hunters', 'Hornets', 'Ravens', 'Demons', 'Angels', 'Thunder',
            'Lightning', 'Storm', 'United', 'City'
        ]
        self.team_suffixes = ['FC', 'United', 'City', 'Athletic', 'Sporting']
        self.stats = {
            'leagues_created': 0,
            'championships_created': 0,
            'teams_created': 0,
            'countries_processed': 0
        }

    def generate_team_name(self):
        """Generates a unique random team name with more variations"""
        attempts = 0
        max_attempts = 100
        while attempts < max_attempts:
            # 70% chance of standard name (Adjective + Noun)
            # 30% chance of name with suffix (Adjective + Noun + Suffix)
            if random.random() < 0.7:
                adj = self.fake.random_element(self.team_adjectives)
                noun = self.fake.random_element(self.team_nouns)
                name = f"{adj} {noun}"
            else:
                adj = self.fake.random_element(self.team_adjectives)
                noun = self.fake.random_element(self.team_nouns)
                suffix = self.fake.random_element(self.team_suffixes)
                name = f"{adj} {noun} {suffix}"

            if not Club.objects.filter(name=name).exists():
                return name
            attempts += 1
        raise Exception(f"Could not generate unique team name after {max_attempts} attempts")

    def add_arguments(self, parser):
        parser.add_argument(
            '--start-from',
            type=str,
            help='Start from specific country code (e.g., "FR" for France)',
        )
        parser.add_argument(
            '--force',
            action='store_true',
            help='Force recreation of championships even if they exist',
        )

    def handle(self, *args, **options):
        self.stdout.write('Starting championship generation process...')
        
        # Безопасная обработка start_from
        start_from = (options.get('start_from') or '').upper()
        force = options.get('force', False)

        # Предварительная проверка
        existing_leagues = League.objects.count()
        existing_championships = Championship.objects.count()
        existing_clubs = Club.objects.count()

        self.stdout.write(f'Current state:')
        self.stdout.write(f'- Existing leagues: {existing_leagues}')
        self.stdout.write(f'- Existing championships: {existing_championships}')
        self.stdout.write(f'- Existing clubs: {existing_clubs}')
        
        try:
            with transaction.atomic():
                # Create active season if not exists
                season, created = Season.objects.get_or_create(
                    name="2024/2025",
                    defaults={
                        'start_date': '2024-08-01',
                        'end_date': '2025-05-31',
                        'is_active': True
                    }
                )
                
                if created:
                    self.stdout.write(self.style.SUCCESS(f'Created new season: {season.name}'))
                else:
                    self.stdout.write(f'Using existing season: {season.name}')

                # Get list of countries and filter if needed
                country_list = list(countries)
                if start_from:
                    try:
                        start_index = next(i for i, (code, _) in enumerate(country_list) 
                                         if code == start_from)
                        country_list = country_list[start_index:]
                        self.stdout.write(f'Starting from country: {start_from}')
                    except StopIteration:
                        self.stdout.write(
                            self.style.WARNING(f'Country code {start_from} not found, starting from beginning')
                        )

                self.stdout.write(f'Processing {len(country_list)} countries...')

                with tqdm(total=len(country_list), desc="Processing countries") as pbar:
                    for country_code, country_name in country_list:
                        try:
                            # Check if league exists
                            league = League.objects.filter(
                                country=country_code,
                                level=1
                            ).first()

                            if not league:
                                league = League.objects.create(
                                    country=country_code,
                                    level=1,
                                    name=f"{country_name} Premier League",
                                    max_teams=16,
                                    foreign_players_limit=5
                                )
                                self.stats['leagues_created'] += 1

                            # Check if championship exists
                            championship = Championship.objects.filter(
                                season=season,
                                league=league
                            ).first()

                            if not championship or force:
                                if force and championship:
                                    championship.delete()
                                
                                championship = Championship.objects.create(
                                    season=season,
                                    league=league,
                                    status='pending',
                                    start_date=season.start_date,
                                    end_date=season.end_date
                                )
                                self.stats['championships_created'] += 1

                                # Create teams
                                for i in range(16):
                                    team_name = self.generate_team_name()
                                    team = Club.objects.create(
                                        name=team_name,
                                        country=country_code,
                                        is_bot=True,
                                        owner=None
                                    )
                                    championship.teams.add(team)
                                    self.stats['teams_created'] += 1

                            self.stats['countries_processed'] += 1

                        except Exception as e:
                            self.stdout.write(
                                self.style.ERROR(f'Error processing {country_name}: {str(e)}')
                            )
                            continue
                        finally:
                            pbar.update(1)

                # Print final statistics
                self.stdout.write(self.style.SUCCESS('\nGeneration completed successfully!'))
                self.stdout.write(f"Countries processed: {self.stats['countries_processed']}")
                self.stdout.write(f"Leagues created: {self.stats['leagues_created']}")
                self.stdout.write(f"Championships created: {self.stats['championships_created']}")
                self.stdout.write(f"Teams created: {self.stats['teams_created']}")
                
        except KeyboardInterrupt:
            self.stdout.write(self.style.WARNING('\nProcess interrupted by user'))
            self.stdout.write(f"Countries processed: {self.stats['countries_processed']}")
            self.stdout.write(f"Leagues created: {self.stats['leagues_created']}")
            self.stdout.write(f"Championships created: {self.stats['championships_created']}")
            self.stdout.write(f"Teams created: {self.stats['teams_created']}")
            sys.exit(1)
            
        except Exception as e:
            self.stdout.write(
                self.style.ERROR(f'\nError during championship generation: {str(e)}')
            )
            raise e

================
File: tournaments/management/commands/generate_players_for_all_teams.py
================
from django.core.management.base import BaseCommand
from django.db import transaction
from clubs.models import Club
from players.models import Player
from faker import Faker
from players.utils import generate_player_stats
import random

class Command(BaseCommand):
    help = 'Generates players for all teams'

    def handle(self, *args, **options):
        try:
            with transaction.atomic():
                clubs = Club.objects.all()
                
                for club in clubs:
                    self.stdout.write(f"Generating players for {club.name}...")
                    
                    # Создаем Faker для соответствующей страны
                    fake = Faker(['en_GB'])
                    
                    # Позиции игроков
                    positions = [
                        "Goalkeeper",
                        "Right Back",
                        "Center Back",
                        "Left Back",
                        "Defensive Midfielder",
                        "Central Midfielder",
                        "Attacking Midfielder",
                        "Right Midfielder",
                        "Left Midfielder",
                        "Center Forward"
                    ]
                    
                    # Создаем минимум 25 игроков для каждой команды
                    # Обязательно создаем вратаря
                    self.create_player(club, "Goalkeeper", fake)
                    
                    # Создаем остальных игроков
                    for _ in range(24):
                        position = random.choice(positions)
                        self.create_player(club, position, fake)
                    
                    self.stdout.write(f"Created 25 players for {club.name}")
                
                self.stdout.write(self.style.SUCCESS("All teams populated with players!"))
                
        except Exception as e:
            self.stdout.write(
                self.style.ERROR(f"Error generating players: {str(e)}")
            )
    
    def create_player(self, club, position, fake):
        """Создает одного игрока"""
        # Генерируем уникальное имя
        while True:
            first_name = fake.first_name_male()
            last_name = fake.last_name_male()
            if not Player.objects.filter(first_name=first_name, last_name=last_name).exists():
                break
        
        # Генерируем характеристики
        stats = generate_player_stats(position, random.randint(1, 4))
        
        if position == 'Goalkeeper':
            Player.objects.create(
                club=club,
                first_name=first_name,
                last_name=last_name,
                nationality=club.country,
                age=random.randint(17, 35),
                position=position,
                player_class=random.randint(1, 4),
                strength=stats['strength'],
                stamina=stats['stamina'],
                pace=stats['pace'],
                positioning=stats['positioning'],
                reflexes=stats['reflexes'],
                handling=stats['handling'],
                aerial=stats['aerial'],
                jumping=stats['jumping'],
                command=stats['command'],
                throwing=stats['throwing'],
                kicking=stats['kicking']
            )
        else:
            Player.objects.create(
                club=club,
                first_name=first_name,
                last_name=last_name,
                nationality=club.country,
                age=random.randint(17, 35),
                position=position,
                player_class=random.randint(1, 4),
                strength=stats['strength'],
                stamina=stats['stamina'],
                pace=stats['pace'],
                marking=stats['marking'],
                tackling=stats['tackling'],
                work_rate=stats['work_rate'],
                positioning=stats['positioning'],
                passing=stats['passing'],
                crossing=stats['crossing'],
                dribbling=stats['dribbling'],
                ball_control=stats['ball_control'],
                heading=stats['heading'],
                finishing=stats['finishing'],
                long_range=stats['long_range'],
                vision=stats['vision']
            )

================
File: tournaments/management/commands/generate_schedule.py
================
from django.core.management.base import BaseCommand
from django.db import transaction
from tournaments.models import Championship
from tournaments.utils import create_championship_matches, validate_championship_schedule
from django.utils import timezone

class Command(BaseCommand):
    help = 'Generates match schedule for championships'

    def add_arguments(self, parser):
        parser.add_argument(
            '--championship',
            type=int,
            help='ID конкретного чемпионата (если не указан, генерируется для всех активных)'
        )

    def handle(self, *args, **options):
        try:
            with transaction.atomic():
                if options['championship']:
                    championships = Championship.objects.filter(
                        id=options['championship'],
                        status='pending'
                    )
                else:
                    championships = Championship.objects.filter(
                        season__is_active=True,
                        status='pending'
                    )

                if not championships:
                    self.stdout.write(
                        self.style.WARNING('Нет чемпионатов для генерации расписания')
                    )
                    return

                for championship in championships:
                    try:
                        self.stdout.write(
                            f'Генерация расписания для {championship}...'
                        )
                        
                        create_championship_matches(championship)
                        
                        if validate_championship_schedule(championship):
                            championship.status = 'in_progress'
                            championship.save()
                            
                            self.stdout.write(
                                self.style.SUCCESS(
                                    f'Успешно сгенерировано расписание для {championship}'
                                )
                            )
                        else:
                            raise ValueError(
                                f'Ошибка валидации расписания для {championship}'
                            )
                            
                    except Exception as e:
                        self.stdout.write(
                            self.style.ERROR(f'Ошибка для {championship}: {str(e)}')
                        )
                        raise

        except Exception as e:
            self.stdout.write(
                self.style.ERROR(f'Ошибка генерации расписания: {str(e)}')
            )

================
File: tournaments/management/commands/handle_season_transitions.py
================
from django.core.management.base import BaseCommand
from django.db import transaction
from tournaments.models import Championship, Season, League
from django.db.models import F
from django.core.exceptions import ValidationError

class Command(BaseCommand):
    help = 'Process end of season transitions between divisions'

    def add_arguments(self, parser):
        parser.add_argument(
            '--season',
            type=int,
            help='Season number to process (defaults to active season)'
        )

    def handle(self, *args, **options):
        try:
            with transaction.atomic():
                # Получаем сезон для обработки
                season_number = options.get('season')
                if season_number:
                    season = Season.objects.get(number=season_number)
                else:
                    season = Season.objects.get(is_active=True)

                self.stdout.write(f"Processing end of season transitions for {season}")

                # Получаем все чемпионаты текущего сезона
                championships = Championship.objects.filter(
                    season=season
                ).select_related('league')

                # Группируем чемпионаты по странам
                countries = {}
                for champ in championships:
                    country_code = champ.league.country.code
                    if country_code not in countries:
                        countries[country_code] = {'div1': None, 'div2': None}
                    
                    if champ.league.level == 1:
                        countries[country_code]['div1'] = champ
                    elif champ.league.level == 2:
                        countries[country_code]['div2'] = champ

                # Обрабатываем каждую страну
                for country_code, divisions in countries.items():
                    if not divisions['div1'] or not divisions['div2']:
                        self.stdout.write(
                            self.style.WARNING(
                                f"Skipping {country_code} - missing division"
                            )
                        )
                        continue

                    self.process_country_transitions(
                        divisions['div1'], 
                        divisions['div2']
                    )

        except Season.DoesNotExist:
            self.stdout.write(
                self.style.ERROR("No active season found!")
            )
        except Exception as e:
            self.stdout.write(
                self.style.ERROR(f"Error during transitions: {str(e)}")
            )
            raise

    def process_country_transitions(self, div1_championship, div2_championship):
        """
        Обработка переходов между дивизионами для одной страны
        """
        country_name = div1_championship.league.country.name
        self.stdout.write(f"\nProcessing {country_name}:")

        try:
            # Получаем команды для понижения (2 последние из первого дивизиона)
            relegated_teams = (
                div1_championship.championshipteam_set
                .annotate(
                    goals_diff=F('goals_for') - F('goals_against')
                )
                .order_by(
                    'points',
                    'goals_diff',
                    'goals_for'
                )[:2]
            )

            # Получаем команды для повышения (2 первые из второго дивизиона)
            promoted_teams = (
                div2_championship.championshipteam_set
                .annotate(
                    goals_diff=F('goals_for') - F('goals_against')
                )
                .order_by(
                    '-points',
                    '-goals_diff',
                    '-goals_for'
                )[:2]
            )

            # Применяем переходы
            div2_league = div2_championship.league
            div1_league = div1_championship.league

            # Понижаем команды
            for team_stats in relegated_teams:
                team = team_stats.team
                team.league = div2_league
                team.save()
                self.stdout.write(
                    f"  Relegated: {team.name} "
                    f"(Points: {team_stats.points}, "
                    f"GD: {team_stats.goals_diff})"
                )

            # Повышаем команды
            for team_stats in promoted_teams:
                team = team_stats.team
                team.league = div1_league
                team.save()
                self.stdout.write(
                    f"  Promoted: {team.name} "
                    f"(Points: {team_stats.points}, "
                    f"GD: {team_stats.goals_diff})"
                )

        except Exception as e:
            raise ValidationError(
                f"Error processing transitions for {country_name}: {str(e)}"
            )

================
File: tournaments/management/commands/initialize_football_world.py
================
from django.core.management.base import BaseCommand
from django.db import transaction
from django.utils import timezone
from tournaments.models import League, Championship, Season
from clubs.models import Club
from players.models import Player
from players.utils import generate_player_stats
from faker import Faker
import random
from datetime import datetime, timedelta
import logging

logger = logging.getLogger(__name__)

class Command(BaseCommand):
    help = 'Initialize complete football world with leagues, teams, and players'

    def __init__(self):
        super().__init__()
        self.TOP_LEAGUES = [
            {
                'country': 'GB',
                'div1_name': 'Premier League',
                'div2_name': 'Championship'
            },
            {
                'country': 'ES',
                'div1_name': 'La Liga',
                'div2_name': 'La Liga 2'
            },
            {
                'country': 'IT',
                'div1_name': 'Serie A',
                'div2_name': 'Serie B'
            },
            {
                'country': 'DE',
                'div1_name': 'Bundesliga',
                'div2_name': '2. Bundesliga'
            },
            {
                'country': 'FR',
                'div1_name': 'Ligue 1',
                'div2_name': 'Ligue 2'
            },
            {
                'country': 'PT',
                'div1_name': 'Primeira Liga',
                'div2_name': 'Liga Portugal 2'
            },
            {
                'country': 'GR',
                'div1_name': 'Super League',
                'div2_name': 'Super League 2'
            },
            {
                'country': 'RU',
                'div1_name': 'Premier League',
                'div2_name': 'First League'
            },
            {
                'country': 'AR',
                'div1_name': 'Primera División',
                'div2_name': 'Primera Nacional'
            },
            {
                'country': 'BR',
                'div1_name': 'Série A',
                'div2_name': 'Série B'
            }
        ]

        self.team_names = [
            'United', 'City', 'Athletic', 'Rovers', 'Wanderers',
            'Rangers', 'Dynamo', 'Sporting', 'Real', 'Inter',
            'Academy', 'Warriors', 'Legion', 'Phoenix', 'Union'
        ]
        self.team_suffixes = ['FC', 'CF', 'SC', 'AF']

        # Определяем структуру команды
        self.team_structure = {
            "Goalkeeper": {"count": 3, "class_distribution": [1, 2, 3]},
            "Right Back": {"count": 2, "class_distribution": [2, 3]},
            "Center Back": {"count": 4, "class_distribution": [1, 2, 3, 4]},
            "Left Back": {"count": 2, "class_distribution": [2, 3]},
            "Defensive Midfielder": {"count": 2, "class_distribution": [2, 3]},
            "Central Midfielder": {"count": 3, "class_distribution": [1, 2, 3]},
            "Attacking Midfielder": {"count": 2, "class_distribution": [2, 3]},
            "Right Midfielder": {"count": 2, "class_distribution": [2, 3]},
            "Left Midfielder": {"count": 2, "class_distribution": [2, 3]},
            "Center Forward": {"count": 3, "class_distribution": [1, 2, 3]}
        }

        # В каждой команде может быть максимум 30 игроков
        self.max_players_per_club = 30

    def generate_team_name(self, fake):
        """
        Генерирует уникальное название команды.
        """
        attempts = 0
        while attempts < 100:
            city = fake.city()
            variant = random.choice([
                f"{city} {random.choice(self.team_names)}",
                f"{random.choice(self.team_names)} {city}",
                f"{city} {random.choice(self.team_suffixes)}"
            ])
            if not Club.objects.filter(name=variant).exists():
                return variant
            attempts += 1
        raise Exception("Не удалось создать уникальное имя команды")

    def create_league_structure(self):
        """
        Создает 2 дивизиона на каждую из TOP_LEAGUES.
        """
        self.stdout.write("Creating league structure...")
        try:
            for league_info in self.TOP_LEAGUES:
                # Первый дивизион
                League.objects.create(
                    name=f"{league_info['country']} {league_info['div1_name']}",
                    country=league_info['country'],
                    level=1,
                    max_teams=16,
                    foreign_players_limit=5
                )
                # Второй дивизион
                League.objects.create(
                    name=f"{league_info['country']} {league_info['div2_name']}",
                    country=league_info['country'],
                    level=2,
                    max_teams=16,
                    foreign_players_limit=5
                )
            self.stdout.write(self.style.SUCCESS(
                f"Created {len(self.TOP_LEAGUES) * 2} leagues"
            ))
            return True
        except Exception as e:
            self.stdout.write(self.style.ERROR(f"Error creating leagues: {str(e)}"))
            return False

    def create_teams(self):
        """
        Создаёт 16 команд (is_bot=True) в каждой лиге, генерируя уникальные названия.
        """
        self.stdout.write("Creating teams...")
        try:
            for league in League.objects.all():
                fake = Faker(['en_GB'])
                for _ in range(16):
                    team_name = self.generate_team_name(fake)
                    Club.objects.create(
                        name=team_name,
                        country=league.country,
                        league=league,
                        is_bot=True
                    )
                self.stdout.write(f"Created 16 teams for {league.name}")
            return True
        except Exception as e:
            self.stdout.write(self.style.ERROR(f"Error creating teams: {str(e)}"))
            return False

    def create_player(self, club, position, fake, player_class):
        """
        Создает одного игрока (с уникальным ФИО) нужного класса и позиции.
        """
        # Генерируем уникальное ФИО
        while True:
            first_name = fake.first_name_male()
            last_name = fake.last_name_male()
            if not Player.objects.filter(first_name=first_name, last_name=last_name).exists():
                break

        stats = generate_player_stats(position, player_class)

        base_stats = {
            'club': club,
            'first_name': first_name,
            'last_name': last_name,
            'nationality': club.country,
            'age': random.randint(17, 35),
            'position': position,
            'player_class': player_class,
            'strength': stats['strength'],
            'stamina': stats['stamina'],
            'pace': stats['pace'],
            'positioning': stats['positioning'],
        }

        if position == 'Goalkeeper':
            # Доп. характеристики вратаря
            gk_stats = {
                'reflexes': stats['reflexes'],
                'handling': stats['handling'],
                'aerial': stats['aerial'],
                'command': stats['command'],
                'distribution': stats['distribution'],
                'one_on_one': stats['one_on_one'],
                'rebound_control': stats['rebound_control'],
                'shot_reading': stats['shot_reading']
            }
            player_stats = {**base_stats, **gk_stats}
        else:
            # Полевые игроки
            field_stats = {
                'marking': stats['marking'],
                'tackling': stats['tackling'],
                'work_rate': stats['work_rate'],
                'passing': stats['passing'],
                'crossing': stats['crossing'],
                'dribbling': stats['dribbling'],
                'flair': stats['flair'],
                'heading': stats['heading'],
                'finishing': stats['finishing'],
                'long_range': stats['long_range'],
                'vision': stats['vision'],
                'accuracy': stats['accuracy']
            }
            player_stats = {**base_stats, **field_stats}

        return Player.objects.create(**player_stats)

    def create_players(self):
        """
        Создаёт игроков для ботов-команд не больше 30 в каждом клубе.
        """
        self.stdout.write("Creating players...")
        try:
            for club in Club.objects.all():
                fake = Faker(['en_GB'])
                players_created = 0
                existing_count = Player.objects.filter(club=club).count()

                # Если уже 30 или больше игроков, пропускаем
                if existing_count >= self.max_players_per_club:
                    self.stdout.write(
                        f"Skipping {club.name} - already has {existing_count} players"
                    )
                    continue

                # Создаем игроков согласно team_structure
                for position, details in self.team_structure.items():
                    if existing_count >= self.max_players_per_club:
                        break

                    count = min(details["count"], self.max_players_per_club - existing_count)
                    class_distribution = details["class_distribution"]

                    for i in range(count):
                        player_class = class_distribution[i % len(class_distribution)]
                        self.create_player(club, position, fake, player_class)
                        players_created += 1
                        existing_count += 1

                        if existing_count >= self.max_players_per_club:
                            break

                self.stdout.write(f"Created {players_created} players for {club.name}")
            return True
        except Exception as e:
            self.stdout.write(self.style.ERROR(f"Error creating players: {str(e)}"))
            return False

    def create_season_and_championships(self):
        """
        Создает 1 сезон (Season 1) и чемпионаты для каждой лиги, 
        устанавливая статус in_progress.
        """
        self.stdout.write("Creating season and championships...")
        try:
            # Чтобы end_date > start_date, поменяем год end_date на 2025
            season = Season.objects.create(
                name="Season 1",
                number=1,
                start_date=datetime(2025, 1, 1).date(),
                end_date=datetime(2025, 1, 31).date(),
                is_active=True
            )

            for league in League.objects.all():
                championship = Championship.objects.create(
                    season=season,
                    league=league,
                    status='in_progress',
                    start_date=season.start_date,
                    end_date=season.end_date,
                    match_time=timezone.now().time().replace(hour=18, minute=0)
                )
                # Добавляем все клубы этой лиги в teams
                teams = Club.objects.filter(league=league)
                for team in teams:
                    championship.teams.add(team)

                self.stdout.write(f"Created championship for {league.name}")
            return True
        except Exception as e:
            self.stdout.write(self.style.ERROR(f"Error creating season and championships: {str(e)}"))
            return False

    def handle(self, *args, **options):
        self.stdout.write("Starting football world initialization...")

        # 1) Создание лиг
        if not self.create_league_structure():
            return

        # 2) Создание команд
        if not self.create_teams():
            return

        # 3) Создание игроков
        if not self.create_players():
            return

        # 4) Сезон + чемпионаты
        if not self.create_season_and_championships():
            return

        # 5) Генерация матчей
        try:
            from django.core.management import call_command
            call_command('generate_all_matches')
            self.stdout.write(self.style.SUCCESS("Football world initialization completed!"))
        except Exception as e:
            self.stdout.write(self.style.ERROR(f'Error generating matches: {str(e)}'))

================
File: tournaments/management/commands/initialize_top_leagues.py
================
from django.core.management.base import BaseCommand
from django.db import transaction
from tournaments.models import League

class Command(BaseCommand):
    help = 'Initialize leagues for top 10 football countries'

    def handle(self, *args, **options):
        # Топ-10 футбольных стран
        TOP_LEAGUES = [
            {
                'country': 'GB',
                'div1_name': 'Premier League',
                'div2_name': 'Championship'
            },
            {
                'country': 'ES',
                'div1_name': 'La Liga',
                'div2_name': 'La Liga 2'
            },
            {
                'country': 'IT',
                'div1_name': 'Serie A',
                'div2_name': 'Serie B'
            },
            {
                'country': 'DE',
                'div1_name': 'Bundesliga',
                'div2_name': '2. Bundesliga'
            },
            {
                'country': 'FR',
                'div1_name': 'Ligue 1',
                'div2_name': 'Ligue 2'
            },
            {
                'country': 'PT',
                'div1_name': 'Primeira Liga',
                'div2_name': 'Liga Portugal 2'
            },
            {
                'country': 'GR',
                'div1_name': 'Super League',
                'div2_name': 'Super League 2'
            },
            {
                'country': 'RU',
                'div1_name': 'Premier League',
                'div2_name': 'First League'
            },
            {
                'country': 'AR',
                'div1_name': 'Primera División',
                'div2_name': 'Primera Nacional'
            },
            {
                'country': 'BR',
                'div1_name': 'Série A',
                'div2_name': 'Série B'
            },
        ]

        try:
            with transaction.atomic():
                # Удаляем все существующие лиги
                League.objects.all().delete()
                
                for league_info in TOP_LEAGUES:
                    # Создаем первый дивизион
                    League.objects.create(
                        name=f"{league_info['country']} {league_info['div1_name']}", # добавляем страну в название
                        country=league_info['country'],
                        level=1,
                        max_teams=16,
                        foreign_players_limit=5
                    )
                    self.stdout.write(
                        f"Created {league_info['div1_name']} for {league_info['country']}"
                    )
                    
                    # Создаем второй дивизион
                    League.objects.create(
                        name=f"{league_info['country']} {league_info['div2_name']}", # добавляем страну в название
                        country=league_info['country'],
                        level=2,
                        max_teams=16,
                        foreign_players_limit=5
                    )
                    self.stdout.write(
                        f"Created {league_info['div2_name']} for {league_info['country']}"
                    )

                self.stdout.write(
                    self.style.SUCCESS(
                        f'Successfully created leagues for {len(TOP_LEAGUES)} countries'
                    )
                )
                
        except Exception as e:
            self.stdout.write(
                self.style.ERROR(f'Error creating leagues: {str(e)}')
            )

================
File: tournaments/management/commands/populate_first_divisions.py
================
from django.core.management.base import BaseCommand
from django.db import transaction
from tournaments.models import League
from clubs.models import Club
from faker import Faker
import random

class Command(BaseCommand):
    help = 'Populates first divisions with bot teams'

    def __init__(self):
        super().__init__()
        self.team_adjectives = [
            'United', 'City', 'Athletic', 'Rovers', 'Wanderers', 
            'Rangers', 'Dynamo', 'Sporting', 'Real', 'Inter',
            'Academy', 'Warriors', 'Legion', 'Phoenix', 'Union'
        ]
        self.team_suffixes = ['FC', 'CF', 'SC', 'AF']

    def generate_team_name(self, fake):
        """Генерирует уникальное название команды"""
        attempts = 0
        while attempts < 100:
            city = fake.city()
            variant = random.choice([
                f"{city} {random.choice(self.team_adjectives)}",
                f"{random.choice(self.team_adjectives)} {city}",
                f"{city} {random.choice(self.team_suffixes)}"
            ])
            if not Club.objects.filter(name=variant).exists():
                return variant
            attempts += 1
        raise Exception("Не удалось создать уникальное имя команды")

    def handle(self, *args, **options):
        try:
            with transaction.atomic():
                # Получаем все первые дивизионы
                first_divisions = League.objects.filter(level=1)
                
                for league in first_divisions:
                    self.stdout.write(f"Populating {league.name}...")
                    
                    # Проверяем, сколько команд уже есть
                    existing_teams = Club.objects.filter(league=league).count()
                    if existing_teams >= 16:
                        self.stdout.write(f"League {league.name} already has {existing_teams} teams")
                        continue
                    
                    # Создаем Faker для соответствующей страны
                    fake = Faker(['en_GB'])  # Можно добавить больше локалей
                    
                    # Добавляем команды до 16
                    teams_to_create = 16 - existing_teams
                    for _ in range(teams_to_create):
                        team_name = self.generate_team_name(fake)
                        Club.objects.create(
                            name=team_name,
                            country=league.country,
                            league=league,
                            is_bot=True
                        )
                        self.stdout.write(f"Created team: {team_name}")
                    
                    self.stdout.write(
                        self.style.SUCCESS(
                            f"Successfully populated {league.name} with {teams_to_create} teams"
                        )
                    )
                
                self.stdout.write(self.style.SUCCESS("All first divisions populated!"))
                
        except Exception as e:
            self.stdout.write(
                self.style.ERROR(f"Error populating first divisions: {str(e)}")
            )

================
File: tournaments/management/commands/populate_second_divisions.py
================
from django.core.management.base import BaseCommand
from django.db import transaction
from tournaments.models import League
from clubs.models import Club
from faker import Faker
import random

class Command(BaseCommand):
    help = 'Populates second divisions with bot teams'

    def __init__(self):
        super().__init__()
        self.team_adjectives = [
            'United', 'City', 'Athletic', 'Rovers', 'Wanderers', 
            'Rangers', 'Dynamo', 'Sporting', 'Real', 'Inter',
            'Academy', 'Warriors', 'Legion', 'Phoenix', 'Union'
        ]
        self.team_suffixes = ['FC', 'CF', 'SC', 'AF']

    def generate_team_name(self, fake):
        """Генерирует уникальное название команды"""
        attempts = 0
        while attempts < 100:
            city = fake.city()
            variant = random.choice([
                f"{city} {random.choice(self.team_adjectives)}",
                f"{random.choice(self.team_adjectives)} {city}",
                f"{city} {random.choice(self.team_suffixes)}"
            ])
            if not Club.objects.filter(name=variant).exists():
                return variant
            attempts += 1
        raise Exception("Не удалось создать уникальное имя команды")

    def handle(self, *args, **options):
        try:
            with transaction.atomic():
                # Получаем все вторые дивизионы
                second_divisions = League.objects.filter(level=2)
                
                for league in second_divisions:
                    self.stdout.write(f"Populating {league.name}...")
                    
                    # Проверяем, сколько команд уже есть
                    existing_teams = Club.objects.filter(league=league).count()
                    if existing_teams >= 16:
                        self.stdout.write(f"League {league.name} already has {existing_teams} teams")
                        continue
                    
                    # Создаем Faker для соответствующей страны
                    fake = Faker(['en_GB'])  # Можно добавить больше локалей
                    
                    # Добавляем команды до 16
                    teams_to_create = 16 - existing_teams
                    for _ in range(teams_to_create):
                        team_name = self.generate_team_name(fake)
                        Club.objects.create(
                            name=team_name,
                            country=league.country,
                            league=league,
                            is_bot=True
                        )
                        self.stdout.write(f"Created team: {team_name}")
                    
                    self.stdout.write(
                        self.style.SUCCESS(
                            f"Successfully populated {league.name} with {teams_to_create} teams"
                        )
                    )
                
                self.stdout.write(self.style.SUCCESS("All second divisions populated!"))
                
        except Exception as e:
            self.stdout.write(
                self.style.ERROR(f"Error populating second divisions: {str(e)}")
            )

================
File: tournaments/management/commands/reset_season.py
================
from django.core.management.base import BaseCommand
from django.db import transaction
from django.utils import timezone
from datetime import datetime, date
from tournaments.models import Season, Championship, ChampionshipMatch
from tournaments.utils import create_championship_matches
from matches.match_simulation import simulate_match
from matches.models import Match
from clubs.models import Club

class Command(BaseCommand):
    help = 'Resets and creates new first season starting from November 2024'

    def handle(self, *args, **options):
        try:
            with transaction.atomic():
                # 1. Удаляем все существующие сезоны и связанные данные
                self.stdout.write("Deleting existing seasons and matches...")
                Season.objects.all().delete()  # Это также удалит связанные чемпионаты и матчи

                # 2. Создаем новый первый сезон
                season = Season.objects.create(
                    name="November 2024",
                    number=1,  # Первый сезон
                    start_date=date(2024, 11, 1),
                    end_date=date(2025, 5, 31),
                    is_active=True
                )
                self.stdout.write(self.style.SUCCESS(f"Created new season: {season.name}"))

                # 3. Создаем чемпионаты для всех лиг
                from tournaments.models import League
                leagues = League.objects.all()
                championships_created = 0

                for league in leagues:
                    # Получаем команды для этой лиги
                    bot_teams = Club.objects.filter(league=league, is_bot=True)
                    human_teams = Club.objects.filter(league=league, is_bot=False)
                    total_teams = bot_teams.count() + human_teams.count()
                    
                    # Проверяем, что в лиге ровно 16 команд (боты + человеческие)
                    if total_teams != 16:
                        self.stdout.write(self.style.WARNING(
                            f"Skipping {league.name} - has {total_teams} teams "
                            f"({bot_teams.count()} bots, {human_teams.count()} human)"
                        ))
                        continue

                    championship = Championship.objects.create(
                        season=season,
                        league=league,
                        status='in_progress',  # Так как сезон уже идёт
                        start_date=season.start_date,
                        end_date=season.end_date
                    )
                    
                    # Добавляем все команды в чемпионат
                    for team in list(bot_teams) + list(human_teams):
                        championship.teams.add(team)

                    # Генерируем расписание
                    create_championship_matches(championship)
                    championships_created += 1

                self.stdout.write(self.style.SUCCESS(
                    f"Created {championships_created} championships"
                ))

                # 4. Симулируем матчи с 1 по 7 ноября
                # Используем timezone.make_aware для создания datetime с часовым поясом
                current_date = timezone.make_aware(
                    datetime(2024, 11, 8, 0, 0, 0)
                )
                
                past_matches = Match.objects.filter(
                    date__lt=current_date,
                    status='scheduled'
                )

                matches_simulated = 0
                for match in past_matches:
                    simulate_match(match.id)
                    matches_simulated += 1

                self.stdout.write(self.style.SUCCESS(
                    f"Simulated {matches_simulated} past matches"
                ))

        except Exception as e:
            self.stdout.write(self.style.ERROR(f"Error occurred: {str(e)}"))
            raise e

        self.stdout.write(self.style.SUCCESS("Season reset completed successfully!"))

================
File: tournaments/management/commands/run_match_checker.py
================
from django.core.management.base import BaseCommand
from django.utils import timezone
import time
from matches.models import Match
from matches.match_simulation import simulate_match
import logging

logger = logging.getLogger('matches')

class Command(BaseCommand):
    help = 'Continuously checks and simulates matches'

    def handle(self, *args, **options):
        self.stdout.write('Starting match checker...')
        
        while True:
            try:
                now = timezone.now()
                self.stdout.write(f'Checking matches at {now}')
                
                # Находим матчи для симуляции
                matches = Match.objects.filter(
                    status='scheduled',
                    date__lte=now
                ).select_related('home_team', 'away_team')
                
                if matches.exists():
                    self.stdout.write(f'Found {matches.count()} matches to simulate')
                    
                    for match in matches:
                        try:
                            self.stdout.write(f'Simulating: {match.home_team} vs {match.away_team}')
                            simulate_match(match.id)
                            match.refresh_from_db()
                            self.stdout.write(
                                self.style.SUCCESS(
                                    f'Simulated: {match.home_team} {match.home_score} - {match.away_score} {match.away_team}'
                                )
                            )
                        except Exception as e:
                            self.stdout.write(
                                self.style.ERROR(f'Error simulating match {match.id}: {str(e)}')
                            )
                
                # Ждем 10 секунд перед следующей проверкой
                time.sleep(10)
                
            except Exception as e:
                self.stdout.write(
                    self.style.ERROR(f'Error in match checker: {str(e)}')
                )
                time.sleep(10)

================
File: tournaments/management/commands/test_match.py
================
from django.core.management.base import BaseCommand
from django.utils import timezone
from clubs.models import Club
from matches.models import Match
from matches.match_simulation import MatchSimulation
import random

class Command(BaseCommand):
    help = 'Tests match simulation with random teams'

    def handle(self, *args, **options):
        try:
            # Получаем две случайные команды
            teams = list(Club.objects.all().order_by('?')[:2])
            if len(teams) < 2:
                self.stdout.write(self.style.ERROR('Недостаточно команд в базе данных'))
                return

            home_team = teams[0]
            away_team = teams[1]

            # Выводим информацию о командах до создания матча
            self.stdout.write('\nИнформация о командах:')
            self.stdout.write(f'\nДомашняя команда: {home_team.name}')
            self.stdout.write(f'Количество игроков: {home_team.player_set.count()}')
            
            self.stdout.write(f'\nГостевая команда: {away_team.name}')
            self.stdout.write(f'Количество игроков: {away_team.player_set.count()}\n')

            # Создаем тестовый матч
            match = Match.objects.create(
                home_team=home_team,
                away_team=away_team,
                date=timezone.now(),
                status='scheduled'
            )

            # Инициализируем симуляцию
            simulation = MatchSimulation(match)
            
            # Симулируем матч
            self.stdout.write('\n=== НАЧАЛО МАТЧА ===\n')
            
            for minute in range(90):
                if minute % 15 == 0:  # Каждые 15 минут показываем статус
                    self.stdout.write(f'\n=== {minute} МИНУТА ===')
                    self.stdout.write(f'Счет: {match.home_score} - {match.away_score}')
                    self.stdout.write(f'Владение мячом: {simulation.match_stats["home"]["possession"]}% - {simulation.match_stats["away"]["possession"]}%')
                    self.stdout.write(f'Удары (в створ): {simulation.match_stats["home"]["shots"]} ({simulation.match_stats["home"]["shots_on_target"]}) - {simulation.match_stats["away"]["shots"]} ({simulation.match_stats["away"]["shots_on_target"]})')
                
                simulation.simulate_minute(minute)
            
            # Вывод итоговой статистики
            self.stdout.write('\n=== ИТОГОВАЯ СТАТИСТИКА ===')
            self.stdout.write(f'\nИтоговый счет: {match.home_score} - {match.away_score}')
            self.stdout.write('\nСтатистика домашней команды:')
            self.stdout.write(f'Владение мячом: {simulation.match_stats["home"]["possession"]}%')
            self.stdout.write(f'Удары (в створ): {simulation.match_stats["home"]["shots"]} ({simulation.match_stats["home"]["shots_on_target"]})')
            self.stdout.write(f'Угловые: {simulation.match_stats["home"]["corners"]}')
            self.stdout.write(f'Фолы: {simulation.match_stats["home"]["fouls"]}')
            self.stdout.write(f'Атаки (опасные): {simulation.match_stats["home"]["attacks"]} ({simulation.match_stats["home"]["dangerous_attacks"]})')
            
            self.stdout.write('\nСтатистика гостевой команды:')
            self.stdout.write(f'Владение мячом: {simulation.match_stats["away"]["possession"]}%')
            self.stdout.write(f'Удары (в створ): {simulation.match_stats["away"]["shots"]} ({simulation.match_stats["away"]["shots_on_target"]})')
            self.stdout.write(f'Угловые: {simulation.match_stats["away"]["corners"]}')
            self.stdout.write(f'Фолы: {simulation.match_stats["away"]["fouls"]}')
            self.stdout.write(f'Атаки (опасные): {simulation.match_stats["away"]["attacks"]} ({simulation.match_stats["away"]["dangerous_attacks"]})')
            
            # События матча
            self.stdout.write('\n=== СОБЫТИЯ МАТЧА ===')
            events = match.events.all().order_by('minute')
            for event in events:
                self.stdout.write(f'{event.minute}\' - {event.description}')

        except Exception as e:
            self.stdout.write(self.style.ERROR(f'\nПроизошла ошибка: {str(e)}'))

================
File: tournaments/management/commands/test_prematch.py
================
from django.core.management.base import BaseCommand
from django.utils import timezone
from clubs.models import Club
from matches.models import Match
from matches.match_preparation import PreMatchPreparation
import random

class Command(BaseCommand):
    help = 'Tests prematch preparation with random teams'

    def handle(self, *args, **options):
        try:
            # Получаем две случайные команды
            teams = list(Club.objects.all().order_by('?')[:2])
            if len(teams) < 2:
                self.stdout.write(self.style.ERROR('Недостаточно команд в базе данных'))
                return

            home_team = teams[0]
            away_team = teams[1]

            # Выводим информацию о командах до создания матча
            self.stdout.write('\nИнформация о командах:')
            self.stdout.write(f'\nДомашняя команда: {home_team.name}')
            self.stdout.write(f'Количество игроков: {home_team.player_set.count()}')
            
            self.stdout.write(f'\nГостевая команда: {away_team.name}')
            self.stdout.write(f'Количество игроков: {away_team.player_set.count()}\n')

            # Создаем тестовый матч
            match = Match.objects.create(
                home_team=home_team,
                away_team=away_team,
                date=timezone.now(),
                status='scheduled'
            )

            # Инициализируем подготовку матча
            prep = PreMatchPreparation(match)
            
            # Проводим подготовку
            if prep.prepare_match():
                self.stdout.write(self.style.SUCCESS('\nПредматчевая подготовка успешна!\n'))
                
                # Выводим информацию о командах
                self.stdout.write('\n=== ИНФОРМАЦИЯ О КОМАНДАХ ===')
                self.stdout.write(f'\nДомашняя команда: {home_team.name}')
                self.stdout.write(f'Гостевая команда: {away_team.name}\n')
                
                # Выводим общую силу команд
                self.stdout.write('\n=== ОБЩАЯ СИЛА КОМАНД ===')
                self.stdout.write(f'Домашняя команда: {prep.team_strengths["home"]}')
                self.stdout.write(f'Гостевая команда: {prep.team_strengths["away"]}\n')
                
                # Выводим детальные параметры
                self.stdout.write('\n=== ПАРАМЕТРЫ ДОМАШНЕЙ КОМАНДЫ ===')
                home_params = prep.match_parameters['home']
                self.stdout.write(f'Атака: {home_params["team_attack"]}')
                self.stdout.write(f'Оборона: {home_params["team_defense"]}')
                self.stdout.write(f'Полузащита: {home_params["team_midfield"]}')
                self.stdout.write(f'Сила вратаря: {home_params["goalkeeper_strength"]}\n')
                
                self.stdout.write('\n=== ПАРАМЕТРЫ ГОСТЕВОЙ КОМАНДЫ ===')
                away_params = prep.match_parameters['away']
                self.stdout.write(f'Атака: {away_params["team_attack"]}')
                self.stdout.write(f'Оборона: {away_params["team_defense"]}')
                self.stdout.write(f'Полузащита: {away_params["team_midfield"]}')
                self.stdout.write(f'Сила вратаря: {away_params["goalkeeper_strength"]}\n')
                
            else:
                self.stdout.write(self.style.ERROR('\nОшибки при подготовке матча:'))
                for error in prep.get_validation_errors():
                    self.stdout.write(self.style.ERROR(f'- {error}'))
            
            # Удаляем тестовый матч
            match.delete()

        except Exception as e:
            self.stdout.write(self.style.ERROR(f'\nПроизошла ошибка: {str(e)}'))

================
File: tournaments/management/commands/update_club_matches.py
================
from django.core.management.base import BaseCommand
from django.db import transaction
from django.db.models import Q
from tournaments.models import Championship, ChampionshipMatch
from matches.models import Match
from clubs.models import Club
import logging

logger = logging.getLogger(__name__)

def update_matches_for_replaced_team(championship, old_team_id, new_team):
    """
    Обновляет все матчи, заменяя old_team на new_team
    """
    try:
        with transaction.atomic():
            # Найти все матчи, где участвовала старая команда
            matches = Match.objects.filter(
                championshipmatch__championship=championship
            ).filter(
                Q(home_team_id=old_team_id) |
                Q(away_team_id=old_team_id)
            )
            
            updated_count = 0
            # Обновить все найденные матчи
            for match in matches:
                if match.home_team_id == old_team_id:
                    match.home_team = new_team
                    updated_count += 1
                if match.away_team_id == old_team_id:
                    match.away_team = new_team
                    updated_count += 1
                match.save()
                logger.info(f"Updated match {match.id}: {match.home_team} vs {match.away_team}")
            
            return updated_count  # Возвращаем количество обновленных матчей
    except Exception as e:
        logger.error(f"Error updating matches: {str(e)}")
        raise

class Command(BaseCommand):
    help = 'Updates championship matches for a club, replacing a bot team'

    def add_arguments(self, parser):
        parser.add_argument('club_id', type=int, help='ID of the club to update matches for')

    def handle(self, *args, **options):
        club_id = options['club_id']
        
        try:
            with transaction.atomic():
                # Получаем клуб
                club = Club.objects.get(id=club_id)
                self.stdout.write(f"Found club: {club.name} (ID: {club.id})")
                
                # Находим активный чемпионат для страны клуба
                championship = Championship.objects.get(
                    league__country=club.country,
                    league__level=1,
                    season__is_active=True
                )
                self.stdout.write(f"Found championship: {championship}")

                # Проверяем, есть ли клуб в чемпионате
                is_in_championship = championship.teams.filter(id=club.id).exists()
                if not is_in_championship:
                    self.stdout.write(self.style.ERROR(f"Club {club.name} is not part of championship {championship}"))
                    return

                # Получаем все матчи чемпионата
                matches = Match.objects.filter(
                    championshipmatch__championship=championship
                )

                # Находим матчи, где клуб должен участвовать
                team_matches = matches.filter(
                    Q(home_team=club) |
                    Q(away_team=club)
                ).count()

                if team_matches == 0:
                    # Клуб в чемпионате, но нет матчей - ищем бота, которого он заменил
                    self.stdout.write("Looking for replaced bot team...")
                    
                    # Выводим все команды в чемпионате для отладки
                    self.stdout.write("\nTeams in championship:")
                    for team in championship.teams.all():
                        self.stdout.write(f"- {team.name} (ID: {team.id}, Bot: {team.is_bot})")
                    
                    # Проверяем статистику
                    from tournaments.models import ChampionshipTeam
                    team_stats = ChampionshipTeam.objects.filter(
                        championship=championship,
                        team=club
                    ).first()
                    
                    if team_stats:
                        self.stdout.write(f"\nFound team statistics:")
                        self.stdout.write(f"Points: {team_stats.points}")
                        self.stdout.write(f"Matches played: {team_stats.matches_played}")
                    else:
                        self.stdout.write(self.style.WARNING("No team statistics found!"))

                    # Выводим пример нескольких матчей для отладки
                    self.stdout.write("\nSample matches in championship:")
                    for match in matches[:5]:
                        self.stdout.write(
                            f"- {match.home_team.name} vs {match.away_team.name}"
                        )

                    # Находим команды-боты с таким же количеством очков
                    if team_stats:
                        potential_bots = ChampionshipTeam.objects.filter(
                            championship=championship,
                            points=team_stats.points,
                            team__is_bot=True
                        )
                        
                        self.stdout.write(f"\nFound {potential_bots.count()} potential bot matches:")
                        for bot_stats in potential_bots:
                            self.stdout.write(
                                f"- {bot_stats.team.name} "
                                f"(Points: {bot_stats.points}, "
                                f"Matches: {bot_stats.matches_played})"
                            )
                    
                    # Спрашиваем пользователя об ID бота
                    bot_id = input("\nEnter the ID of the bot team to replace: ")
                    try:
                        bot_id = int(bot_id)
                        replaced_matches = update_matches_for_replaced_team(
                            championship=championship,
                            old_team_id=bot_id,
                            new_team=club
                        )
                        self.stdout.write(
                            self.style.SUCCESS(
                                f"Successfully updated {replaced_matches} matches "
                                f"for club {club.name}"
                            )
                        )
                    except ValueError:
                        self.stdout.write(self.style.ERROR("Invalid bot ID!"))
                else:
                    self.stdout.write(
                        self.style.SUCCESS(
                            f"Club {club.name} already has {team_matches} matches "
                            f"in championship {championship}"
                        )
                    )

        except Club.DoesNotExist:
            self.stdout.write(self.style.ERROR(f"Club with ID {club_id} not found"))
        except Championship.DoesNotExist:
            self.stdout.write(
                self.style.ERROR(
                    f"No active championship found for club {club.name} "
                    f"in country {club.country}"
                )
            )
        except Exception as e:
            self.stdout.write(self.style.ERROR(f"Error: {str(e)}"))

================
File: tournaments/middleware.py
================
# tournaments/middleware.py
from django.utils import timezone
from datetime import timedelta
from matches.models import Match
from matches.match_simulation import simulate_match
import logging

logger = logging.getLogger('matches')

class MatchSimulationMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
        self.last_check = timezone.now()
        self.check_interval = timedelta(seconds=10)  # Уменьшим интервал для тестирования
        logger.info("Match simulation middleware initialized")

    def __call__(self, request):
        now = timezone.now()
        
        # Добавим подробное логирование
        logger.info(f"Checking matches at {now}")
        logger.info(f"Last check was at {self.last_check}")
        
        if now - self.last_check >= self.check_interval:
            logger.info("Starting match check...")
            self.check_matches()
            self.last_check = now
            
        return self.get_response(request)

    def check_matches(self):
        now = timezone.now()
        matches = Match.objects.filter(
            status='scheduled',
            date__lte=now
        ).select_related('home_team', 'away_team')

        logger.info(f"Found {matches.count()} matches to check")
        
        for match in matches:
            try:
                logger.info(f"Simulating match: {match.home_team} vs {match.away_team}")
                simulate_match(match.id)
                
                # Перезагружаем матч для получения результата
                match.refresh_from_db()
                logger.info(
                    f"Match simulated: {match.home_team} {match.home_score} - {match.away_score} {match.away_team}"
                )
            except Exception as e:
                logger.error(f"Error simulating match {match.id}: {str(e)}")

================
File: tournaments/models.py
================
from django.db import models
from django.core.exceptions import ValidationError
from django.utils import timezone
from django_countries.fields import CountryField
from clubs.models import Club
from matches.models import Match
from datetime import datetime, timedelta, time
import pytz
import calendar
from .date_utils import get_next_season_dates  # Изменен импорт

class Season(models.Model):
    """Model for representing a game season"""
    number = models.PositiveIntegerField(
        unique=True, 
        help_text="Порядковый номер сезона"
    )
    name = models.CharField(max_length=100)
    start_date = models.DateField()
    end_date = models.DateField()
    is_active = models.BooleanField(default=False)

    class Meta:
        ordering = ['-start_date']

    def __str__(self):
        return f"Сезон {self.number} ({self.start_date.strftime('%B %Y')})"

    def clean(self):
        """Проверка корректности дат сезона"""
        if not self.start_date:
            return

        if self.start_date.day != 1:
            raise ValidationError({
                'start_date': 'Дата начала сезона должна быть первым числом месяца'
            })

        # Определяем последний день месяца используя calendar.monthrange
        _, last_day = calendar.monthrange(self.start_date.year, self.start_date.month)
        expected_end_date = self.start_date.replace(day=last_day)
        
        if self.end_date != expected_end_date:
            raise ValidationError({
                'end_date': f'Дата окончания сезона должна быть {last_day}-м числом месяца'
            })

    @property
    def is_february(self) -> bool:
        """Проверяет, является ли текущий сезон февральским"""
        return self.start_date.month == 2

    @property
    def needs_double_matchday(self) -> bool:
        """Определяет, нужны ли двойные туры в этом сезоне"""
        return self.is_february and calendar.monthrange(self.start_date.year, 2)[1] == 28

    def get_double_matchday_dates(self) -> list:
        """Возвращает даты для двойных туров"""
        if not self.needs_double_matchday:
            return []
        
        dates = [self.start_date.replace(day=15)]
        if self.end_date.day == 28:  # Для невисокосного февраля
            dates.append(self.start_date.replace(day=16))
        return dates

    def save(self, *args, **kwargs):
        if not self.name:
            self.name = f"Сезон {self.number}"
        super().save(*args, **kwargs)

    @classmethod
    def create_next_season(cls) -> 'Season':
        """Создает новый сезон"""
        last_season = cls.objects.order_by('-number').first()
        new_season_number = 1 if not last_season else last_season.number + 1

        # Получаем даты следующего сезона
        start_date, end_date = get_next_season_dates()

        season = cls(
            number=new_season_number,
            start_date=start_date,
            end_date=end_date,
            is_active=True
        )
        season.full_clean()
        season.save()
        return season

class League(models.Model):
    """Model for representing a league/division"""
    name = models.CharField(max_length=100)
    country = CountryField()
    level = models.PositiveIntegerField()  # 1 for top division, 2 for second, etc.
    max_teams = models.PositiveIntegerField(default=16)
    foreign_players_limit = models.PositiveIntegerField(
        default=5, 
        help_text="Maximum number of foreign players allowed in match squad"
    )

    class Meta:
        unique_together = ['country', 'level']
        ordering = ['country', 'level']

    def __str__(self):
        return f"{self.name} ({self.country})"

    def clean(self):
        if self.max_teams != 16:
            raise ValidationError({
                'max_teams': 'Количество команд в лиге должно быть равно 16'
            })

class Championship(models.Model):
    STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('in_progress', 'In Progress'),
        ('finished', 'Finished')
    ]

    season = models.ForeignKey(Season, on_delete=models.CASCADE)
    league = models.ForeignKey(League, on_delete=models.CASCADE)
    teams = models.ManyToManyField(Club, through='ChampionshipTeam')
    status = models.CharField(
        max_length=20, 
        choices=STATUS_CHOICES,
        default='pending'
    )
    start_date = models.DateField()
    end_date = models.DateField()
    match_time = models.TimeField(
        default=time(18, 0),
        help_text="Match start time (UTC)"
    )

    class Meta:
        unique_together = ['season', 'league']

    def __str__(self):
        return f"{self.league.name} - {self.season.name}"

    def get_local_match_time(self, user_timezone=None):
        if not user_timezone:
            user_timezone = timezone.get_current_timezone()
        utc_time = datetime.combine(datetime.today(), self.match_time)
        utc_time = pytz.utc.localize(utc_time)
        return utc_time.astimezone(user_timezone).time()

    def clean(self):
        if self.teams.count() != 16:
            raise ValidationError('Количество команд в чемпионате должно быть равно 16')

    def can_participate_in_transitions(self) -> bool:
        """Проверяет, может ли чемпионат участвовать в переходах"""
        if not self.is_completed:
            return False
            
        valid, error = self.validate_status()
        if not valid:
            return False
            
        if self.league.level not in [1, 2]:
            return False
            
        return True

    def get_teams_for_relegation(self) -> list:
        """Возвращает две команды для понижения в дивизионе"""
        if self.league.level != 1:
            raise ValidationError("Relegation is only possible from the first division")

        if not self.can_participate_in_transitions():
            raise ValidationError("Championship cannot participate in transitions yet")
            
        return (
            self.championshipteam_set
            .annotate(
                goals_diff=models.F('goals_for') - models.F('goals_against')
            )
            .select_related('team')
            .order_by(
                'points',
                'goals_diff',
                'goals_for'
            )[:2]
        )

    def get_teams_for_promotion(self) -> list:
        """Возвращает две команды для повышения в дивизионе"""
        if self.league.level != 2:
            raise ValidationError("Promotion is only possible from the second division")

        if not self.can_participate_in_transitions():
            raise ValidationError("Championship cannot participate in transitions yet")
            
        return (
            self.championshipteam_set
            .annotate(
                goals_diff=models.F('goals_for') - models.F('goals_against')
            )
            .select_related('team')
            .order_by(
                '-points',
                '-goals_diff',
                '-goals_for'
            )[:2]
        )

    @property
    def is_completed(self) -> bool:
        """Проверяет, завершены ли все матчи чемпионата"""
        return not self.championshipmatch_set.filter(
            ~models.Q(match__status='finished')
        ).exists()

    def get_standings(self) -> list:
        """Возвращает отсортированную таблицу результатов"""
        return (
            self.championshipteam_set
            .annotate(
                goals_diff=models.F('goals_for') - models.F('goals_against')
            )
            .select_related('team')
            .order_by(
                '-points',
                '-goals_diff',
                '-goals_for'
            )
        )

    def validate_status(self) -> tuple:
        """
        Проверяет текущий статус чемпионата
        Возвращает (is_valid, error_message)
        """
        if self.teams.count() != 16:
            return False, "Неверное количество команд в чемпионате"
                
        matches_count = self.championshipmatch_set.count()
        expected_matches = 16 * 15  # Каждая команда играет с каждой другой дважды
        if matches_count != expected_matches:
            return False, f"Неверное количество матчей: {matches_count} вместо {expected_matches}"
                
        return True, None

class ChampionshipTeam(models.Model):
    """Model for storing team statistics in championship"""
    championship = models.ForeignKey(Championship, on_delete=models.CASCADE)
    team = models.ForeignKey(Club, on_delete=models.CASCADE)
    points = models.PositiveIntegerField(default=0)
    matches_played = models.PositiveIntegerField(default=0)
    wins = models.PositiveIntegerField(default=0)
    draws = models.PositiveIntegerField(default=0)
    losses = models.PositiveIntegerField(default=0)
    goals_for = models.PositiveIntegerField(default=0)
    goals_against = models.PositiveIntegerField(default=0)

    class Meta:
        unique_together = ['championship', 'team']
        ordering = ['-points', '-goals_for']

    def __str__(self):
        return f"{self.team.name} - {self.championship}"

    @property
    def goals_difference(self):
        """Calculate goals difference"""
        return self.goals_for - self.goals_against

    @property
    def points_per_game(self):
        """Calculate average points per game"""
        if self.matches_played > 0:
            return round(self.points / self.matches_played, 2)
        return 0

    @property
    def position(self) -> int:
        """Возвращает текущую позицию команды в таблице"""
        return (
            self.championship.championshipteam_set
            .annotate(
                goals_diff=models.F('goals_for') - models.F('goals_against')
            )
            .filter(
                models.Q(points__gt=self.points) |
                (models.Q(points=self.points) & models.Q(goals_diff__gt=self.goals_difference)) |
                (models.Q(points=self.points) & 
                 models.Q(goals_diff=self.goals_difference) & 
                 models.Q(goals_for__gt=self.goals_for))
            )
            .count() + 1
        )

    @property
    def is_relegation_zone(self) -> bool:
        """Проверяет, находится ли команда в зоне вылета"""
        return self.position >= 15

    @property
    def is_promotion_zone(self) -> bool:
        """Проверяет, находится ли команда в зоне повышения"""
        return self.position <= 2

class ChampionshipMatch(models.Model):
    """Model for linking matches to championship"""
    championship = models.ForeignKey(Championship, on_delete=models.CASCADE)
    match = models.OneToOneField(Match, on_delete=models.CASCADE)
    round = models.PositiveIntegerField()
    match_day = models.PositiveIntegerField()
    processed = models.BooleanField(default=False)

    class Meta:
        ordering = ['round', 'match_day']

    def __str__(self):
        return f"Round {self.round}: {self.match}"

    @property
    def match_datetime(self):
        """Возвращает дату и время матча"""
        return datetime.combine(
            self.championship.start_date + timedelta(days=self.match_day - 1),
            datetime.min.time().replace(hour=13)
        )

================
File: tournaments/signals.py
================
from django.db.models.signals import post_save, pre_save
from django.dispatch import receiver
from clubs.models import Club
from tournaments.models import Championship, ChampionshipTeam, ChampionshipMatch, Season
from matches.models import Match
from django.db import transaction
from django.db.models import Q
from django.core.management import call_command

def update_matches_for_replaced_team(championship, old_team_id, new_team):
    """
    Обновляет все матчи, заменяя old_team на new_team
    """
    try:
        with transaction.atomic():
            # Находим все матчи старой команды
            bot_matches = Match.objects.filter(
                championshipmatch__championship=championship
            ).filter(
                Q(home_team_id=old_team_id) | Q(away_team_id=old_team_id)
            ).select_related(
                'championshipmatch',
                'home_team',
                'away_team'
            ).order_by('championshipmatch__round')

            # Обновляем каждый матч
            updated_count = 0
            unique_opponents = set()

            for match in bot_matches:
                # Получаем противника
                opponent = match.away_team if match.home_team_id == old_team_id else match.home_team
                unique_opponents.add(opponent.id)
                
                # Обновляем команду в матче
                if match.home_team_id == old_team_id:
                    match.home_team = new_team
                else:
                    match.away_team = new_team

                match.save()
                updated_count += 1

            # Проверка на количество уникальных противников
            if len(unique_opponents) < 2:
                raise ValueError(
                    f"Error: team has only {len(unique_opponents)} opponents. "
                    f"Something is wrong with the schedule."
                )

            return updated_count

    except Exception as e:
        raise

@receiver(post_save, sender=Club)
def handle_club_creation(sender, instance, created, **kwargs):
    """Обрабатывает создание нового клуба и замещение бота"""
    if not created or instance.is_bot:
        return
        
    try:
        with transaction.atomic():
            # Найти активный чемпионат
            championship = Championship.objects.select_related('season')\
                .filter(
                    league__country=instance.country,
                    league__level=1,
                    season__is_active=True
                ).first()
                
            if not championship:
                return

            # Проверяем, не добавлен ли уже клуб
            if championship.teams.filter(id=instance.id).exists():
                return
                
            # Найти команду-бота для замены
            bot_team = championship.teams.filter(is_bot=True).first()
            if not bot_team:
                return
            
            # Сохраняем ID бота перед удалением
            bot_team_id = bot_team.id
                
            # Получаем статистику бота
            bot_stats = ChampionshipTeam.objects.get(
                championship=championship,
                team=bot_team
            )
            
            # Создаем запись для нового клуба
            ChampionshipTeam.objects.create(
                championship=championship,
                team=instance,
                points=bot_stats.points,
                matches_played=bot_stats.matches_played,
                wins=bot_stats.wins,
                draws=bot_stats.draws,
                losses=bot_stats.losses,
                goals_for=bot_stats.goals_for,
                goals_against=bot_stats.goals_against
            )
            
            # Обновляем матчи
            update_matches_for_replaced_team(
                championship=championship,
                old_team_id=bot_team_id,
                new_team=instance
            )
            
            # Удаляем бота
            bot_stats.delete()
            bot_team.delete()
            
    except Exception as e:
        raise

@receiver(post_save, sender=Match)
def handle_match_result(sender, instance, **kwargs):
    """Обновляет статистику команд после завершения матча"""
    try:
        championship_match = ChampionshipMatch.objects.select_related(
            'championship',
            'match',
            'match__home_team',
            'match__away_team'
        ).filter(match=instance).first()

        if not championship_match or championship_match.processed or instance.status != 'finished':
            return

        max_attempts = 3
        current_attempt = 0

        while current_attempt < max_attempts:
            try:
                with transaction.atomic():
                    # Получаем статистику команд
                    home_stats = ChampionshipTeam.objects.select_for_update().get(
                        championship=championship_match.championship,
                        team=instance.home_team
                    )
                    away_stats = ChampionshipTeam.objects.select_for_update().get(
                        championship=championship_match.championship,
                        team=instance.away_team
                    )

                    # Обновляем статистику
                    home_stats.matches_played += 1
                    away_stats.matches_played += 1
                    home_stats.goals_for += instance.home_score
                    home_stats.goals_against += instance.away_score
                    away_stats.goals_for += instance.away_score
                    away_stats.goals_against += instance.home_score

                    # Обновляем результаты
                    if instance.home_score > instance.away_score:
                        home_stats.wins += 1
                        home_stats.points += 3
                        away_stats.losses += 1
                    elif instance.home_score < instance.away_score:
                        away_stats.wins += 1
                        away_stats.points += 3
                        home_stats.losses += 1
                    else:
                        home_stats.draws += 1
                        away_stats.draws += 1
                        home_stats.points += 1
                        away_stats.points += 1

                    # Сохраняем изменения
                    home_stats.save()
                    away_stats.save()

                    # Проверяем завершение чемпионата
                    championship = championship_match.championship
                    if championship.is_completed and championship.status != 'finished':
                        championship.status = 'finished'
                        championship.save()

                    championship_match.processed = True
                    championship_match.save()
                    return

            except Exception:
                current_attempt += 1
                if current_attempt == max_attempts:
                    raise
                import time
                time.sleep(1)

    except Exception:
        raise

@receiver(post_save, sender=Season)
def handle_season_end(sender, instance, **kwargs):
    """Обрабатывает окончание сезона"""
    # Проверяем, что сезон был активным, но стал неактивным
    if not instance.is_active and kwargs.get('update_fields') and 'is_active' in kwargs['update_fields']:
        try:
            with transaction.atomic():
                # Запускаем процесс переходов между дивизионами
                call_command('handle_season_transitions')
        except Exception as e:
            raise

@receiver(post_save, sender=ChampionshipTeam)
def update_team_league(sender, instance, **kwargs):
    """Обновляет привязку команды к лиге при изменении статистики"""
    if instance.championship.status == 'finished':
        try:
            with transaction.atomic():
                team = instance.team
                
                # Получаем текущую позицию команды
                position = instance.position
                current_level = instance.championship.league.level
                
                # Определяем, нужно ли менять лигу
                if current_level == 1 and position >= 15:  # Вылет из высшего дивизиона
                    new_league = League.objects.get(
                        country=team.country,
                        level=2
                    )
                    team.league = new_league
                    team.save()
                elif current_level == 2 and position <= 2:  # Повышение во второй дивизион
                    new_league = League.objects.get(
                        country=team.country,
                        level=1
                    )
                    team.league = new_league
                    team.save()
        except Exception as e:
            raise

================
File: tournaments/static/tournaments/css/calendar.css
================
/* Основные стили календаря */
.fc {
    max-width: 100%;
    background: white;
    padding: 10px;
    border-radius: 5px;
}

/* Стили событий в зависимости от статуса */
.match-scheduled {
    background-color: #6c757d;
    border-color: #5a6268;
    color: white;
}

.match-in_progress {
    background-color: #ffc107;
    border-color: #d39e00;
    color: black;
}

.match-finished {
    background-color: #198754;
    border-color: #146c43;
    color: white;
}

/* Стили для заголовков */
.fc-header-toolbar {
    margin-bottom: 1.5em;
}

.fc-toolbar-title {
    font-size: 1.25em !important;
}

/* Стили для ячеек */
.fc-daygrid-day {
    min-height: 100px;
}

/* Стили для событий */
.fc-event {
    cursor: pointer;
    padding: 2px 4px;
    margin: 1px 0;
    font-size: 0.85em;
}

/* Стили для модального окна с временными зонами */
.timezone-modal {
    max-width: 400px;
}

.timezone-modal .modal-body {
    max-height: 300px;
    overflow-y: auto;
}

================
File: tournaments/static/tournaments/js/calendar.js
================
document.addEventListener('DOMContentLoaded', function() {
    // Инициализация календаря
    const calendarEl = document.getElementById('calendar');
    if (!calendarEl) return;

    const calendar = new FullCalendar.Calendar(calendarEl, {
        initialView: 'dayGridMonth',
        headerToolbar: {
            left: 'prev,next today',
            center: 'title',
            right: 'dayGridMonth,timeGridWeek,timeGridDay'
        },
        events: calendarEvents,
        eventTimeFormat: {
            hour: '2-digit',
            minute: '2-digit',
            hour12: false,
            meridiem: false
        },
        eventClick: function(info) {
            if (info.event.url) {
                window.location.href = info.event.url;
                info.jsEvent.preventDefault();
            }
        },
        eventDidMount: function(info) {
            // Добавляем тултип с деталями матча
            const event = info.event;
            let tooltipContent = `${event.title}<br>`;
            if (event.extendedProps.status === 'finished') {
                tooltipContent += `Score: ${event.extendedProps.score}`;
            } else {
                tooltipContent += event.extendedProps.status;
            }
            
            new bootstrap.Tooltip(info.el, {
                title: tooltipContent,
                html: true,
                placement: 'top',
                customClass: 'match-tooltip'
            });
        }
    });

    calendar.render();
});

// Функция для обновления отображения времени
function updateMatchTimes(timezone) {
    document.querySelectorAll('.match-time').forEach(function(el) {
        const utcTime = moment.utc(el.dataset.utc);
        el.textContent = utcTime.tz(timezone).format('DD MMM HH:mm');
    });
    
    if (typeof calendar !== 'undefined') {
        calendar.setOption('timeZone', timezone);
        calendar.refetchEvents();
    }
}

================
File: tournaments/tasks.py
================
# C:\realfootballsim\tournaments\tasks.py

from celery import shared_task
from django.utils import timezone
from django.db import transaction, OperationalError
from django.core.management import call_command
from matches.models import Match
from players.models import Player
from clubs.models import Club
from .models import Season, Championship, League
import logging
import time
from datetime import timedelta
from django.core.exceptions import ObjectDoesNotExist
import random

logger = logging.getLogger(__name__)


def retry_on_db_lock(func, max_attempts=3, delay=1):
    """
    Декоратор для повторных попыток в случае Database is locked (SQLite).
    """
    def wrapper(*args, **kwargs):
        attempts = 0
        while attempts < max_attempts:
            try:
                return func(*args, **kwargs)
            except OperationalError as e:
                if "database is locked" in str(e) and attempts < max_attempts - 1:
                    attempts += 1
                    time.sleep(delay)
                    continue
                raise
    return wrapper


@shared_task(name='tournaments.simulate_active_matches', bind=True)
def simulate_active_matches(self):
    """
    Пошаговая симуляция матчей (каждая «минута»).
    """
    now = timezone.now()
    logger.info(f"Starting active matches simulation at {now}")

    matches = Match.objects.filter(status='in_progress')
    if not matches.exists():
        logger.info("No matches in progress at the moment.")
        return "No matches in progress"

    from matches.match_simulation import simulate_one_minute

    for match in matches:
        simulate_one_minute(match.id)
        logger.info(
            f"Simulated one minute for match {match.id} "
            f"({match.home_team} vs {match.away_team}, current_minute={match.current_minute})"
        )

    return f"Simulated one minute for {matches.count()} matches"


@shared_task(name='tournaments.check_season_end', bind=True)
def check_season_end(self):
    """
    Проверяет окончание сезона и создаёт новый при необходимости.
    """
    try:
        with transaction.atomic():
            current_season = Season.objects.select_for_update().get(is_active=True)
            today = timezone.now().date()

            logger.info(
                f"Checking season {current_season.number} (end date: {current_season.end_date})"
            )

            is_end_date_passed = today > current_season.end_date
            finished_matches_count = Match.objects.filter(
                championshipmatch__championship__season=current_season,
                status='finished'
            ).count()

            # Допустим у нас 16 команд, каждая играет 15 туров * 2 круга = 30, итого 16 * 15 (т.к. каждая пара считает лишь один раз)
            required_matches = (
                len(Championship.objects.filter(season=current_season)) * (16 * 15)
            )
            all_matches_played = finished_matches_count >= required_matches

            if is_end_date_passed and all_matches_played:
                logger.info(f"Season {current_season.number} has ended. Starting end-season process...")

                # Проверяем, не остались ли незавершенные матчи
                unfinished_matches = Match.objects.filter(
                    championshipmatch__championship__season=current_season,
                    status__in=['scheduled', 'in_progress']
                ).count()
                
                if unfinished_matches > 0:
                    return f"Season {current_season.number} has {unfinished_matches} unfinished matches"

                logger.info("Processing teams transitions between divisions...")
                call_command('handle_season_transitions')

                current_season.is_active = False
                current_season.save()

                logger.info("Creating new season...")
                call_command('create_new_season')

                new_season = Season.objects.get(is_active=True)
                championships = Championship.objects.filter(season=new_season)
                total_teams = sum(c.teams.count() for c in championships)

                return (
                    f"Season {current_season.number} ended successfully. "
                    f"Created new season {new_season.number} with "
                    f"{championships.count()} championships and {total_teams} teams"
                )

            return f"Season {current_season.number} is still active"

    except Season.DoesNotExist:
        logger.warning("No active season found")
        return "No active season found"
    except Exception as e:
        logger.error(f"Error in season end check: {str(e)}")
        raise


@shared_task(name='tournaments.start_scheduled_matches')
def start_scheduled_matches():
    """
    Переводит матчи из scheduled в in_progress и копирует составы команд.
    Автоматически дополняет неполные составы случайными игроками из клуба.
    """

    def complete_lineup(club, current_lineup):
        """
        Дополняет неполный состав случайными игроками из клуба.
        
        current_lineup может содержать либо строки (старый формат),
        либо словари вида:
            {
                "playerId": "8012",
                "slotType": "...",
                ...
            }
        Нужно извлекать из этого словаря именно playerId и приводить к int.
        """
        # 1) Определяем, используется ли формат "dict" (playerId) или старый
        #    Сделаем проверку по первому элементу, если он есть.
        is_new_format = False
        if current_lineup:
            any_val = next(iter(current_lineup.values()))
            if isinstance(any_val, dict):
                is_new_format = True

        # 2) Собираем ID уже занятых игроков
        used_ids = set()
        for slot_key, slot_val in current_lineup.items():
            if isinstance(slot_val, dict):
                # Новый формат
                pid_str = slot_val.get('playerId')
                if pid_str is not None:
                    used_ids.add(int(pid_str))
            else:
                # Старый формат
                used_ids.add(int(slot_val))

        # 3) Получаем всех доступных игроков клуба
        available_players = list(
            Player.objects.filter(club=club)
            .exclude(id__in=used_ids)
            .values_list('id', flat=True)
        )

        # 4) Сколько недостает игроков?
        slots_needed = 11 - len(current_lineup)
        if len(available_players) < slots_needed:
            return None  # Недостаточно игроков

        # 5) Рандомно добавляем нужное число
        random_players = random.sample(available_players, slots_needed)
        next_pos = len(current_lineup)

        for player_id in random_players:
            if is_new_format:
                # Создаем запись в виде dict
                current_lineup[str(next_pos)] = {
                    "playerId": str(player_id),
                    # Остальные поля можно заполнить пустыми или как угодно
                    "slotType": "auto_filled",
                    "slotLabel": f"AUTO{next_pos}",
                    "playerPosition": ""  # Можно попытаться вычислить из Player, если нужно
                }
            else:
                # Старый формат: просто строка
                current_lineup[str(next_pos)] = str(player_id)

            next_pos += 1

        return current_lineup

    now = timezone.now()
    logger.info("===== STARTING start_scheduled_matches TASK =====")

    with transaction.atomic():
        matches = Match.objects.select_for_update().filter(
            status='scheduled',
            datetime__lte=now
        )
        count = matches.count()

        if count == 0:
            logger.info("No scheduled matches ready to start.")
            return "0 matches started."

        logger.info(f"Found {count} scheduled matches ready to start.")

        for match in matches:
            logger.info(f"Processing match ID={match.id}: {match.home_team} vs {match.away_team}")

            # Обработка состава домашней команды
            home_data = match.home_team.lineup
            if not home_data or not isinstance(home_data, dict):
                home_data = {"lineup": {}}

            home_lineup = home_data.get('lineup', {})
            if len(home_lineup) < 11:
                new_home_lineup = complete_lineup(match.home_team, home_lineup)
                if new_home_lineup is None:
                    return '0 matches started: not enough players in home team'
                home_lineup = new_home_lineup

            match.home_lineup = home_lineup
            match.home_tactic = home_data.get('tactic', 'balanced')

            # Обработка состава гостевой команды
            away_data = match.away_team.lineup
            if not away_data or not isinstance(away_data, dict):
                away_data = {"lineup": {}}

            away_lineup = away_data.get('lineup', {})
            if len(away_lineup) < 11:
                new_away_lineup = complete_lineup(match.away_team, away_lineup)
                if new_away_lineup is None:
                    return '0 matches started: not enough players in away team'
                away_lineup = new_away_lineup

            match.away_lineup = away_lineup
            match.away_tactic = away_data.get('tactic', 'balanced')

            # Обновляем статус и сохраняем
            match.status = 'in_progress'
            match.save()

            logger.info(
                f"Match {match.id} is now in_progress. "
                f"home_lineup={match.home_lineup}, away_lineup={match.away_lineup} "
                f"home_tactic={match.home_tactic}, away_tactic={match.away_tactic}"
            )

    return f"{count} matches started."

================
File: tournaments/templates/tournaments/base.html
================
{% extends 'core/base.html' %}

{% block content %}
<div class="row">
    <div class="col-12">
        <nav class="mb-4">
            <div class="d-flex justify-content-between align-items-center">
                <ul class="nav nav-tabs">
                    <li class="nav-item">
                        <a class="nav-link {% if request.resolver_match.url_name == 'championship_list' %}active{% endif %}" 
                           href="{% url 'tournaments:championship_list' %}">Championships</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link {% if request.resolver_match.url_name == 'season_list' %}active{% endif %}" 
                           href="{% url 'tournaments:season_list' %}">Seasons</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link {% if request.resolver_match.url_name == 'league_list' %}active{% endif %}" 
                           href="{% url 'tournaments:league_list' %}">Leagues</a>
                    </li>
                </ul>
                
                <div style="width: 200px;">
                    {% include 'tournaments/timezone_selector.html' %}
                </div>
            </div>
        </nav>
        
        {% block tournament_content %}{% endblock %}
    </div>
</div>
{% endblock %}

================
File: tournaments/templates/tournaments/championship_detail.html
================
{% extends 'tournaments/base.html' %}
{% load static %}

{% block tournament_content %}
<div class="row">
    <!-- Header Section -->
    <div class="col-12 mb-4">
        <div class="card">
            <div class="card-body">
                <div class="d-flex justify-content-between align-items-center">
                    <div>
                        <h2>{{ championship.league.name }}</h2>
                        <p class="text-muted mb-0">
                            {{ championship.league.country.name }} - Division {{ championship.league.level }}
                        </p>
                        <p class="text-muted">
                            Season: {{ championship.season.name }} | 
                            Status: {{ championship.get_status_display }} |
                            Match Time: <span id="match-time" utc-time="{{ championship.match_time|time:'H:i' }}"></span>
                        </p>
                    </div>
                    <div>
                        <button class="btn btn-outline-secondary" data-bs-toggle="modal" data-bs-target="#timezonesModal">
                            Change Timezone
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- League Table -->
    <div class="col-md-8">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h3 class="card-title h5 mb-0">League Table</h3>
                <a href="{% url 'matches:championship_matches' championship.id %}" class="btn btn-primary btn-sm">
                    View All Matches
                </a>
            </div>
            <div class="card-body">
                <div class="table-responsive">
                    <table class="table table-hover">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Team</th>
                                <th>MP</th>
                                <th>W</th>
                                <th>D</th>
                                <th>L</th>
                                <th>GF</th>
                                <th>GA</th>
                                <th>GD</th>
                                <th>Pts</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for team in standings %}
                            <tr>
                                <td>{{ forloop.counter }}</td>
                                <td>
                                    <a href="{% url 'clubs:club_detail' team.team.id %}" class="text-decoration-none">
                                        {{ team.team.name }}
                                        {% if team.team.is_bot %}
                                            <small class="text-muted">(Bot)</small>
                                        {% endif %}
                                    </a>
                                </td>
                                <td>{{ team.matches_played }}</td>
                                <td>{{ team.wins }}</td>
                                <td>{{ team.draws }}</td>
                                <td>{{ team.losses }}</td>
                                <td>{{ team.goals_for }}</td>
                                <td>{{ team.goals_against }}</td>
                                <td>{% if team.goals_diff > 0 %}+{% endif %}{{ team.goals_diff }}</td>
                                <td><strong>{{ team.points }}</strong></td>
                            </tr>
                            {% empty %}
                            <tr>
                                <td colspan="10" class="text-center">No teams in championship</td>
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- Matches Section -->
    <div class="col-md-4">
        <div class="card">
            <div class="card-header">
                <h3 class="card-title h5 mb-0">Recent Matches</h3>
            </div>
            <div class="card-body">
                {% if matches %}
                    {% regroup matches by round as round_list %}
                    {% for round in round_list %}
                    <div class="mb-4">
                        <h4 class="h6">Round {{ round.grouper }}</h4>
                        <div class="list-group">
                            {% for match in round.list %}
                            <a href="{% url 'matches:match_detail' match.match.id %}" class="list-group-item list-group-item-action">
                                <div class="d-flex justify-content-between align-items-center">
                                    <small>{{ match.match.datetime|date:"d M Y H:i" }}</small>
                                    <span class="badge {% if match.match.status == 'finished' %}bg-success{% elif match.match.status == 'in_progress' %}bg-warning{% else %}bg-secondary{% endif %}">
                                        {{ match.match.get_status_display }}
                                    </span>
                                </div>
                                <div class="d-flex justify-content-between align-items-center mt-2">
                                    <span class="{% if match.match.home_team == user.club %}fw-bold{% endif %}">
                                        {{ match.match.home_team.name }}
                                        {% if match.match.home_team.is_bot %}
                                            <small>(Bot)</small>
                                        {% endif %}
                                    </span>
                                    {% if match.match.status == 'finished' %}
                                        <strong>{{ match.match.home_score }} - {{ match.match.away_score }}</strong>
                                    {% else %}
                                        <span>vs</span>
                                    {% endif %}
                                    <span class="{% if match.match.away_team == user.club %}fw-bold{% endif %}">
                                        {{ match.match.away_team.name }}
                                        {% if match.match.away_team.is_bot %}
                                            <small>(Bot)</small>
                                        {% endif %}
                                    </span>
                                </div>
                            </a>
                            {% endfor %}
                        </div>
                    </div>
                    {% endfor %}
                {% else %}
                    <p class="text-center">No matches scheduled</p>
                {% endif %}
                <div class="text-center mt-3">
                    <a href="{% url 'matches:championship_matches' championship.id %}" class="btn btn-outline-primary">
                        View All Matches
                    </a>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Timezone Modal -->
<div class="modal fade timezone-modal" id="timezonesModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Select Timezone</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                {% include 'tournaments/timezone_selector.html' %}
            </div>
        </div>
    </div>
</div>
{% endblock %}

================
File: tournaments/templates/tournaments/championship_list.html
================
{% extends 'tournaments/base.html' %}

{% block tournament_content %}
<div class="row">
    <div class="col-12">
        <h2 class="mb-4">Championships</h2>

        {% if active_seasons %}
        <div class="mb-5">
            <h3>Active Seasons</h3>
            {% for season in active_seasons %}
            <div class="card mb-4">
                <div class="card-header">
                    <h4 class="mb-0">{{ season.name }}</h4>
                </div>
                <div class="card-body">
                    {% regroup championships|dictsort:"league.country" by league.country as country_list %}
                    {% for country in country_list %}
                    {% if country.list|length > 0 %}
                    <h5 class="mt-3">{{ country.grouper }}</h5>
                    <div class="row">
                        {% for championship in country.list %}
                        {% if championship.season == season %}
                        <div class="col-md-6 mb-3">
                            <div class="card h-100">
                                <div class="card-body">
                                    <h5 class="card-title">{{ championship.league.name }}</h5>
                                    <p class="text-muted small">Division {{ championship.league.level }}</p>
                                    <p class="card-text">
                                        Status: {{ championship.get_status_display }}<br>
                                        Teams: {{ championship.teams.count }}/{{ championship.league.max_teams }}
                                    </p>
                                    {% if championship.teams.count > 0 %}
                                    <small class="text-muted">Participating teams:</small>
                                    <div class="mt-2 small">
                                        {% for team in championship.teams.all|slice:":5" %}
                                        <a href="{% url 'clubs:club_detail' team.id %}" class="text-decoration-none">
                                            {{ team.name }}{% if not forloop.last %}, {% endif %}
                                        </a>
                                        {% endfor %}
                                        {% if championship.teams.count > 5 %}
                                        <span class="text-muted">and {{ championship.teams.count|add:"-5" }} more...</span>
                                        {% endif %}
                                    </div>
                                    {% endif %}
                                </div>
                                <div class="card-footer bg-transparent">
                                    <a href="{% url 'tournaments:championship_detail' championship.pk %}" 
                                       class="btn btn-primary btn-sm">View Details</a>
                                </div>
                            </div>
                        </div>
                        {% endif %}
                        {% endfor %}
                    </div>
                    {% endif %}
                    {% endfor %}
                </div>
            </div>
            {% endfor %}
        </div>
        {% endif %}

        <div class="mb-4">
            <h3>All Championships</h3>
            {% regroup championships|dictsort:"league.country.name" by league.country.name as country_list %}
            {% for country in country_list %}
            <div class="card mb-4">
                <div class="card-header">
                    <h4 class="mb-0">{{ country.grouper }}</h4>
                </div>
                <div class="card-body">
                    <div class="row">
                        {% for championship in country.list %}
                        <div class="col-md-6 mb-3">
                            <div class="card h-100">
                                <div class="card-body">
                                    <h5 class="card-title">{{ championship.league.name }}</h5>
                                    <h6 class="card-subtitle mb-2 text-muted">{{ championship.season.name }}</h6>
                                    <p class="small">Division {{ championship.league.level }}</p>
                                    <p class="card-text">
                                        Status: {{ championship.get_status_display }}<br>
                                        Teams: {{ championship.teams.count }}/{{ championship.league.max_teams }}
                                    </p>
                                    {% if championship.teams.count > 0 %}
                                    <small class="text-muted">Teams:</small>
                                    <div class="mt-2 small">
                                        {% for team in championship.teams.all|slice:":5" %}
                                        <a href="{% url 'clubs:club_detail' team.id %}" class="text-decoration-none">
                                            {{ team.name }}{% if not forloop.last %}, {% endif %}
                                        </a>
                                        {% endfor %}
                                        {% if championship.teams.count > 5 %}
                                        <span class="text-muted">and {{ championship.teams.count|add:"-5" }} more...</span>
                                        {% endif %}
                                    </div>
                                    {% endif %}
                                </div>
                                <div class="card-footer bg-transparent">
                                    <a href="{% url 'tournaments:championship_detail' championship.pk %}" 
                                       class="btn btn-primary btn-sm">View Details</a>
                                </div>
                            </div>
                        </div>
                        {% endfor %}
                    </div>
                </div>
            </div>
            {% empty %}
            <div class="alert alert-info">
                No championships available.
            </div>
            {% endfor %}
        </div>
    </div>
</div>
{% endblock %}

================
File: tournaments/templates/tournaments/league_list.html
================
{% extends 'tournaments/base.html' %}
{% block tournament_content %}
<div class="row">
    <div class="col-12">
        <div class="d-flex justify-content-between align-items-center mb-4">
            <h2>Leagues</h2>
            {% if user.is_staff %}
            <a href="{% url 'admin:tournaments_league_add' %}" class="btn btn-primary">
                Create New League
            </a>
            {% endif %}
        </div>

        {% for country, leagues in countries.items %}
        <div class="card mb-4">
            <div class="card-header">
                <h3 class="h5 mb-0">{{ country.name }}</h3>
            </div>
            <div class="card-body">
                <div class="row">
                    {% for league in leagues %}
                    <div class="col-md-6 mb-3">
                        <div class="card h-100">
                            <div class="card-body">
                                <h4 class="h5 card-title">{{ league.name }}</h4>
                                <p class="text-muted small mb-3">Division {{ league.level }}</p>
                                
                                <div class="mb-3">
                                    <strong>League Info:</strong>
                                    <ul class="list-unstyled mt-2">
                                        <li><i class="bi bi-people"></i> Teams: {{ league.clubs.count }}/{{ league.max_teams }}</li>
                                        <li><i class="bi bi-globe"></i> Foreign Players Limit: {{ league.foreign_players_limit }}</li>
                                        {% with championship_count=league.championship_set.count %}
                                        <li><i class="bi bi-trophy"></i> Championships: {{ championship_count }}</li>
                                        {% endwith %}
                                    </ul>
                                </div>

                                {% if league.clubs.exists %}
                                <div class="mb-3">
                                    <strong>Current Teams:</strong>
                                    <div class="mt-2 small">
                                        {% for club in league.clubs.all|slice:":5" %}
                                        <a href="{% url 'clubs:club_detail' club.id %}" class="text-decoration-none">
                                            {{ club.name }}
                                            {% if club.is_bot %}<small>(Bot)</small>{% endif %}
                                            {% if not forloop.last %}, {% endif %}
                                        </a>
                                        {% endfor %}
                                        {% if league.clubs.count > 5 %}
                                        <span class="text-muted">and {{ league.clubs.count|add:"-5" }} more...</span>
                                        {% endif %}
                                    </div>
                                </div>
                                {% endif %}

                                {% if league.championship_set.exists %}
                                <div class="mb-3">
                                    <strong>Current Season:</strong>
                                    {% with current_championship=league.championship_set.filter.first %}
                                    <p class="small mt-2 mb-0">
                                        {{ current_championship.season.name }}
                                        ({{ current_championship.get_status_display }})
                                    </p>
                                    {% endwith %}
                                </div>
                                {% endif %}
                            </div>
                            <div class="card-footer bg-transparent">
                                <div class="btn-group w-100">
                                    {% if league.championship_set.exists %}
                                    <a href="{% url 'tournaments:championship_detail' league.championship_set.first.id %}" 
                                       class="btn btn-outline-primary">View Current Season</a>
                                    {% endif %}
                                    {% if user.is_staff %}
                                    <a href="{% url 'admin:tournaments_league_change' league.id %}" 
                                       class="btn btn-outline-secondary">Edit</a>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                    </div>
                    {% endfor %}
                </div>
            </div>
        </div>
        {% empty %}
        <div class="alert alert-info">
            No leagues available yet.
            {% if user.is_staff %}
            <a href="{% url 'admin:tournaments_league_add' %}" class="alert-link">Create one</a>
            {% endif %}
        </div>
        {% endfor %}
    </div>
</div>
{% endblock %}

================
File: tournaments/templates/tournaments/my_championship.html
================
{% extends 'tournaments/base.html' %}

{% block tournament_content %}
<div class="row">
    <!-- Header Section -->
    <div class="col-12 mb-4">
        <div class="card">
            <div class="card-body">
                <div class="d-flex justify-content-between align-items-center">
                    <div>
                        <h2>{{ championship.league.name }}</h2>
                        <p class="text-muted mb-0">
                            {{ championship.league.country.name }} - Division {{ championship.league.level }}
                        </p>
                        <p class="text-muted">
                            Season: {{ championship.season.name }} | 
                            Status: {{ championship.get_status_display }}
                        </p>
                    </div>
                    <div>
                        <a href="{% url 'tournaments:championship_list' %}" class="btn btn-outline-primary">
                            View All Championships
                        </a>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- League Table -->
    <div class="col-md-8">
        <div class="card">
            <div class="card-header">
                <h3 class="card-title h5 mb-0">League Table</h3>
            </div>
            <div class="card-body">
                <div class="table-responsive">
                    <table class="table table-hover">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Team</th>
                                <th>MP</th>
                                <th>W</th>
                                <th>D</th>
                                <th>L</th>
                                <th>GF</th>
                                <th>GA</th>
                                <th>GD</th>
                                <th>Pts</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for team in standings %}
                            <tr {% if team.team == user.club %}class="table-active"{% endif %}>
                                <td>{{ forloop.counter }}</td>
                                <td>
                                    {{ team.team.name }}
                                    {% if team.team == user.club %}
                                        <span class="badge bg-primary">Your Club</span>
                                    {% endif %}
                                </td>
                                <td>{{ team.matches_played }}</td>
                                <td>{{ team.wins }}</td>
                                <td>{{ team.draws }}</td>
                                <td>{{ team.losses }}</td>
                                <td>{{ team.goals_for }}</td>
                                <td>{{ team.goals_against }}</td>
                                <td>{% if team.goals_difference > 0 %}+{% endif %}{{ team.goals_difference }}</td>
                                <td><strong>{{ team.points }}</strong></td>
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- Team Matches -->
    <div class="col-md-4">
        <div class="card">
            <div class="card-header">
                <h3 class="card-title h5 mb-0">Your Team's Matches</h3>
            </div>
            <div class="card-body">
                <div class="list-group">
                    {% for match in team_matches %}
                    <div class="list-group-item">
                        <div class="d-flex justify-content-between align-items-center">
                            <small>
                                Round {{ match.round }} | 
                                <a href="{% url 'matches:match_detail' match.match.id %}">
                                    {{ match.match.datetime|date:"d M H:i" }}
                                </a>
                            </small>
                            <span class="badge {% if match.match.status == 'finished' %}bg-success{% elif match.match.status == 'in_progress' %}bg-warning{% else %}bg-secondary{% endif %}">
                                {{ match.match.get_status_display }}
                            </span>
                        </div>
                        <div class="d-flex justify-content-between align-items-center mt-2">
                            <span {% if match.match.home_team == user.club %}class="fw-bold"{% endif %}>
                                {{ match.match.home_team.name }}
                            </span>
                            {% if match.match.status == 'finished' %}
                                <strong>{{ match.match.home_score }} - {{ match.match.away_score }}</strong>
                            {% else %}
                                <span>vs</span>
                            {% endif %}
                            <span {% if match.match.away_team == user.club %}class="fw-bold"{% endif %}>
                                {{ match.match.away_team.name }}
                            </span>
                        </div>
                    </div>
                    {% empty %}
                    <div class="alert alert-warning">
                        No matches found for your team.
                    </div>
                    {% endfor %}
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

================
File: tournaments/templates/tournaments/season_list.html
================
{% extends 'tournaments/base.html' %}
{% block tournament_content %}
<div class="row">
    <div class="col-12">
        <div class="d-flex justify-content-between align-items-center mb-4">
            <h2>Seasons</h2>
            {% if user.is_staff %}
            <a href="{% url 'admin:tournaments_season_add' %}" class="btn btn-primary">
                Create New Season
            </a>
            {% endif %}
        </div>

        <div class="row">
            {% for season in seasons %}
            <div class="col-md-6 mb-4">
                <div class="card h-100">
                    <div class="card-header">
                        <h5 class="card-title mb-0">
                            {{ season.name }}
                            {% if season.is_active %}
                            <span class="badge bg-success">Active</span>
                            {% endif %}
                        </h5>
                    </div>
                    <div class="card-body">
                        <div class="mb-3">
                            <strong>Season Info:</strong>
                            <ul class="list-unstyled mt-2">
                                <li><i class="bi bi-calendar"></i> Start Date: {{ season.start_date }}</li>
                                <li><i class="bi bi-calendar"></i> End Date: {{ season.end_date }}</li>
                                {% with championship_count=season.championship_set.count %}
                                <li><i class="bi bi-trophy"></i> Championships: {{ championship_count }}</li>
                                {% endwith %}
                            </ul>
                        </div>

                        {% if season.championship_set.exists %}
                        <div class="mb-3">
                            <strong>Active Championships:</strong>
                            <div class="list-group mt-2">
                                {% for championship in season.championship_set.all %}
                                <div class="list-group-item">
                                    <div class="d-flex justify-content-between align-items-center">
                                        <div>
                                            <strong>{{ championship.league.name }}</strong>
                                            <small class="text-muted">(Division {{ championship.league.level }})</small>
                                        </div>
                                        <a href="{% url 'tournaments:championship_detail' championship.id %}" 
                                           class="btn btn-sm btn-outline-primary">View</a>
                                    </div>
                                    {% if championship.teams.exists %}
                                    <div class="small mt-2">
                                        <strong>Teams:</strong>
                                        {% for team in championship.teams.all|slice:":3" %}
                                        <a href="{% url 'clubs:club_detail' team.id %}" class="text-decoration-none">
                                            {{ team.name }}{% if not forloop.last %}, {% endif %}
                                        </a>
                                        {% endfor %}
                                        {% if championship.teams.count > 3 %}
                                        <span class="text-muted">and {{ championship.teams.count|add:"-3" }} more...</span>
                                        {% endif %}
                                    </div>
                                    {% endif %}
                                </div>
                                {% endfor %}
                            </div>
                        </div>
                        {% endif %}
                    </div>
                    <div class="card-footer bg-transparent">
                        <div class="btn-group w-100">
                            {% if user.is_staff %}
                            <a href="{% url 'admin:tournaments_season_change' season.id %}" 
                               class="btn btn-outline-secondary">Edit</a>
                            {% endif %}
                        </div>
                    </div>
                </div>
            </div>
            {% empty %}
            <div class="col-12">
                <div class="alert alert-info">
                    No seasons available yet.
                    {% if user.is_staff %}
                    <a href="{% url 'admin:tournaments_season_add' %}" class="alert-link">Create one</a>
                    {% endif %}
                </div>
            </div>
            {% endfor %}
        </div>
    </div>
</div>
{% endblock %}

================
File: tournaments/templates/tournaments/timezone_selector.html
================
<form method="post" action="{% url 'tournaments:set_timezone' %}" class="timezone-form">
    {% csrf_token %}
    <input type="hidden" name="next" value="{{ request.path }}">
    <select name="timezone" class="form-select form-select-sm" onchange="this.form.submit()">
        {% for tz, name in TOURNAMENT_TIMEZONES %}
            <option value="{{ tz }}" {% if tz == user_timezone %}selected{% endif %}>
                {{ name }}
            </option>
        {% endfor %}
    </select>
</form>

================
File: tournaments/tests.py
================
from django.test import TestCase
from django.utils import timezone
from datetime import datetime, timedelta
from django.core.exceptions import ValidationError
from django_countries import countries
from .models import Season, League, Championship, ChampionshipTeam
from .utils import generate_league_schedule, create_championship_matches, validate_championship_schedule
from clubs.models import Club

class ChampionshipSystemTests(TestCase):
    def setUp(self):
        """Настройка тестовых данных"""
        # Создаем сезон
        self.season = Season.objects.create(
            number=1,
            start_date=datetime(2024, 3, 1).date(),
            end_date=datetime(2024, 3, 30).date(),
            is_active=True
        )

        # Создаем лигу
        self.league = League.objects.create(
            name="Test League",
            country='GB',  # Великобритания
            level=1,
            max_teams=16
        )

        # Создаем тестовые клубы
        self.clubs = []
        for i in range(16):
            club = Club.objects.create(
                name=f"Test Club {i+1}",
                country='GB',
                is_bot=True
            )
            self.clubs.append(club)

        # Создаем чемпионат
        self.championship = Championship.objects.create(
            season=self.season,
            league=self.league,
            status='pending',
            start_date=self.season.start_date,
            end_date=self.season.end_date
        )

        # Добавляем команды в чемпионат
        for club in self.clubs:
            ChampionshipTeam.objects.create(
                championship=self.championship,
                team=club
            )

    def test_schedule_generation_basic(self):
        """Тест базовой генерации расписания"""
        schedule = generate_league_schedule(self.championship)
        self.assertEqual(len(schedule), 240)  # 16 команд = 30 туров по 8 матчей

    def test_home_away_balance(self):
        """Тест баланса домашних/выездных матчей"""
        schedule = generate_league_schedule(self.championship)
        
        # Подсчет домашних и выездных матчей для каждой команды
        home_games = {club: 0 for club in self.clubs}
        away_games = {club: 0 for club in self.clubs}
        
        for round_num, day, home, away in schedule:
            home_games[home] += 1
            away_games[away] += 1
        
        # Проверяем баланс для каждой команды
        for club in self.clubs:
            self.assertEqual(home_games[club], 15, 
                           f"Команда {club} имеет {home_games[club]} домашних матчей вместо 15")
            self.assertEqual(away_games[club], 15, 
                           f"Команда {club} имеет {away_games[club]} выездных матчей вместо 15")

    def test_consecutive_matches(self):
        """Тест на последовательные домашние/выездные матчи"""
        schedule = generate_league_schedule(self.championship)
        
        # Создаем словарь матчей для каждой команды
        team_schedules = {club: [] for club in self.clubs}
        for round_num, day, home, away in sorted(schedule):
            team_schedules[home].append(('home', round_num))
            team_schedules[away].append(('away', round_num))
        
        # Проверяем каждую команду
        for club, matches in team_schedules.items():
            matches.sort(key=lambda x: x[1])  # Сортируем по номеру тура
            
            consecutive_home = 0
            consecutive_away = 0
            
            for match_type, _ in matches:
                if match_type == 'home':
                    consecutive_home += 1
                    consecutive_away = 0
                else:
                    consecutive_away += 1
                    consecutive_home = 0
                
                self.assertLess(consecutive_home, 3,
                              f"Команда {club} имеет более 2 домашних матчей подряд")
                self.assertLess(consecutive_away, 3,
                              f"Команда {club} имеет более 2 выездных матчей подряд")

    def test_all_matches_in_one_day(self):
        """Тест, что все матчи тура проходят в один день"""
        create_championship_matches(self.championship)
        
        matches = self.championship.championshipmatch_set.all()
        rounds = matches.values('round').distinct()
        
        for round_data in rounds:
            round_num = round_data['round']
            round_matches = matches.filter(round=round_num)
            
            # Собираем все даты матчей в этом туре
            match_dates = set()
            for match in round_matches:
                match_dates.add(match.match.date.date())
            
            # Проверяем, что все матчи в один день
            self.assertEqual(len(match_dates), 1,
                           f"Матчи тура {round_num} проходят в разные дни: {match_dates}")

    def test_february_schedule(self):
        """Тест для февральского расписания"""
        # Создаем февральский сезон
        february_season = Season.objects.create(
            number=2,
            start_date=datetime(2024, 2, 1).date(),
            end_date=datetime(2024, 2, 28).date(),
            is_active=False
        )
        
        february_championship = Championship.objects.create(
            season=february_season,
            league=self.league,
            status='pending',
            start_date=february_season.start_date,
            end_date=february_season.end_date
        )
        
        # Добавляем те же команды
        for club in self.clubs:
            ChampionshipTeam.objects.create(
                championship=february_championship,
                team=club
            )
        
        create_championship_matches(february_championship)
        self.assertTrue(validate_championship_schedule(february_championship))

        # Проверяем наличие двойных туров 15 февраля
        double_matchday_matches = february_championship.championshipmatch_set.filter(
            match__date__date=datetime(2024, 2, 15).date()
        )
        self.assertEqual(double_matchday_matches.count(), 16,  # 8 матчей * 2 тура
                        "Неверное количество матчей в двойной игровой день")

================
File: tournaments/tests/test_championships.py
================
# tournaments/tests/test_championships.py
from django.test import TestCase
from django.utils import timezone
from datetime import datetime, timedelta
from django.core.exceptions import ValidationError
from django_countries import countries
from tournaments.models import Season, League, Championship, ChampionshipTeam
from tournaments.utils import generate_league_schedule, create_championship_matches, validate_championship_schedule
from clubs.models import Club

class ChampionshipSystemTests(TestCase):
    def setUp(self):
        """Настройка тестовых данных"""
        # Создаем сезон
        self.season = Season.objects.create(
            name="Сезон 1",
            number=1,  # Добавляем обязательное поле number
            start_date=datetime(2024, 3, 1).date(),
            end_date=datetime(2024, 3, 30).date(),
            is_active=True
        )

        # Создаем лигу
        self.league = League.objects.create(
            name="Test League",
            country='GB',  # Великобритания
            level=1,
            max_teams=16
        )

        # Создаем тестовые клубы
        self.clubs = []
        for i in range(16):
            club = Club.objects.create(
                name=f"Test Club {i+1}",
                country='GB',
                is_bot=True
            )
            self.clubs.append(club)

        # Создаем чемпионат
        self.championship = Championship.objects.create(
            season=self.season,
            league=self.league,
            status='pending',
            start_date=self.season.start_date,
            end_date=self.season.end_date
        )

        # Добавляем команды в чемпионат
        for club in self.clubs:
            ChampionshipTeam.objects.create(
                championship=self.championship,
                team=club
            )

    def test_schedule_generation_basic(self):
        """Тест базовой генерации расписания"""
        schedule = generate_league_schedule(self.championship)
        
        # Проверяем общее количество матчей
        # 16 команд, каждая играет с каждой дважды = 16 * 15 = 240 матчей
        self.assertEqual(len(schedule), 240, 
                        "Неверное общее количество матчей")
        
        # Проверяем количество туров
        rounds = {match[0] for match in schedule}
        self.assertEqual(len(rounds), 30, 
                        "Должно быть 30 туров")

    def test_home_away_balance(self):
        """Тест баланса домашних/выездных матчей"""
        schedule = generate_league_schedule(self.championship)
        
        # Подсчет домашних и выездных матчей для каждой команды
        home_games = {club: 0 for club in self.clubs}
        away_games = {club: 0 for club in self.clubs}
        
        for round_num, day, home, away in schedule:
            home_games[home] += 1
            away_games[away] += 1
        
        # Проверяем баланс для каждой команды
        for club in self.clubs:
            self.assertEqual(home_games[club], 15, 
                           f"Команда {club} имеет {home_games[club]} домашних матчей вместо 15")
            self.assertEqual(away_games[club], 15, 
                           f"Команда {club} имеет {away_games[club]} выездных матчей вместо 15")

    def test_consecutive_matches(self):
        """Тест на последовательные домашние/выездные матчи"""
        schedule = generate_league_schedule(self.championship)
        
        # Создаем словарь матчей для каждой команды
        team_schedules = {club: [] for club in self.clubs}
        for round_num, day, home, away in sorted(schedule):
            team_schedules[home].append(('home', round_num))
            team_schedules[away].append(('away', round_num))
        
        # Проверяем каждую команду
        for club, matches in team_schedules.items():
            matches.sort(key=lambda x: x[1])  # Сортируем по номеру тура
            
            consecutive_home = 0
            consecutive_away = 0
            max_consecutive_home = 0
            max_consecutive_away = 0
            
            for match_type, _ in matches:
                if match_type == 'home':
                    consecutive_home += 1
                    consecutive_away = 0
                    max_consecutive_home = max(max_consecutive_home, consecutive_home)
                else:
                    consecutive_away += 1
                    consecutive_home = 0
                    max_consecutive_away = max(max_consecutive_away, consecutive_away)
                
            self.assertLess(max_consecutive_home, 3,
                          f"Команда {club} имеет {max_consecutive_home} домашних матчей подряд")
            self.assertLess(max_consecutive_away, 3,
                          f"Команда {club} имеет {max_consecutive_away} выездных матчей подряд")

    def test_all_matches_in_round_same_time(self):
        """Тест, что все матчи тура проходят в одно время"""
        create_championship_matches(self.championship)
        
        matches = self.championship.championshipmatch_set.all()
        rounds = matches.values('round').distinct()
        
        for round_data in rounds:
            round_num = round_data['round']
            round_matches = matches.filter(round=round_num)
            
            # Собираем все времена матчей в этом туре
            match_times = set()
            for match in round_matches:
                match_times.add(match.match.date)
            
            # Проверяем, что все матчи в одно время
            self.assertEqual(len(match_times), 1,
                           f"Матчи тура {round_num} проходят в разное время")

    def test_regular_season_schedule(self):
        """Тест расписания для обычного сезона"""
        create_championship_matches(self.championship)
        
        matches = self.championship.championshipmatch_set.all()
        # Проверяем, что каждый день проводится только один тур
        match_dates = matches.values_list('match__date__date', flat=True).distinct()
        self.assertEqual(len(match_dates), 30, 
                        "Должно быть 30 игровых дней для 30 туров")

        # Проверяем время начала матчей
        for match_date in match_dates:
            date_matches = matches.filter(match__date__date=match_date)
            match_times = set(date_matches.values_list('match__date__hour', flat=True))
            self.assertEqual(len(match_times), 1,
                           f"В обычный день {match_date} должен быть только один тур")
            self.assertEqual(list(match_times)[0], 18,
                           "Все матчи должны начинаться в 18:00")

   # Изменения в тестовом файле
def test_february_schedule(self):
    """Тест для февральского расписания"""
    # Создаем февральский сезон
    february_season = Season.objects.create(
        name="Сезон 2",
        number=2,
        start_date=datetime(2024, 2, 1).date(),
        end_date=datetime(2024, 2, 28).date(),
        is_active=False
    )
    
    february_championship = Championship.objects.create(
        season=february_season,
        league=self.league,
        status='pending',
        start_date=february_season.start_date,
        end_date=february_season.end_date
    )
    
    # Добавляем те же команды
    for club in self.clubs:
        ChampionshipTeam.objects.create(
            championship=february_championship,
            team=club
        )
    
    create_championship_matches(february_championship)
    matches = february_championship.championshipmatch_set.all()
    
    # Проверяем, что в обычные дни все матчи тура в 18:00
    for day in range(1, 29):
        if day not in [15, 16]:  # Не двойные туры
            date_matches = matches.filter(
                match__date__date=datetime(2024, 2, day).date()
            )
            if date_matches.exists():
                # Проверяем только время начала
                match_hours = set(date_matches.values_list(
                    'match__date__hour', flat=True
                ))
                self.assertEqual(match_hours, {18},
                               f"Матчи в день {day} февраля должны начинаться в 18:00")
    
    # Проверяем двойные туры (15 и 16 февраля)
    for day in [15, 16]:
        date_matches = matches.filter(
            match__date__date=datetime(2024, 2, day).date()
        )
        match_hours = set(date_matches.values_list(
            'match__date__hour', flat=True
        ))
        self.assertEqual(match_hours, {18, 20},
                       f"В двойной игровой день {day} февраля матчи должны начинаться в 18:00 и 20:00")

================
File: tournaments/tests/test_season_transitions.py
================
from django.test import TestCase
from django.utils import timezone
from django.core.management import call_command
from tournaments.models import Season, League, Championship, ChampionshipTeam
from tournaments.tasks import check_season_end
from clubs.models import Club
from datetime import timedelta
from django.db import transaction

class SeasonTransitionTests(TestCase):
    def setUp(self):
        """
        Настройка тестового окружения.
        Создаём сезон, лиги, команды и чемпионаты
        """
        # Создаем сезон
        self.season = Season.objects.create(
            number=1,
            name="Test Season",
            start_date=timezone.now().date(),
            end_date=timezone.now().date() + timedelta(days=30),
            is_active=True
        )

        # Создаем две лиги для одной страны
        self.league_div1 = League.objects.create(
            name="Test League D1",
            country='GB',
            level=1,
            max_teams=16
        )
        
        self.league_div2 = League.objects.create(
            name="Test League D2",
            country='GB',
            level=2,
            max_teams=16
        )

        # Создаем команды для обоих дивизионов
        self.div1_teams = []
        self.div2_teams = []

        with transaction.atomic():
            # Создаём команды первого дивизиона
            for i in range(16):
                team = Club.objects.create(
                    name=f"D1 Team {i+1}",
                    country='GB',
                    league=self.league_div1,
                    is_bot=True
                )
                self.div1_teams.append(team)

            # Создаём команды второго дивизиона
            for i in range(16):
                team = Club.objects.create(
                    name=f"D2 Team {i+1}",
                    country='GB',
                    league=self.league_div2,
                    is_bot=True
                )
                self.div2_teams.append(team)

            # Создаем чемпионаты
            self.championship_div1 = Championship.objects.create(
                season=self.season,
                league=self.league_div1,
                status='in_progress',
                start_date=self.season.start_date,
                end_date=self.season.end_date
            )

            self.championship_div2 = Championship.objects.create(
                season=self.season,
                league=self.league_div2,
                status='in_progress',
                start_date=self.season.start_date,
                end_date=self.season.end_date
            )

            # Добавляем команды в чемпионат первого дивизиона
            for team in self.div1_teams:
                self.championship_div1.teams.add(team)
                ChampionshipTeam.objects.filter(
                    championship=self.championship_div1,
                    team=team
                ).update(
                    points=0,
                    matches_played=0,
                    wins=0,
                    draws=0,
                    losses=0,
                    goals_for=0,
                    goals_against=0
                )

            # Добавляем команды в чемпионат второго дивизиона
            for team in self.div2_teams:
                self.championship_div2.teams.add(team)
                ChampionshipTeam.objects.filter(
                    championship=self.championship_div2,
                    team=team
                ).update(
                    points=0,
                    matches_played=0,
                    wins=0,
                    draws=0,
                    losses=0,
                    goals_for=0,
                    goals_against=0
                )

    def test_season_transitions(self):
        """Тестируем процесс переходов между дивизионами"""
        
        # Устанавливаем результаты для команд первого дивизиона
        div1_teams = ChampionshipTeam.objects.filter(
            championship=self.championship_div1
        )
        for i, team_stats in enumerate(div1_teams):
            team_stats.points = 80 - i * 5  # От 80 до 5 очков
            team_stats.matches_played = 30
            team_stats.save()

        # Устанавливаем результаты для команд второго дивизиона
        div2_teams = ChampionshipTeam.objects.filter(
            championship=self.championship_div2
        )
        for i, team_stats in enumerate(div2_teams):
            team_stats.points = 80 - i * 5  # От 80 до 5 очков
            team_stats.matches_played = 30
            team_stats.save()

        # Завершаем сезон и запускаем переходы
        self.season.end_date = timezone.now().date() - timedelta(days=1)
        self.season.save()
        
        # Запускаем обработку переходов
        call_command('handle_season_transitions')

        # Проверяем что две худшие команды из D1 перешли в D2
        relegated_teams = div1_teams.order_by('points')[:2]
        for team_stats in relegated_teams:
            team = Club.objects.get(id=team_stats.team.id)
            self.assertEqual(
                team.league, 
                self.league_div2,
                f"Team {team.name} should be relegated to D2"
            )

        # Проверяем что две лучшие команды из D2 перешли в D1
        promoted_teams = div2_teams.order_by('-points')[:2]
        for team_stats in promoted_teams:
            team = Club.objects.get(id=team_stats.team.id)
            self.assertEqual(
                team.league, 
                self.league_div1,
                f"Team {team.name} should be promoted to D1"
            )

    def test_new_season_creation(self):
        """Тестируем создание нового сезона после переходов"""
        
        # Завершаем текущий сезон
        self.season.end_date = timezone.now().date() - timedelta(days=1)
        self.season.save()
        
        # Запускаем процесс создания нового сезона
        call_command('create_new_season')

        # Проверяем что новый сезон создан
        new_season = Season.objects.get(number=self.season.number + 1)
        self.assertTrue(new_season.is_active)
        
        # Проверяем что созданы чемпионаты
        new_championships = Championship.objects.filter(season=new_season)
        self.assertEqual(new_championships.count(), 2)
        
        # Проверяем корректность распределения команд
        for championship in new_championships:
            self.assertEqual(
                championship.teams.count(), 
                16,
                f"Championship {championship} should have 16 teams"
            )

    def test_full_transition_process(self):
        """Тестируем полный процесс перехода к новому сезону"""
        
        # Завершаем текущий сезон
        self.season.end_date = timezone.now().date() - timedelta(days=1)
        self.season.save()

        # Запускаем проверку окончания сезона через Celery задачу
        check_season_end()

        # Проверяем что старый сезон неактивен
        old_season = Season.objects.get(id=self.season.id)
        self.assertFalse(old_season.is_active)

        # Проверяем что создан новый сезон
        new_season = Season.objects.get(is_active=True)
        self.assertNotEqual(new_season.id, self.season.id)

        # Проверяем корректность переходов
        # В первом дивизионе должны остаться 14 старых команд + 2 новых
        div1_championship = Championship.objects.get(
            season=new_season,
            league=self.league_div1
        )
        self.assertEqual(div1_championship.teams.count(), 16)

        # Во втором дивизионе должны остаться 14 старых команд + 2 новых
        div2_championship = Championship.objects.get(
            season=new_season,
            league=self.league_div2
        )
        self.assertEqual(div2_championship.teams.count(), 16)

    def tearDown(self):
        """Очистка после тестов"""
        Season.objects.all().delete()
        League.objects.all().delete()
        Club.objects.all().delete()

================
File: tournaments/timezone_middleware.py
================
from django.utils import timezone
import pytz

class TimezoneMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        tzname = request.session.get('django_timezone')
        if tzname:
            timezone.activate(pytz.timezone(tzname))
        else:
            timezone.deactivate()
        return self.get_response(request)

================
File: tournaments/urls.py
================
from django.urls import path
from . import views

app_name = 'tournaments'

urlpatterns = [
    path('', views.ChampionshipListView.as_view(), name='championship_list'),
    path('championship/<int:pk>/', views.ChampionshipDetailView.as_view(), name='championship_detail'),
    path('championship/<int:pk>/calendar/', views.ChampionshipCalendarView.as_view(), name='championship_calendar'),
    path('seasons/', views.SeasonListView.as_view(), name='season_list'),
    path('leagues/', views.LeagueListView.as_view(), name='league_list'),
    path('set-timezone/', views.set_timezone, name='set_timezone'),
    path('api/matches/<int:pk>/', views.get_championship_matches, name='api_matches'),
    path('my-championship/', views.MyChampionshipView.as_view(), name='my_championship'),
]

================
File: tournaments/utils.py
================
from typing import List, Tuple, Dict
from datetime import datetime, timedelta
from django.utils import timezone
from django.db import models, transaction
import calendar

def check_consecutive_matches(schedule: List[Tuple], team, is_home: bool) -> int:
    """
    Проверяет количество последовательных домашних или гостевых матчей для команды.
    """
    max_consecutive = 0
    current_consecutive = 0

    for match in schedule:
        if is_home:
            is_match = match[2] == team  # домашняя команда
        else:
            is_match = match[3] == team  # гостевая команда

        if is_match:
            current_consecutive += 1
            max_consecutive = max(max_consecutive, current_consecutive)
        else:
            current_consecutive = 0

    return max_consecutive

def get_team_matches(schedule: List[Tuple], team) -> List[Tuple[int, bool]]:
    """
    Возвращает список матчей команды с информацией о домашних/гостевых играх.
    """
    team_matches = []
    for round_num, day, home, away in schedule:
        if home == team:
            team_matches.append((round_num, True))
        elif away == team:
            team_matches.append((round_num, False))
    return sorted(team_matches)

def validate_schedule_balance(schedule: List[Tuple], teams: List) -> Dict:
    """
    Проверяет баланс домашних и гостевых матчей для каждой команды.
    """
    balance = {team: {'home': 0, 'away': 0} for team in teams}

    for _, _, home, away in schedule:
        balance[home]['home'] += 1
        balance[away]['away'] += 1

    return balance

def generate_league_schedule(championship) -> List[Tuple]:
    """
    Генерирует сбалансированное расписание матчей по принципу кругового турнира.
    """
    from .models import Championship  # Импорт внутри функции
    
    teams = list(championship.teams.all())
    if len(teams) != 16:
        raise ValueError(f"Требуется ровно 16 команд, сейчас: {len(teams)}")
    
    n = len(teams)
    rounds = n - 1
    schedule = []
    
    # Создаем массив с номерами команд
    team_numbers = list(range(n))
    
    # Генерируем матрицу встреч
    matches = []
    for round_num in range(rounds):
        round_matches = []
        for i in range(n // 2):
            home = team_numbers[i]
            away = team_numbers[n - i - 1]
            # Чередуем домашние и выездные матчи
            if (i + round_num) % 2 == 0:
                round_matches.append((home, away))
            else:
                round_matches.append((away, home))
        matches.append(round_matches)
        # Ротация команд
        team_numbers = [team_numbers[0]] + team_numbers[-1:] + team_numbers[1:-1]
    
    # Создаем расписание для первого и второго кругов
    for half in range(2):
        for round_num in range(rounds):
            actual_round = round_num + 1 + half * rounds
            round_matches = matches[round_num]
            for match_num, (home_idx, away_idx) in enumerate(round_matches):
                if half == 1:
                    # Во втором круге меняем хозяев и гостей
                    home_idx, away_idx = away_idx, home_idx
                home_team = teams[home_idx]
                away_team = teams[away_idx]
                schedule.append((actual_round, match_num + 1, home_team, away_team))
    
    return schedule

def create_championship_matches(championship) -> None:
    """
    Создает матчи чемпионата на основе сгенерированного расписания.
    """
    from .models import ChampionshipMatch  # Импорт внутри функции
    from matches.models import Match  # Импорт внутри функции
    
    with transaction.atomic():
        ChampionshipMatch.objects.filter(championship=championship).delete()

        schedule = generate_league_schedule(championship)
        matches_by_round = {}
        
        # Группируем матчи по турам
        for round_num, day, home_team, away_team in schedule:
            if round_num not in matches_by_round:
                matches_by_round[round_num] = []
            matches_by_round[round_num].append((day, home_team, away_team))
            
        current_date = championship.start_date

        # Создаем матчи
        for round_num in sorted(matches_by_round.keys()):
            match_time = championship.match_time
            if championship.league.level == 2:
                match_time = (
                    datetime.combine(datetime.min, match_time) - 
                    timedelta(hours=2)
                ).time()

            match_datetime = timezone.make_aware(
                datetime.combine(current_date, match_time)
            )

            for day, home_team, away_team in matches_by_round[round_num]:
                match = Match.objects.create(
                    home_team=home_team,
                    away_team=away_team,
                    datetime=match_datetime,
                    status='scheduled'
                )

                ChampionshipMatch.objects.create(
                    championship=championship,
                    match=match,
                    round=round_num,
                    match_day=current_date.day
                )

            current_date += timedelta(days=1)

def validate_championship_schedule(championship) -> bool:
    """
    Проверяет корректность расписания чемпионата.
    """
    from .models import Championship  # Импорт внутри функции
    
    matches = championship.championshipmatch_set.select_related('match')
    teams = list(championship.teams.all())

    # Проверка количества матчей
    expected_matches = len(teams) * (len(teams) - 1)
    if matches.count() != expected_matches:
        return False

    # Проверка баланса матчей
    team_matches = {team: {'home': 0, 'away': 0} for team in teams}
    for match in matches:
        team_matches[match.match.home_team]['home'] += 1
        team_matches[match.match.away_team]['away'] += 1

    for team, stats in team_matches.items():
        if stats['home'] != (len(teams) - 1) or stats['away'] != (len(teams) - 1):
            return False

    # Проверка последовательности матчей
    for team in teams:
        team_schedule = list(matches.filter(
            models.Q(match__home_team=team) | models.Q(match__away_team=team)
        ).order_by('round'))

        home_streak = 0
        away_streak = 0
        max_home_streak = 0
        max_away_streak = 0

        for match in team_schedule:
            if match.match.home_team == team:
                home_streak += 1
                away_streak = 0
                max_home_streak = max(max_home_streak, home_streak)
            else:
                away_streak += 1
                home_streak = 0
                max_away_streak = max(max_away_streak, away_streak)

        if max_home_streak > 2 or max_away_streak > 2:
            return False

    return True

================
File: tournaments/views.py
================
from django.views.generic import ListView, DetailView
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.contrib import messages
from django.core.exceptions import ObjectDoesNotExist
from django.http import Http404
from django.urls import reverse
from django.conf import settings
import json
from django.utils import timezone
from django.http import JsonResponse
from django.db import models
from .models import Championship, Season, League

class ChampionshipListView(LoginRequiredMixin, ListView):
    model = Championship
    template_name = 'tournaments/championship_list.html'
    context_object_name = 'championships'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['active_seasons'] = Season.objects.filter(is_active=True)
        context['championships'] = Championship.objects.all().select_related(
            'league', 'season'
        ).order_by('league__level')
        return context

class ChampionshipDetailView(LoginRequiredMixin, DetailView):
    model = Championship
    template_name = 'tournaments/championship_detail.html'
    context_object_name = 'championship'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        
        context['standings'] = (
            self.object.championshipteam_set
            .annotate(
                goals_diff=models.F('goals_for') - models.F('goals_against')
            )
            .order_by('-points', '-goals_diff', '-goals_for')
        )
        
        matches = self.object.championshipmatch_set.all().select_related(
            'match', 
            'match__home_team', 
            'match__away_team'
        ).order_by('round', 'match__datetime')
        
        context['matches'] = matches
        
        calendar_events = []
        for match in matches:
            calendar_events.append({
                'id': match.id,
                'title': f"{match.match.home_team} vs {match.match.away_team}",
                'start': match.match.datetime.isoformat(),
                'status': match.match.status,
                'score': f"{match.match.home_score} - {match.match.away_score}" if match.match.status == 'finished' else None,
                'url': reverse('matches:match_detail', args=[match.match.id]),
                'className': f"match-{match.match.status}"
            })
        
        context['calendar_events'] = json.dumps(calendar_events)
        context['user_timezone'] = self.request.session.get('timezone', timezone.get_current_timezone_name())
        
        return context

class MyChampionshipView(LoginRequiredMixin, DetailView):
    model = Championship
    template_name = 'tournaments/my_championship.html'
    
    def dispatch(self, request, *args, **kwargs):
        if not hasattr(request.user, 'club'):
            messages.warning(request, "You need to create a club first.")
            return redirect('clubs:create_club')
        return super().dispatch(request, *args, **kwargs)
    
    def get_object(self):
        try:
            return Championship.objects.select_related(
                'league',
                'season'
            ).get(
                teams=self.request.user.club,
                season__is_active=True
            )
        except Championship.DoesNotExist:
            raise Http404("No championship found for your club")
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        championship = self.object
        user_club = self.request.user.club

        # Get standings
        context['standings'] = championship.championshipteam_set.select_related(
            'team'
        ).order_by(
            '-points', 
            '-goals_for'
        )

        # Get team matches for display
        context['team_matches'] = championship.championshipmatch_set.filter(
            models.Q(match__home_team=user_club) | 
            models.Q(match__away_team=user_club)
        ).select_related(
            'match', 
            'match__home_team', 
            'match__away_team'
        ).order_by('match__datetime')

        return context

class ChampionshipCalendarView(LoginRequiredMixin, DetailView):
    model = Championship
    template_name = 'tournaments/championship_calendar.html'
    context_object_name = 'championship'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        return context

class SeasonListView(LoginRequiredMixin, ListView):
    model = Season
    template_name = 'tournaments/season_list.html'
    context_object_name = 'seasons'

class LeagueListView(LoginRequiredMixin, ListView):
    model = League
    template_name = 'tournaments/league_list.html'
    context_object_name = 'leagues'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        countries = {}
        for league in self.get_queryset().order_by('country', 'level'):
            if league.country not in countries:
                countries[league.country] = []
            countries[league.country].append(league)
        context['countries'] = countries
        return context

def set_timezone(request):
    if request.method == 'POST':
        request.session['django_timezone'] = request.POST['timezone']
        return redirect(request.POST.get('next', '/'))
    else:
        return redirect('/')

def get_championship_matches(request, pk):
    championship = Championship.objects.get(pk=pk)
    matches = championship.championshipmatch_set.all().select_related(
        'match', 
        'match__home_team', 
        'match__away_team'
    )
    
    match_data = [{
        'id': match.id,
        'round': match.round,
        'date': match.match.datetime.isoformat(),
        'home_team': match.match.home_team.name,
        'away_team': match.match.away_team.name,
        'status': match.match.status,
        'score': f"{match.match.home_score}-{match.match.away_score}" if match.match.status == 'finished' else None
    } for match in matches]
    
    return JsonResponse({'matches': match_data})
